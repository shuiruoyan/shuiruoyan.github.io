<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="浩子同学">
<meta property="og:url" content="http://www.songwh.top/index.html">
<meta property="og:site_name" content="浩子同学">
<meta property="article:author" content="浩子">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.songwh.top/"/>





  <title>浩子同学</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">浩子同学</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我的精神家园</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-主页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/about.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/04/06/%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%89%87Pyhont%E4%BB%A3%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%89%87Pyhont%E4%BB%A3%E7%A0%81/" itemprop="url">获取网络图片Pyhon代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T14:36:56+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>这是一个利用<code>Python</code>来下载网络照片的小程序，其中应用到了<code>BeautifuSoup</code>和<code>re</code>正则表达式：</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/04/06/%E8%8E%B7%E5%8F%96%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%89%87Pyhont%E4%BB%A3%E7%A0%81/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/04/06/%E4%BD%86%E8%A1%8C%E5%A5%BD%E4%BA%8B%EF%BC%8C%E8%8E%AB%E9%97%AE%E5%89%8D%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/%E4%BD%86%E8%A1%8C%E5%A5%BD%E4%BA%8B%EF%BC%8C%E8%8E%AB%E9%97%AE%E5%89%8D%E7%A8%8B/" itemprop="url">但行好事，莫问前程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T14:36:56+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%86%8D%E8%AE%A4%E7%9F%A5/" itemprop="url" rel="index">
                    <span itemprop="name">再认知</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>但行好事，莫问前程</p>
<p>回望去年元旦时夸的各种海口，略感惭愧，我还是高估了自己一年能做事情的数量，2018即将到来，无论这一年过的是多么的苟且与狼狈，总结还是要有一个，聊以慰藉，寄以希望。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/04/06/%E4%BD%86%E8%A1%8C%E5%A5%BD%E4%BA%8B%EF%BC%8C%E8%8E%AB%E9%97%AE%E5%89%8D%E7%A8%8B/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/04/06/Markdown%E6%A0%B7%E5%BC%8FCSS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/Markdown%E6%A0%B7%E5%BC%8FCSS/" itemprop="url">小书匠MarkDown样式CCS</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T14:36:56+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>经过不断的摸索终于搞定了小书匠在苹果手机上面的字体显示不明显问题，现在将自己重新修改过的CCS样式贴出来，以供记录：</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/04/06/Markdown%E6%A0%B7%E5%BC%8FCSS/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/04/06/activemq%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/activemq%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/" itemprop="url">ActiveMQ入门使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T00:00:00+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>演示环境： Centos7、jdk8、activemq5.15.8<br>下载地址： <a href="http://activemq.apache.org/activemq-5158-release.html" target="_blank" rel="noopener">http://activemq.apache.org/activemq-5158-release.html</a><br>解压： <code>tar -zxvf apache-activemq-5.15.8-bin.tar.gz -C /var</code><br>修改目录名称 <code>mv /var/apache-activemq-5.15.8/ /var/activemq/</code><br>启动： <code>./bin/activemq start</code><br>停止：<code>./bin/activemq stop</code></p>
<h1 id="操作练习"><a href="#操作练习" class="headerlink" title="操作练习"></a>操作练习</h1><p>1、创建一个systemd服务文件：<code>vi /usr/lib/systemd/system/activemq.service</code></p>
<p>2、 放入内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;ActiveMQ service</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;forking</span><br><span class="line">ExecStart&#x3D;&#x2F;var&#x2F;activemq&#x2F;bin&#x2F;activemq start</span><br><span class="line">ExecStop&#x3D;&#x2F;var&#x2F;activemq&#x2F;bin&#x2F;activemq stop</span><br><span class="line">User&#x3D;root</span><br><span class="line">Group&#x3D;root</span><br><span class="line">Restart&#x3D;always</span><br><span class="line">RestartSec&#x3D;9</span><br><span class="line">StandardOutput&#x3D;syslog</span><br><span class="line">StandardError&#x3D;syslog</span><br><span class="line">SyslogIdentifier&#x3D;activemq</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>
<p>3、 找到java命令所在的目录 <code>whereis java</code></p>
<p>4、设置activemq配置文件/var/activemq/bin/env中的JAVA_HOME</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Location of the java installation</span><br><span class="line"># Specify the location of your java installation using JAVA_HOME, or specify the</span><br><span class="line"># path to the &quot;java&quot; binary using JAVACMD</span><br><span class="line"># (set JAVACMD to &quot;auto&quot; for automatic detection)</span><br><span class="line">JAVA_HOME&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;java&#x2F;jdk1.8.0_181&quot;</span><br><span class="line">JAVACMD&#x3D;&quot;auto&quot;</span><br></pre></td></tr></table></figure>

<p>5、 通过systemctl管理activemq启停</p>
<ul>
<li>启动activemq服务: <code>systemctl start activemq</code></li>
<li>查看服务状态: <code>systemctl status activemq</code></li>
<li>创建软件链接：<code>ln -s /usr/lib/systemd/system/activemq.service /etc/systemd/system/multi-user.target.wants/activemq.service</code></li>
<li>开机自启: <code>systemctl enable activemq</code></li>
<li>检测是否开启成功(enable)： <code>systemctl list-unit-files |grep activemq</code></li>
</ul>
<p>6、 防火墙配置，Web管理端口默认为8161（admin/admin），通讯端口默认为61616</p>
<ul>
<li>添加并重启防火墙<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;8161&#x2F;tcp --permanent</span><br><span class="line">firewall-cmd --zone&#x3D;public --add-port&#x3D;61616&#x2F;tcp --permanent</span><br><span class="line">systemctl restart firewalld.service</span><br></pre></td></tr></table></figure></li>
<li>或者直接关闭防火墙: <code>systemctl stop firewalld.service</code></li>
</ul>
<p>7、 修改web管理系统的部分配置,配置文件在<code>/var/activemq/conf</code></p>
<ul>
<li><p>端口修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;jettyPort&quot; class&#x3D;&quot;org.apache.activemq.web.WebConsolePort&quot; init-method&#x3D;&quot;start&quot;&gt;</span><br><span class="line">  &lt;!-- the default port number for the web console --&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;host&quot; value&#x3D;&quot;0.0.0.0&quot;&#x2F;&gt;</span><br><span class="line">  &lt;!--此处即为管理平台的端口--&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;port&quot; value&#x3D;&quot;8161&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭登录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;securityConstraint&quot; class&#x3D;&quot;org.eclipse.jetty.util.security.Constraint&quot;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;BASIC&quot; &#x2F;&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;roles&quot; value&#x3D;&quot;user,admin&quot; &#x2F;&gt;</span><br><span class="line">  &lt;!-- 改为false即可关闭登陆 --&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;authenticate&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他配置: <code>/var/activemq/conf/jetty-realm.properties</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">## ---------------------------------------------------------------------------</span><br><span class="line"># 在此即可维护账号密码，格式：</span><br><span class="line"># 用户名:密码,角色</span><br><span class="line"># Defines users that can access the web (console, demo, etc.)</span><br><span class="line"># username: password [,rolename ...]</span><br><span class="line">admin: admin, admin</span><br><span class="line">user: 123, user</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>8、 JAVA客户端的使用</p>
<ul>
<li><p>标准客户端使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.apache.activemq&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;activemq-all&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.15.8&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring中使用: <code>http://spring.io/guides/gs/messaging-jms/</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-jms&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.3.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.activemq&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;activemq-broker&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.15.8&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;exclusions&gt;</span><br><span class="line">    &lt;exclusion&gt;</span><br><span class="line">        &lt;artifactId&gt;geronimo-jms_1.1_spec&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.geronimo.specs&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;&#x2F;exclusion&gt;</span><br><span class="line">    &lt;&#x2F;exclusions&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>

          
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/04/06/netty-%E7%99%BE%E4%B8%87%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/netty-%E7%99%BE%E4%B8%87%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE/" itemprop="url">Netty百万连接配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T00:00:00+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="0、-启动客户端和服务端"><a href="#0、-启动客户端和服务端" class="headerlink" title="0、 启动客户端和服务端"></a>0、 启动客户端和服务端</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 测试环境： centos7 jdk8 4核6G</span><br><span class="line"></span><br><span class="line"># 服务端启动</span><br><span class="line">java -Xmx4096m -Xms4096m -Dnetease.debug&#x3D;true -cp netty-all-4.1.32.Final.jar:netty-push-1.0.0.jar com.study.netty.push.server.WebSocketServer</span><br><span class="line"></span><br><span class="line"># 客户端</span><br><span class="line">java -Xmx4096m -Xms4096m -Dnetease.debug&#x3D;false -Dnetease.pushserver.host&#x3D;192.168.100.241 -cp netty-all-4.1.32.Final.jar:netty-push-1.0.0.jar com.study.netty.push.client.WebSocketClient</span><br></pre></td></tr></table></figure>

<h1 id="1、-too-many-openFiles-服务端和测试机都改一下"><a href="#1、-too-many-openFiles-服务端和测试机都改一下" class="headerlink" title="1、 too many openFiles  服务端和测试机都改一下"></a>1、 too many openFiles  服务端和测试机都改一下</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 进程最大文件打开添加参数最大限制</span><br><span class="line">vi &#x2F;etc&#x2F;security&#x2F;limits.conf  </span><br><span class="line">* soft nofile 1000000</span><br><span class="line">* hard nofile 1000000</span><br><span class="line"></span><br><span class="line"># 全局限制 cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-nr</span><br><span class="line">echo 1200000 &gt; &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max</span><br><span class="line"></span><br><span class="line">vi &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">fs.file-max &#x3D; 1000000</span><br></pre></td></tr></table></figure>

<h1 id="2、-客户端问题汇总"><a href="#2、-客户端问题汇总" class="headerlink" title="2、 客户端问题汇总"></a>2、 客户端问题汇总</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 客户机开不了这么多连接 ，可能的问题原因端口开放数</span><br><span class="line">linux对外随机分配的端口是有限制,理论上单机对外端口数可达65535,但实际对外可建立的连接默认最大只有28232个</span><br><span class="line">查看： cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;ip_local_port_range</span><br><span class="line">echo &quot;net.ipv4.ip_local_port_range&#x3D; 1024 65535&quot;&gt;&gt; &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line"># 如果你的机器差，出现了奇怪的问题~</span><br><span class="line">sysctl -w net.ipv4.tcp_tw_recycle&#x3D;1 #快速回收time_wait的连接</span><br><span class="line">sysctl -w net.ipv4.tcp_tw_reuse&#x3D;1 </span><br><span class="line">sysctl -w net.ipv4.tcp_timestamps&#x3D;1</span><br></pre></td></tr></table></figure>

<h1 id="3、-可能的问题"><a href="#3、-可能的问题" class="headerlink" title="3、 可能的问题"></a>3、 可能的问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 如果发现自己的用例跑不上去，就看看linux日志</span><br><span class="line">tail -f &#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line"># linux 日志</span><br><span class="line">1、 nf_conntrack: table full, dropping packet 表示防火墙的表满了，加大 nf_conntrack_max 参数</span><br><span class="line">echo &quot;net.nf_conntrack_max &#x3D; 1000000&quot;&gt;&gt; &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line"></span><br><span class="line"># 2、 TCP: too many orphaned sockets 表示内存不太够，拒绝分配，一般就是TCP缓冲区内存不够用，调大一点</span><br><span class="line"># cat &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_mem </span><br><span class="line">echo &quot;net.ipv4.tcp_mem &#x3D; 786432 2097152 16777216&quot;&gt;&gt; &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_rmem &#x3D; 4096 4096 16777216&quot;&gt;&gt; &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">echo &quot;net.ipv4.tcp_wmem &#x3D; 4096 4096 16777216&quot;&gt;&gt; &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<h1 id="4、-常规监控"><a href="#4、-常规监控" class="headerlink" title="4、  常规监控"></a>4、  常规监控</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 查看某个端口的连接情况</span><br><span class="line">netstat -nat|grep -i &quot;9001&quot;|wc -l</span><br><span class="line">netstat -n | awk &#39;&#x2F;^tcp&#x2F; &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#39;</span><br><span class="line"></span><br><span class="line"># 网络接口的带宽使用情况 </span><br><span class="line">#tcpdump https:&#x2F;&#x2F;www.cnblogs.com&#x2F;maifengqiang&#x2F;p&#x2F;3863168.html</span><br><span class="line"></span><br><span class="line"># glances工具</span><br><span class="line">yum install -y glances</span><br><span class="line">glances 控制台查看</span><br><span class="line">glances -s 服务器模式查看</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果是自己虚拟机，要记得关闭防火墙<br>systemctl stop firewalld.service</p>
</blockquote>

          
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/04/06/activemq-Broker-Cluster%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/activemq-Broker-Cluster%E9%9B%86%E7%BE%A4%E9%83%A8%E7%BD%B2/" itemprop="url">Broker-Cluster 部署</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T00:00:00+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Broker-Cluster-部署"><a href="#Broker-Cluster-部署" class="headerlink" title="Broker-Cluster 部署"></a>Broker-Cluster 部署</h1><h2 id="机器列表"><a href="#机器列表" class="headerlink" title="机器列表"></a><strong>机器列表</strong></h2><ul>
<li>192.168.100.242</li>
<li>192.168.100.243</li>
</ul>
<blockquote>
<p>为了保证机器之间网络互通，建议关闭防火墙：<code>systemctl stop firewalld.service</code></p>
</blockquote>
<h2 id="Static静态集群部署方式"><a href="#Static静态集群部署方式" class="headerlink" title="Static静态集群部署方式"></a><strong>Static静态集群部署方式</strong></h2><p>static 方式就是在broker的配置中，静态指定要连接到其它broker的地址，格式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">networkConnector</span> <span class="attr">uri</span>=<span class="string">"static:(tcp://host1:61616,tcp://host2:61616)"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong> host1、host2表示连接目标的地址，61616是连接目标开放的端口。修改配置前，先停止activemq</p>
<h3 id="一、修改配置文件"><a href="#一、修改配置文件" class="headerlink" title="一、修改配置文件"></a><strong>一、修改配置文件</strong></h3><ol>
<li>修改192.168.100.242上的/var/activemq/conf/activemq.xml，在<code>&lt;broker&gt;&lt;/broker&gt;</code>标签中添加以下代码<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">networkConnectors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">networkConnector</span> <span class="attr">uri</span>=<span class="string">"static:(tcp://192.168.100.243:61616)"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">networkConnectors</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>修改192.168.100.243上的/var/activemq/conf/activemq.xml，在<code>&lt;broker&gt;&lt;/broker&gt;</code>标签中添加以下代码<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">networkConnectors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">networkConnector</span> <span class="attr">uri</span>=<span class="string">"static:(tcp://192.168.100.242:61616)"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">networkConnectors</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="三、验证"><a href="#三、验证" class="headerlink" title="三、验证"></a><strong>三、验证</strong></h3></li>
<li>启动所有broker</li>
<li>查看日志中是否有WARN等警告/错误信息。 <code>tail -f /var/activemq/data/activemq.log</code></li>
<li>所有的broker都启动后，可以在web管理界面的Networky页面可以看到连接信息。</li>
<li>将生产者与消费者分别连接到不同的节点上，看生产者发送的消息，在消费者中能不能收到。</li>
</ol>
<h2 id="Dynamic自动发现集群部署方式"><a href="#Dynamic自动发现集群部署方式" class="headerlink" title="Dynamic自动发现集群部署方式"></a><strong>Dynamic自动发现集群部署方式</strong></h2><blockquote>
<p>ActiveMQ 通过组播方式将自己的信息发送出去，接收到的信息的机器再来连接这个发送源。默认情况下，ActiveMQ 发送的是机器名，可以通过配置修改成发送IP地址。<strong>注意机器间的网络</strong>。</p>
</blockquote>
<h3 id="一、修改配置文件-1"><a href="#一、修改配置文件-1" class="headerlink" title="一、修改配置文件"></a><strong>一、修改配置文件</strong></h3><ol>
<li>修改每台机器上的/var/activemq/conf/activemq.xml，在<broker></broker>标签中添加以下代码<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">networkConnectors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">networkConnector</span> <span class="attr">uri</span>=<span class="string">"multicast://default"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">networkConnectors</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>修改transportConnector，增加discoveryUri属性，并添加publishedAddressPolicy<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transportConnector</span> <span class="attr">name</span>=<span class="string">"openwire"</span> <span class="attr">uri</span>=<span class="string">"tcp://0.0.0.0:61616?maximumConnections=1000<span class="symbol">&amp;amp;</span>wireFormat.maxFrameSize=104857600"</span> <span class="attr">discoveryUri</span>=<span class="string">"multicast://default"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">publishedAddressPolicy</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">publishedAddressPolicy</span> <span class="attr">publishedHostStrategy</span>=<span class="string">"IPADDRESS"</span>&gt;</span><span class="tag">&lt;/<span class="name">publishedAddressPolicy</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">publishedAddressPolicy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transportConnector</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p>验证方式和上面的静态方式一致</p>
</blockquote>

          
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/04/06/activemq%E4%B8%BB%E4%BB%8E%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/activemq%E4%B8%BB%E4%BB%8E%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88/" itemprop="url">ActiveMQ主从数据库集群方案</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T00:00:00+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<blockquote>
<p>集群配置参考 <a href="http://activemq.apache.org/clustering.html" target="_blank" rel="noopener">http://activemq.apache.org/clustering.html</a></p>
</blockquote>
<h1 id="数据库共享方案"><a href="#数据库共享方案" class="headerlink" title="数据库共享方案"></a>数据库共享方案</h1><h2 id="1、-使用数据库进行消息持久化"><a href="#1、-使用数据库进行消息持久化" class="headerlink" title="1、 使用数据库进行消息持久化"></a>1、 使用数据库进行消息持久化</h2><h3 id="1-1、引入数据库驱动包和数据库连接池"><a href="#1-1、引入数据库驱动包和数据库连接池" class="headerlink" title="1.1、引入数据库驱动包和数据库连接池"></a>1.1、引入数据库驱动包和数据库连接池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">根据需要，把数据库驱动放到activemq目录下 lib&#x2F;extra</span><br><span class="line">如：mysql-connector-java-5.1.41.jar</span><br></pre></td></tr></table></figure>
<h3 id="1-2、修改activemq-xml，使用jdbc持久化"><a href="#1-2、修改activemq-xml，使用jdbc持久化" class="headerlink" title="1.2、修改activemq.xml，使用jdbc持久化"></a>1.2、修改activemq.xml，使用jdbc持久化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;var&#x2F;activemq&#x2F;conf&#x2F;activemq.xml  文件 persistenceAdapter节点</span><br><span class="line">&lt;!-- persistent&#x3D;true--&gt;</span><br><span class="line">&lt;broker brokerName&#x3D;&quot;localhost&quot; persistent&#x3D;&quot;true&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;activemq.apache.org&#x2F;schema&#x2F;core&quot;&gt;</span><br><span class="line">    &lt;persistenceAdapter&gt;</span><br><span class="line">       &lt;!-- 这里是关键 --&gt;</span><br><span class="line">        &lt;jdbcPersistenceAdapter dataSource&#x3D;&quot;#mysql-ds&quot; useDatabaseLock&#x3D;&quot;false&quot; transactionIsolation&#x3D;&quot;4&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;persistenceAdapter&gt;</span><br><span class="line">      ........</span><br><span class="line">&lt;&#x2F;broker&gt;</span><br><span class="line">&lt;!-- MySql DataSource Sample Setup --&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;mysql-ds&quot; class&#x3D;&quot;org.apache.commons.dbcp2.BasicDataSource&quot; destroy-method&#x3D;&quot;close&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;database.tony.com:3306&#x2F;test_activemq?relaxAutoCommit&#x3D;true&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;tony&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;tony&quot;&#x2F;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;poolPreparedStatements&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2、集群配置"><a href="#2、集群配置" class="headerlink" title="2、集群配置"></a>2、集群配置</h2><blockquote>
<p>多台服务器部署启动activemq服务，使用同一个数据库</p>
</blockquote>
<h2 id="3、客户端使用-http-activemq-apache-org-failover-transport-reference-html"><a href="#3、客户端使用-http-activemq-apache-org-failover-transport-reference-html" class="headerlink" title="3、客户端使用  http://activemq.apache.org/failover-transport-reference.html"></a>3、客户端使用  <a href="http://activemq.apache.org/failover-transport-reference.html" target="_blank" rel="noopener">http://activemq.apache.org/failover-transport-reference.html</a></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># brokerURI 使用failover，故障自动切换方式</span><br><span class="line"># 非failover的公共参数配置通过nested.*，例如 failover:(...)?nested.wireFormat.maxInactivityDuration&#x3D;1000</span><br><span class="line"># ?randomize&#x3D;false 随机选择，默认是顺序</span><br><span class="line"># 指定优先切换 failover:(tcp:&#x2F;&#x2F;host1:61616,tcp:&#x2F;&#x2F;host2:61616,tcp:&#x2F;&#x2F;host3:61616)?priorityBackup&#x3D;true&amp;priorityURIs&#x3D;tcp:&#x2F;&#x2F;local1:61616,tcp:&#x2F;&#x2F;local2:61616</span><br><span class="line"># maxReconnectDelay重连的最大间隔时间(毫秒)</span><br><span class="line"></span><br><span class="line">brokerUrl &#x3D; &quot;failover:(tcp:&#x2F;&#x2F;activemq.tony.com:61616,tcp:&#x2F;&#x2F;activemq-slave.tony.com:61616)?initialReconnectDelay&#x3D;100&quot;;</span><br></pre></td></tr></table></figure>

<h2 id="4、原理简述"><a href="#4、原理简述" class="headerlink" title="4、原理简述"></a>4、原理简述</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、 数据库表自动创建</span><br><span class="line">2、 多服务器争抢获取LOCK表锁</span><br><span class="line">3、 连接断开后，客户端自动重连</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/04/06/rabbitmq%E6%8C%81%E4%B9%85%E5%8C%96_%E5%86%85%E5%AD%98_%E7%A3%81%E7%9B%98%E9%A2%84%E8%AD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/rabbitmq%E6%8C%81%E4%B9%85%E5%8C%96_%E5%86%85%E5%AD%98_%E7%A3%81%E7%9B%98%E9%A2%84%E8%AD%A6/" itemprop="url">RabbitMQ持久化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T00:00:00+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h1 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h1><p>此示例演示交换器、队列、消息持久化功能。和内存、磁盘预警</p>
<h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>RabbitMQ 的持久化分交换器持久化、队列持久化和消息持久化。</p>
<ul>
<li><p>定义持久化交换器，通过第三个参数 <code>durable</code> 开启/关闭持久化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.exchangeDeclare(exchangeName, exchangeType, durable)</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义持久化队列，通过第二个参数 <code>durable</code> 开启/关闭持久化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.queueDeclare(queue, durable, exclusive, autoDelete, arguments);</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送持久化消息，需要在消息属性中设置 <code>deliveryMode=2</code>， 此属性在 <code>BasicProperties</code> 中，通过 <code>basicPublish</code> 方法的 <code>props</code> 参数传入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(exchange, routingKey, props, body);</span><br></pre></td></tr></table></figure>

<p>  <code>BasicProperties</code> 对象可以从RabbitMQ 内置的 <code>MessageProperties</code> 类中获取</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageProperties.PERSISTENT_TEXT_PLAIN</span><br></pre></td></tr></table></figure>

<p>  如果还需要设置其它属性，可以通过 <code>AMQP.BasicProperties.Builder</code> 去构建一个 <code>BasicProperties</code> 对象</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AMQP.BasicProperties.Builder()</span><br><span class="line">        .deliveryMode(<span class="number">2</span>)</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="内存告警"><a href="#内存告警" class="headerlink" title="内存告警"></a>内存告警</h2><p>默认情况下 <code>set_vm_memory_high_watermark</code> 的值为 0.4，即内存阈值（临界值）为 0.4，表示当 RabbitMQ 使用的内存超过 40%时，就会产生内存告警并阻塞所有生产者的连接。一旦告警被解除(有消息被消费或者从内存转储到磁盘等情况的发生)， 一切都会恢复正常。</p>
<p>在出现内存告警后，所有的客户端连接都会被阻塞。阻塞分为 <code>blocking</code> 和 <code>blocked</code> 两种。</p>
<ul>
<li>blocking：表示没有发送消息的链接。</li>
<li>blocked：表示试图发送消息的链接。</li>
</ul>
<p>如果出现了内存告警，并且机器还有可用内存，可以通过命令调整内存阈值，解除告警。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_vm_memory_high_watermark 1</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_vm_memory_high_watermark absolute 1GB</span><br></pre></td></tr></table></figure>

<p>但这种方式只是临时调整，RabbitMQ 服务重启后，会还原。如果需要永久调整，可以修改配置文件。但修改配置文件需要<strong>重启RabbitMQ 服务才能生效</strong>。</p>
<ul>
<li><p>修改配置文件：<code>vim /etc/rabbitmq/rabbitmq.conf</code> </p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm_memory_high_watermark.relative = 0.4</span><br></pre></td></tr></table></figure>

<p>  或者</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm_memory_high_watermark.absolute = 1GB</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="模拟内存告警"><a href="#模拟内存告警" class="headerlink" title="模拟内存告警"></a><strong>模拟内存告警</strong></h3><ol>
<li><p>调整内存阈值，模拟出告警，在RabbitMQ 服务器上修改。<strong><code>注意：修改之前，先在管理页面看一下当前使用了多少，调成比当前值小</code></strong></p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_vm_memory_high_watermark absolute 50MB</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新管理页面（可能需要刷新多次），在 <code>Overview -&gt; Nodes</code> 中可以看到Memory变成了红色，表示此节点内存告警了</p>
</li>
<li><p>启动 <code>Producer</code> 和 <code>Consumer</code> </p>
</li>
<li><p>查看管理界面的 <code>Connections</code> 页面，可以看到生产者和消费者的链接都处于 <code>blocking</code> 状态。</p>
</li>
<li><p>在 <code>Producer</code> 的控制台按回车健，再观察管理界面的 <code>Connections</code> 页面，会发现生产者的状态成了 <code>blocked</code>。</p>
</li>
<li><p>此时虽然在<code>Producer</code> 控制台看到了发送两条消息的信息，但 <code>Consumer</code> 并没有收到任何消息。并且在管理界面的 <code>Queues</code> 页面也看到不到队列的消息数量有变化。</p>
</li>
<li><p>解除内存告警后，会发现 <code>Consumer</code> 收到了 <code>Producer</code> 发送的两条消息。</p>
</li>
</ol>
<h2 id="内存换页"><a href="#内存换页" class="headerlink" title="内存换页"></a>内存换页</h2><ul>
<li><p>在Broker节点的使用内存即将达到内存阈值之前，它会尝试将队列中的消息存储到磁盘以释放内存空间，这个动作叫内存换页。</p>
</li>
<li><p>持久化和非持久化的消息都会被转储到磁盘中，其中持久化的消息本身就在磁盘中有一份副本，此时会将持久化的消息从内存中清除掉。</p>
</li>
<li><p>默认情况下，在内存到达内存阈值的 50%时会进行换页动作。也就是说，在默认的内存阈值为 0.4 的情况下，当内存超过 0.4 x 0 .5=0.2 时会进行换页动作。</p>
</li>
<li><p>通过修改配置文件，调整内存换页分页阈值（不能通过命令调整）。</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此值大于1时，相当于禁用了换页功能。</span></span><br><span class="line">vm_memory_high_watermark_paging_ratio = 0.75</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="磁盘告警"><a href="#磁盘告警" class="headerlink" title="磁盘告警"></a>磁盘告警</h2><ul>
<li><p>当磁盘剩余空间低于磁盘的阈值时，RabbitMQ 同样会阻塞生产者，这样可以避免因非持久化的消息持续换页而耗尽磁盘空间导致服务崩溃</p>
</li>
<li><p>默认情况下，磁盘阈值为50MB，表示当磁盘剩余空间低于50MB 时会阻塞生产者并停止内存中消息的换页动作</p>
</li>
<li><p>这个阈值的设置可以减小，但不能完全消除因磁盘耗尽而导致崩渍的可能性。比如在两次磁盘空间检测期间内，磁盘空间从大于50MB被耗尽到0MB</p>
</li>
<li><p>通过命令可以调整磁盘阈值，临时生效，重启恢复</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># disk_limit 为固定大小，单位为MB、GB</span></span><br><span class="line">rabbitmqctl set_disk_free_limit &lt;disk_limit&gt;</span><br></pre></td></tr></table></figure>

<p>  或者</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fraction 为相对比值，建议的取值为1.0~2.0之间</span></span><br><span class="line">rabbitmqctl set_disk_free_limit mem_relative &lt;fraction&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="模拟磁盘告警"><a href="#模拟磁盘告警" class="headerlink" title="模拟磁盘告警"></a><strong>模拟磁盘告警</strong></h3><ol>
<li><p>在服务器通过命令，临时调整磁盘阈值（<strong>需要设置一个绝对大与当前磁盘空间的数值</strong>）</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_disk_free_limit 102400GB</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新管理页面（可能需要刷新多次），在 Overview -&gt; Nodes 中可以看到Disk space变成了红色，表示此节点磁盘告警了</p>
</li>
<li><p>后续步骤同<a href="#模拟内存告警">模拟内存告警</a>。</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/04/06/keepalived-lvs%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/keepalived-lvs%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" itemprop="url">KeepAlive-LVS使用手册</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T00:00:00+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h1 id="前提-配置java环境变量"><a href="#前提-配置java环境变量" class="headerlink" title="前提-配置java环境变量"></a>前提-配置java环境变量</h1><h1 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 下载</span><br><span class="line">curl &quot;http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;apache&#x2F;tomcat&#x2F;tomcat-8&#x2F;v8.5.31&#x2F;bin&#x2F;apache-tomcat-8.5.31.tar.gz&quot; -o apache-tomcat-8.5.31.tar.gz</span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line">tar -xvf apache-tomcat-8.5.31.tar.gz </span><br><span class="line"></span><br><span class="line"># 启动</span><br><span class="line">.&#x2F;apache-tomcat-8.5.31&#x2F;bin&#x2F;startup.sh</span><br></pre></td></tr></table></figure>

<h1 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h1><h2 id="下载及解压-相关的模块到-u01目录"><a href="#下载及解压-相关的模块到-u01目录" class="headerlink" title="下载及解压 相关的模块到/u01目录"></a>下载及解压 相关的模块到/u01目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">curl &quot;http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.14.0.tar.gz&quot; -o nginx-1.14.0.tar.gz</span><br><span class="line">tar -xvf nginx-1.14.0.tar.gz</span><br><span class="line"></span><br><span class="line">curl &quot;http:&#x2F;&#x2F;www.zlib.net&#x2F;zlib-1.2.11.tar.gz&quot; -o zlib-1.2.11.tar.gz</span><br><span class="line">tar -xvf zlib-1.2.11.tar.gz</span><br><span class="line"></span><br><span class="line">curl &quot;https:&#x2F;&#x2F;jaist.dl.sourceforge.net&#x2F;project&#x2F;pcre&#x2F;pcre&#x2F;8.41&#x2F;pcre-8.41.tar.gz&quot; -o pcre-8.41.tar.gz</span><br><span class="line">tar -xvf pcre-8.41.tar.gz</span><br><span class="line"></span><br><span class="line">curl &quot;https:&#x2F;&#x2F;www.openssl.org&#x2F;source&#x2F;openssl-1.0.2o.tar.gz&quot; -o openssl-1.0.2o.tar.gz</span><br><span class="line">tar -xvf openssl-1.0.2o.tar.gz</span><br><span class="line"></span><br><span class="line">curl &quot;http:&#x2F;&#x2F;labs.frickle.com&#x2F;files&#x2F;ngx_cache_purge-2.3.tar.gz&quot; -o ngx_cache_purge-2.3.tar.gz</span><br><span class="line">tar -xvf ngx_cache_purge-2.3.tar.gz</span><br></pre></td></tr></table></figure>

<h2 id="编译安装nginx"><a href="#编译安装nginx" class="headerlink" title="编译安装nginx"></a>编译安装nginx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.14.0</span><br><span class="line"></span><br><span class="line">.&#x2F;configure --add-module&#x3D;..&#x2F;ngx_cache_purge-2.3 --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx --with-http_ssl_module --with-pcre&#x3D;..&#x2F;pcre-8.41 --with-zlib&#x3D;..&#x2F;zlib-1.2.11 --with-openssl&#x3D;..&#x2F;openssl-1.0.2o</span><br><span class="line"></span><br><span class="line">make </span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果有异常：./configure: error: C compiler cc is not found，则安装gcc等软件</p>
</blockquote>
<figure class="highlight plain"><figcaption><span>-y install gcc gcc-c++ autoconf automake make ```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># keepalived</span><br><span class="line">## 下载安装相关相关的组件</span><br></pre></td></tr></table></figure>
<p>yum -y install openssl-devel<br>yum -y install libnl libnl-devel<br>yum install -y libnfnetlink-devel</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 下载安装keepalived</span><br></pre></td></tr></table></figure>
<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>curl “<a href="http://www.keepalived.org/software/keepalived-1.4.4.tar.gz&quot;" target="_blank" rel="noopener">http://www.keepalived.org/software/keepalived-1.4.4.tar.gz&quot;</a> -o keepalived-1.4.4.tar.gz<br>tar -xvf keepalived-1.4.4.tar.gz</p>
<p>cd keepalived-1.4.4  </p>
<h1 id="安装到-usr-local-keepalived目录"><a href="#安装到-usr-local-keepalived目录" class="headerlink" title="安装到/usr/local/keepalived目录"></a>安装到/usr/local/keepalived目录</h1><p>./configure –prefix=/usr/local/keepalived –sysconf=/etc<br>make &amp;&amp; make install</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 配置文件存放地址 </span><br><span class="line">&gt; 配置放在&#x2F;etc&#x2F;keepalived&#x2F;，三份配置文件（一个nginx_monitor监控脚本，主备各一份keepalived配置）</span><br><span class="line">### nginx监控shell脚本 nginx_monitor.sh 文件</span><br></pre></td></tr></table></figure>
<h1 id="创建nginx-monitor-脚本，并赋予可执行权限"><a href="#创建nginx-monitor-脚本，并赋予可执行权限" class="headerlink" title="创建nginx monitor 脚本，并赋予可执行权限"></a>创建nginx monitor 脚本，并赋予可执行权限</h1><p>chmod +x /etc/keepalived/nginx_monitor.sh</p>
<h1 id="测试一下脚本能不能执行"><a href="#测试一下脚本能不能执行" class="headerlink" title="测试一下脚本能不能执行"></a>测试一下脚本能不能执行</h1><p>执行命令：/etc/keepalived/nginx_monitor.sh<br>没报错即表示为成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### keepalived配置</span><br></pre></td></tr></table></figure>
<h1 id="master主机"><a href="#master主机" class="headerlink" title="- master主机"></a>- master主机</h1><p>keepalived-nginx-master.conf</p>
<h1 id="backup备机"><a href="#backup备机" class="headerlink" title="- backup备机"></a>- backup备机</h1><p>keepalived-nginx-backup.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 启动keepalived</span><br></pre></td></tr></table></figure>
<h1 id="启动master主机"><a href="#启动master主机" class="headerlink" title="启动master主机"></a>启动master主机</h1><p>/usr/local/keepalived/sbin/keepalived -f /etc/keepalived/keepalived-nginx-master.conf</p>
<h1 id="启动backup备机"><a href="#启动backup备机" class="headerlink" title="启动backup备机"></a>启动backup备机</h1><p>/usr/local/keepalived/sbin/keepalived -f /etc/keepalived/keepalived-nginx-backup.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 停止</span><br></pre></td></tr></table></figure>
<p>ps -ef | grep keepalived<br>kill -9 关闭相关的进程</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 测试</span><br></pre></td></tr></table></figure>
<ol>
<li>关掉备机，功能完全不受影响。</li>
<li>关掉主机，虚拟IP漂移到备机，备机开始工作。</li>
<li>关掉主机nginx，主机监控到无nginx后，自动切换<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># LVS安装测试</span><br></pre></td></tr></table></figure>
LVS全称为Linux Virtual Server，工作在ISO模型中的第四层，由于其工作在第四层，因此与iptables类似，必须工作在内核空间上。因此lvs与iptables一样，是直接工作在内核中的，叫ipvs，主流的linux发行版默认都已经集成了ipvs，因此用户只需安装一个管理工具ipvsadm即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 安装所需依赖包</span><br></pre></td></tr></table></figure>
yum install popt-static kernel-devel make gcc openssl-devel lftplibnl* popt* openssl-devel lftplibnl* popt* libnl* libpopt* gcc*<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 加载 ip_vs</span><br></pre></td></tr></table></figure>
1、lvs安装部署：在两台LVS Server上安装lvs、keepalived软件（LVS_MASTER &amp; LVS_BACKUP）<br>查看内核模块是否支持<h1 id="lsmod-grep-ip-vs"><a href="#lsmod-grep-ip-vs" class="headerlink" title="lsmod |grep ip_vs"></a>lsmod |grep ip_vs</h1>ip_vs 35009 0<br>如果没有显示，则说明没有加载，执行命令 modprobe ip_vs 就可以把ip_vs模块加载到内核 </li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 2、安装ipvsadm</span><br></pre></td></tr></table></figure>
<p>curl <a href="http://www.linuxvirtualserver.org/software/kernel-2.6/ipvsadm-1.26.tar.gz" target="_blank" rel="noopener">http://www.linuxvirtualserver.org/software/kernel-2.6/ipvsadm-1.26.tar.gz</a> -o ipvsadm-1.26.tar.gz<br>tar zxf ipvsadm-1.26.tar.gz<br>cd ipvsadm-1.26<br>rpm -qa | grep kernel-devel（默认已经安装）<br>make &amp;&amp; make install</p>
<p>curl “<a href="http://www.linuxvirtualserver.org/software/kernel-2.6/ipvsadm-1.25-1.src.rpm&quot;" target="_blank" rel="noopener">http://www.linuxvirtualserver.org/software/kernel-2.6/ipvsadm-1.25-1.src.rpm&quot;</a> -o ipvsadm-1.25-1.src.rpm<br>rpm -ivh ipvsadm-1.25-1.src.rpm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># DR模式</span><br><span class="line">## 3、   dr配置</span><br></pre></td></tr></table></figure>
<p>#执行ipvsadm命令加载<br>ipvsadm<br>#查看结果 (能够显示表示成功)<br>DR模式配置</p>
<h1 id="vim-usr-local-sbin-lvs-dr-sh"><a href="#vim-usr-local-sbin-lvs-dr-sh" class="headerlink" title="vim /usr/local/sbin/lvs_dr.sh"></a>vim /usr/local/sbin/lvs_dr.sh</h1><p>#! /bin/bash<br>echo 1 &gt; /proc/sys/net/ipv4/ip_forward<br>ipv=/sbin/ipvsadm<br>vip=192.168.100.235<br>ifconfig ens192:0 down<br>ifconfig ens192:0 $vip broadcast $vip netmask 255.255.255.255 up<br>route add -host $vip dev ens192:0<br>$ipv -C<br>$ipv -A -t $vip:8080 -s wrr</p>
<p>rs1=192.168.100.112<br>$ipv -a -t $vip:8080 -r $rs1:8080 -g -w 3</p>
<h1 id="rs配置-真实web服务器运行"><a href="#rs配置-真实web服务器运行" class="headerlink" title="rs配置 真实web服务器运行"></a>rs配置 真实web服务器运行</h1><h1 id="vim-usr-local-sbin-lvs-dr-rs-sh"><a href="#vim-usr-local-sbin-lvs-dr-rs-sh" class="headerlink" title="vim /usr/local/sbin/lvs_dr_rs.sh"></a>vim /usr/local/sbin/lvs_dr_rs.sh</h1><p>#! /bin/bash<br>vip=192.168.100.235<br>ifconfig lo:0 $vip broadcast $vip netmask 255.255.255.255 up<br>route add -host $vip lo:0<br>echo “1” &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore<br>echo “2” &gt;/proc/sys/net/ipv4/conf/lo/arp_announce<br>echo “1” &gt;/proc/sys/net/ipv4/conf/all/arp_ignore<br>echo “2” &gt;/proc/sys/net/ipv4/conf/all/arp_announce</p>
<p>ipvsadm -C 清除<br>说明：<br>-A  –add-service在服务器列表中新添加一条新的虚拟服务器记录<br>-t 表示为tcp服务<br>-u 表示为udp服务<br>-s –scheduler 使用的调度算法， rr | wrr | lc | wlc | lblb | lblcr | dh | sh | sed | nq 默认调度算法是 wlc<br>-a –add-server 在服务器表中添加一条新的真实主机记录<br>-r –real-server  真实服务器地址<br>-m –masquerading 指定LVS工作模式为NAT模式<br>-w –weight 真实服务器的权值<br>-g –gatewaying 指定LVS工作模式为直接路由器模式（也是LVS默认的模式）<br>-i –ipip 指定LVS的工作模式为隧道模式</p>
<h1 id="可能出现的错误"><a href="#可能出现的错误" class="headerlink" title="可能出现的错误"></a>可能出现的错误</h1><p>1、没有轮询效果<br>ipvsadm -L –timeout  一条tcp的连接经过lvs后,lvs会把这台记录保存15分钟<br>可以设置短一点，达到实验效果：ipvsadm –set 1 2 1</p>
<p>注： 保存添加的虚拟ip记录和ipvsadm的规则可以使用service ipvsadm save，还可以用-S或–save。清除所有记录和规则除了使用-C，还以使用–clear<br>错误：Memory allocation problem<br>查看一下vmlloc使用情况： cat /proc/meminfo | grep -i vmalloc<br>在/etc/default/grub文件的末尾添加如下一行：<br>GRUB_CMDLINE_LINUX=”vmalloc=256MB”</p>
<p>完成上述操作之后，发现lvs状态仍然是SYN_RECV。抓包后的pcap文件中，没有syn ack。于是想到是不是在什么地方丢掉了。<br>看到官方文档中有描述要设置re_ filter。<br>查了一下这个参数的解释<br>======================================<br>rp_filter参数有三个值，0、1、2，具体含义：<br>0：不开启源地址校验。<br>1：开启严格的反向路径校验。对每个进来的数据包，校验其反向路径是否是最佳路径。如果反向路径不是最佳路径，则直接丢弃该数据包。<br>2：开启松散的反向路径校验。对每个进来的数据包，校验其源地址是否可达，即反向路径是否能通（通过任意网口），如果反向路径不同，则直接丢弃该数据包。<br>=======================================<br>default的值是1，这里改为2<br>echo 2 &gt; /proc/sys/net/ipv4/conf/ 网卡名/rp_filter<br>echo 2 &gt; /proc/sys/net/ipv4/conf/ 网卡名/rp_filter<br>systemctl restart network.service</p>
<p>echo “1” &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore<br>                                 echo “2”&gt; /proc/sys/net/ipv4/conf/lo/arp_announce<br>                                 echo “1”&gt; /proc/sys/net/ipv4/conf/all/arp_ignore<br>                                 echo “2” &gt; /proc/sys/net/ipv4/conf/all/arp_announce</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## lvs调度算法</span><br></pre></td></tr></table></figure>
<p> 1、静态调度：<br>①rr（Round Robin）:轮询调度，轮叫调度</p>
<p> 轮询调度算法的原理是每一次把来自用户的请求轮流分配给内部中的服务器，从1开始，直到N(内部服务器个数)，然后重新开始循环。算法的优点是其简洁性，它无需记录当前所有连接的状态，所以它是一种无状态调度。【提示：这里是不考虑每台服务器的处理能力】</p>
<p>②wrr：weight,加权（以权重之间的比例实现在各主机之间进行调度）</p>
<p>由于每台服务器的配置、安装的业务应用等不同，其处理能力会不一样。所以，我们根据服务器的不同处理能力，给每个服务器分配不同的权值，使其能够接受相应权值数的服务请求。</p>
<p>③sh:source hashing,源地址散列。主要实现会话绑定，能够将此前建立的session信息保留了</p>
<p>源地址散列调度算法正好与目标地址散列调度算法相反，它根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的并且没有超负荷，将请求发送到该服务器，否则返回空。它采用的散列函数与目标地址散列调度算法的相同。它的算法流程与目标地址散列调度算法的基本相似，除了将请求的目标IP地址换成请求的源IP地址，所以这里不一个一个叙述。</p>
<p>④Dh:Destination hashing:目标地址散列。把同一个IP地址的请求，发送给同一个server。</p>
<p>目标地址散列调度算法也是针对目标IP地址的负载均衡，它是一种静态映射算法，通过一个散列（Hash）函数将一个目标IP地址映射到一台服务器。目标地址散列调度算法先根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且未超载，将请求发送到该服务器，否则返回空。</p>
<p>2、动态调度<br>①lc（Least-Connection）：最少连接<br>最少连接调度算法是把新的连接请求分配到当前连接数最小的服务器，最小连接调度是一种动态调度短算法，它通过服务器当前所活跃的连接数来估计服务器的负载均衡，调度器需要记录各个服务器已建立连接的数目，当一个请求被调度到某台服务器，其连接数加1，当连接中止或超时，其连接数减一，在系统实现时，我们也引入当服务器的权值为0时，表示该服务器不可用而不被调度。<br>简单算法：active*256+inactive(谁的小，挑谁)</p>
<p>②wlc(Weighted Least-Connection Scheduling)：加权最少连接。</p>
<p>加权最小连接调度算法是最小连接调度的超集，各个服务器用相应的权值表示其处理性能。服务器的缺省权值为1，系统管理员可以动态地设置服务器的权限，加权最小连接调度在调度新连接时尽可能使服务器的已建立连接数和其权值成比例。</p>
<p>简单算法：（active*256+inactive）/weight【（活动的连接数+1）/除以权重】（谁的小，挑谁）</p>
<p>③sed(Shortest Expected Delay)：最短期望延迟</p>
<p>基于wlc算法</p>
<p>简单算法：（active+1)<em>256/weight 【（活动的连接数+1）</em>256/除以权重】</p>
<p>④nq（never queue）:永不排队（改进的sed）</p>
<p>无需队列，如果有台realserver的连接数＝0就直接分配过去，不需要在进行sed运算。</p>
<p>⑤LBLC（Locality-Based Least Connection）：基于局部性的最少连接</p>
<p>基于局部性的最少连接算法是针对请求报文的目标IP地址的负载均衡调度，不签主要用于Cache集群系统，因为Cache集群中客户请求报文的布标IP地址是变化的，这里假设任何后端服务器都可以处理任何请求，算法的设计目标在服务器的负载基本平衡的情况下，将相同的目标IP地址的请求调度到同一个台服务器，来提高个太服务器的访问局部性和主存Cache命中率，从而调整整个集群系统的处理能力。</p>
<p>基于局部性的最少连接调度算法根据请求的目标IP地址找出该目标IP地址最近使用的RealServer，若该Real Server是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则用“最少链接”的原则选出一个可用的服务器，将请求发送到该服务器。</p>
<p>⑥LBLCR（Locality-Based Least Connections withReplication）：带复制的基于局部性最少链接</p>
<pre><code>带复制的基于局部性最少链接调度算法也是针对目标IP地址的负载均衡，该算法根据请求的目标IP地址找出该目标IP地址对应的服务器组，按“最小连接”原则从服务器组中选出一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按“最小连接”原则从这个集群中选出一台服务器，将该服务器加入到服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 注意事项</span><br><span class="line">## 防火墙</span><br></pre></td></tr></table></figure>
<p>firewall-cmd –state #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）<br>systemctl list-unit-files|grep firewalld.service<br>systemctl stop firewalld.service #停止firewall<br>systemctl disable firewalld.service #禁止firewall开机启动</p>
<p>[root@localhost ~]#systemctl stop firewalld.service<br>[root@localhost ~]#systemctl disable firewalld.service<br>启动一个服务：systemctl start firewalld.service<br>关闭一个服务：systemctl stop firewalld.service<br>重启一个服务：systemctl restart firewalld.service<br>显示一个服务的状态：systemctl status firewalld.service<br>在开机时启用一个服务：systemctl enable firewalld.service<br>在开机时禁用一个服务：systemctl disable firewalld.service<br>查看服务是否开机启动：systemctl is-enabled firewalld.service;echo $?<br>查看已启动的服务列表：systemctl list-unit-files|grep enabled</p>
<pre><code>

安装killall工具
yum install psmisc

    # 状态变成master会执行该脚本
    # notify_master &quot;/etc/keepalived/be_master.sh&quot;

    # 状态变成backup会执行该脚本
    # notify_backup  &quot;&quot;

    # 监控脚本执行发现异常时会执行该脚本
    # notify_fault &quot;xxxx.sh&quot;


</code></pre>
          
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/04/06/rabbitmq%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/rabbitmq%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA/" itemprop="url">RabbitMQ虚拟主机</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T00:00:00+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a><strong>示例说明</strong></h1><p>此示例演示Virtual Hosts和权限的使用，及客户端链接集群的用法。</p>
<h2 id="Virtual-Hosts"><a href="#Virtual-Hosts" class="headerlink" title="Virtual Hosts"></a><strong>Virtual Hosts</strong></h2><p>每一个 RabbitMQ 服务器都能创建虚拟的消息服务器，我们称之为虚拟主机 (virtual host) ,简称为 vhost。</p>
<p>每一个 vhost 本质上是一个独立的小型 RabbitMQ 服务器，拥有自己独立的队列、交换器及绑定关系等，井且它拥有自己独立的权限。</p>
<p>vhost 就像是虚拟机与物理服务器一样，它们在各个实例间提供逻辑上的分离，为不同程序安全保密地运行数据，它既能将同一个RabbitMQ 中的众多客户区分开，又可以避免队列和交换器等命名冲突。</p>
<p>vhost 之间是绝对隔离的，无法将 vhostl 中的交换器与 vhost2 中的队列进行绑定，这样既保证了安全性，又可以确保可移植性。</p>
<p>如果在使用 RabbitMQ 达到一定规模的时候，建议用户对业务功能、场景进行归类区分，并为之分配独立的 vhost。</p>
<h3 id="Virtual-Hosts-的功能说明"><a href="#Virtual-Hosts-的功能说明" class="headerlink" title="Virtual Hosts 的功能说明"></a><strong>Virtual Hosts 的功能说明</strong></h3><p>vhost可以限制最大连接数和最大队列数，并且可以设置vhost下的用户资源权限和Topic权限，具体权限见下方说明。</p>
<ul>
<li><p>在 <code>Admin -&gt; Limits</code> 页面可以设置vhost的最大连接数和最大队列数，达到限制后，继续创建，将会报错。</p>
</li>
<li><p>用户资源权限是指RabbitMQ 用户在客户端执行AMQP操作命令时，拥有对资源的操作和使用权限。权限分为三个部分：<code>configure、write、read</code>，见下方表格说明。参考：<a href="http://www.rabbitmq.com/access-control.html#permissions" target="_blank" rel="noopener">http://www.rabbitmq.com/access-control.html#permissions</a></p>
<table>
<thead>
<tr>
<th align="left">AMQP 0-9-1 Operation</th>
<th align="left"></th>
<th align="left">configure</th>
<th align="left">write</th>
<th align="left">read</th>
</tr>
</thead>
<tbody><tr>
<td align="left">exchange.declare</td>
<td align="left">(passive=false)</td>
<td align="left">exchange</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">exchange.declare</td>
<td align="left">(passive=true)</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">exchange.declare</td>
<td align="left">(with <a href="http://www.rabbitmq.com/ae.html" target="_blank" rel="noopener">AE</a>)</td>
<td align="left">exchange</td>
<td align="left">exchange (AE)</td>
<td align="left">exchange</td>
</tr>
<tr>
<td align="left">exchange.delete</td>
<td align="left"></td>
<td align="left">exchange</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">queue.declare</td>
<td align="left">(passive=false)</td>
<td align="left">queue</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">queue.declare</td>
<td align="left">(passive=true)</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">queue.declare</td>
<td align="left">(with <a href="http://www.rabbitmq.com/dlx.html" target="_blank" rel="noopener">DLX</a>)</td>
<td align="left">queue</td>
<td align="left">exchange (DLX)</td>
<td align="left">queue</td>
</tr>
<tr>
<td align="left">queue.delete</td>
<td align="left"></td>
<td align="left">queue</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">exchange.bind</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">exchange (destination)</td>
<td align="left">exchange (source)</td>
</tr>
<tr>
<td align="left">exchange.unbind</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">exchange (destination)</td>
<td align="left">exchange (source)</td>
</tr>
<tr>
<td align="left">queue.bind</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">queue</td>
<td align="left">exchange</td>
</tr>
<tr>
<td align="left">queue.unbind</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">queue</td>
<td align="left">exchange</td>
</tr>
<tr>
<td align="left">basic.publish</td>
<td align="left"></td>
<td align="left"></td>
<td align="left">exchange</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">basic.get</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">queue</td>
</tr>
<tr>
<td align="left">basic.consume</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">queue</td>
</tr>
<tr>
<td align="left">queue.purge</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
<td align="left">queue</td>
</tr>
</tbody></table>
<p>  <strong>举例说明：</strong></p>
<ul>
<li>比如创建队列时，会调用<code>queue.declare</code>方法，此时会使用到<code>configure</code>权限，会校验队列名是否与<code>configure</code>的表达式匹配。</li>
<li>比如队列绑定交换器时，会调用<code>queue.bind</code>方法，此时会用到<code>write</code> 和 <code>read</code>权限，会检验队列名是否与<code>write</code>的表达式匹配，交换器名是否与<code>read</code>的表达式匹配。</li>
</ul>
</li>
<li><p>Topic权限，参考：<a href="http://www.rabbitmq.com/access-control.html#topic-authorisation" target="_blank" rel="noopener">http://www.rabbitmq.com/access-control.html#topic-authorisation</a></p>
<ul>
<li>Topic权限是RabbitMQ 针对STOMP和MQTT等协议实现的一种权限。由于这类协议都是基于Topic消费的，而AMQP是基于Queue消费，所以AMQP的标准资源权限不适合用在这类协议中，而Topic权限也不适用于AMQP协议。所以，我们一般不会去使用它，只用在使用了MQTT这类的协议时才可能会用到。</li>
</ul>
</li>
</ul>
<h4 id="vhost使用示例"><a href="#vhost使用示例" class="headerlink" title="vhost使用示例"></a><strong>vhost使用示例</strong></h4><ol>
<li><p>使用管理员用户登录Web管理界面。</p>
</li>
<li><p>在 <code>Admin -&gt; Virtual Hosts</code> 页面添加一个名为 <code>v1</code> 的Virtual Hosts。</p>
<ul>
<li>此时还需要为此vhost分配用户，添加一个新用户</li>
</ul>
</li>
<li><p>在 <code>Admin -&gt; Users</code> 页面添加一个名为 <code>order-user</code> 的用户，并设置为 <code>management</code> 角色。</p>
</li>
<li><p>从 <code>Admin</code> 进入 <code>order-user</code> 的用户设置界面,在 <code>Permissions</code> 中，为用户分配vhost为/v1，并为每种权限设置需要匹配的目标名称的正则表达式。</p>
<table>
<thead>
<tr>
<th align="right">字段名</th>
<th align="left">值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="right">Virtual Host</td>
<td align="left">/v1</td>
<td align="left">指定用户的vhost，以下权限都只限于 <code>/v1</code> vhost中</td>
</tr>
<tr>
<td align="right">Configure regexp</td>
<td align="left">eq-.*</td>
<td align="left">只能操作名称以eq-开头的exchange或queue；为空则不能操作任何exchange和queue</td>
</tr>
<tr>
<td align="right">Write regexp</td>
<td align="left">.*</td>
<td align="left">能够发送消息到任意名称的exchange，并且能绑定到任意名称的队列和任意名称的目标交换器（指交换器绑定到交换器），为空表示没有权限</td>
</tr>
<tr>
<td align="right">Read regexp</td>
<td align="left">^test$</td>
<td align="left">只能消费名为test队列上的消息，并且只能绑定到名为test的交换器</td>
</tr>
</tbody></table>
</li>
<li><p>执行示例代码<code>VirtualHostsDemo</code>。</p>
</li>
</ol>
<h2 id="集群连接恢复"><a href="#集群连接恢复" class="headerlink" title="集群连接恢复"></a><strong>集群连接恢复</strong></h2><ul>
<li><p><strong>参考</strong>：<a href="https://www.rabbitmq.com/api-guide.html#connection-recovery" target="_blank" rel="noopener">https://www.rabbitmq.com/api-guide.html#connection-recovery</a></p>
</li>
<li><p>通过<code>factory.setAutomaticRecoveryEnabled(true);</code>可以设置连接自动恢复的开关，默认已开启</p>
</li>
<li><p>通过<code>factory.setNetworkRecoveryInterval(10000);</code>可以设置间隔多长时间尝试恢复一次，默认是5秒：<code>com.rabbitmq.client.ConnectionFactory.DEFAULT_NETWORK_RECOVERY_INTERVAL</code></p>
</li>
<li><p>什么时候会触发连接恢复？<a href="https://www.rabbitmq.com/api-guide.html#recovery-triggers" target="_blank" rel="noopener">https://www.rabbitmq.com/api-guide.html#recovery-triggers</a></p>
<ul>
<li><p>如果启用了自动连接恢复，将由以下事件触发：</p>
<ul>
<li>连接的I/O循环中抛出IOExceiption</li>
<li>读取Socket套接字超时</li>
<li>检测不到服务器心跳</li>
<li>在连接的I/O循环中引发任何其他异常</li>
</ul>
</li>
<li><p>如果客户端第一次连接失败，不会自动恢复连接。需要我们自己负责重试连接、记录失败的尝试、实现重试次数的限制等等。</p>
<pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"><span class="comment">// 设置连接配置</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Connection conn = factory.newConnection();</span><br><span class="line">&#125; <span class="keyword">catch</span> (java.net.ConnectException e) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    <span class="comment">// 重新连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li>
<li><p>如果程序中调用了<code>Connection.Close</code>，也不会自动恢复连接。</p>
</li>
<li><p>如果是<code>Channel-level</code>的异常，也不会自动恢复连接，因为这些异常通常是应用程序中存在语义问题(例如试图从不存在的队列消费)。</p>
</li>
</ul>
</li>
<li><p>在Connection和Channel上，可以设置重新连接的监听器，开始重连和重连成功时，会触发监听器。添加和移除监听，需要将Connection或Channel强制转换成Recoverable接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((Recoverable) connection).addRecoveryListener()</span><br><span class="line">((Recoverable) connection).removeRecoveryListener()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="重连测试方式"><a href="#重连测试方式" class="headerlink" title="重连测试方式"></a><strong>重连测试方式</strong></h2><ul>
<li>测试前，先按<a href="http://code.dongnaoedu.com/MQ/rabbitmq/rabbitmq#%E5%8D%95%E6%9C%BA%E5%A4%9A%E8%8A%82%E7%82%B9%E9%83%A8%E7%BD%B2" target="_blank" rel="noopener">集群部署方式</a>搭建好集群。</li>
<li>开启集群节点后，启动<code>Consumer</code>和<code>Producer</code>。</li>
<li>使用 <code>rabbitmqctl -n [node_name] stop_app</code> 命令关闭一个节点，例如：<code>rabbitmqctl -n rabbit2 stop_app</code>;</li>
<li>查看Consumer和Producer控制台是否有重连的信息。</li>
<li>使用 <code>rabbitmqctl -n [node_name] start_app</code> 可开启关闭的节点。 </li>
</ul>
<h2 id="镜像队列测试"><a href="#镜像队列测试" class="headerlink" title="镜像队列测试"></a><strong>镜像队列测试</strong></h2><ul>
<li><p>测试方式</p>
<ul>
<li><p>生产者连接10.10.1.41:5672发送消息后，停止rabbit1节点</p>
<table>
<thead>
<tr>
<th align="center">队列持久化</th>
<th align="center">消息持久化</th>
<th align="center">镜像队列</th>
<th align="left">结果</th>
</tr>
</thead>
<tbody><tr>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">rabbit1重启后，队列和消息丢失</td>
</tr>
<tr>
<td align="center">是</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="left">rabbit1重启后，队列存在但消息丢失；rabbit1不启动消费者连接其它节点也无法启动</td>
</tr>
<tr>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">否</td>
<td align="left">rabbit1重启后，队列存在，消息丢失；rabbit1不启动消费者连接其它节点也无法启动</td>
</tr>
<tr>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="left">对列和消息都还存在，并且消费者能够正常消费</td>
</tr>
<tr>
<td align="center">是</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="left">同上</td>
</tr>
<tr>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="left">同上</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/04/06/nginxlua/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/nginxlua/" itemprop="url">Nginx及其测试模块lua的安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T00:00:00+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<blockquote>
<p>参考项：<a href="https://github.com/openresty/lua-nginx-module#installation" target="_blank" rel="noopener">https://github.com/openresty/lua-nginx-module#installation</a></p>
</blockquote>
<h1 id="安装依赖项"><a href="#安装依赖项" class="headerlink" title="安装依赖项"></a>安装依赖项</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</span><br><span class="line"></span><br><span class="line"># lua_jit</span><br><span class="line">wget http:&#x2F;&#x2F;luajit.org&#x2F;download&#x2F;LuaJIT-2.0.5.tar.gz </span><br><span class="line">tar -xvf LuaJIT-2.0.5.tar.gz</span><br><span class="line">cd LuaJIT-2.0.5</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h1 id="下载安装nginx和依赖项"><a href="#下载安装nginx和依赖项" class="headerlink" title="下载安装nginx和依赖项"></a>下载安装nginx和依赖项</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;netease</span><br><span class="line"># nginx</span><br><span class="line">wget http:&#x2F;&#x2F;nginx.org&#x2F;download&#x2F;nginx-1.14.2.tar.gz</span><br><span class="line">tar -xvf nginx-1.14.2.tar.gz</span><br><span class="line"># ndk</span><br><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;simplresty&#x2F;ngx_devel_kit&#x2F;archive&#x2F;v0.3.0.zip </span><br><span class="line">unzip v0.3.0.zip </span><br><span class="line"># ngx_lua 模块</span><br><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;openresty&#x2F;lua-nginx-module&#x2F;archive&#x2F;v0.10.14.zip</span><br><span class="line">unzip v0.10.14.zip</span><br><span class="line"></span><br><span class="line"># 安装nginx</span><br><span class="line">cd nginx-1.14.2</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx-1.14.2 \</span><br><span class="line">         --add-module&#x3D;..&#x2F;ngx_devel_kit-0.3.0 \</span><br><span class="line">         --add-module&#x3D;..&#x2F;lua-nginx-module-0.10.14</span><br></pre></td></tr></table></figure>

<h1 id="测试lua模块是否安装成功"><a href="#测试lua模块是否安装成功" class="headerlink" title="测试lua模块是否安装成功"></a>测试lua模块是否安装成功</h1><h2 id="0、-创建一个文件夹存储lua脚本"><a href="#0、-创建一个文件夹存储lua脚本" class="headerlink" title="0、 创建一个文件夹存储lua脚本"></a>0、 创建一个文件夹存储lua脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;nginx-1.14.2&#x2F;lua_scripts</span><br></pre></td></tr></table></figure>

<h2 id="1、创建mydata-lua"><a href="#1、创建mydata-lua" class="headerlink" title="1、创建mydata.lua"></a>1、创建mydata.lua</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- mydata.lua</span><br><span class="line"> local _M &#x3D; &#123;&#125;</span><br><span class="line"></span><br><span class="line"> local data &#x3D; &#123;</span><br><span class="line">     dog &#x3D; 3,</span><br><span class="line">     cat &#x3D; 4,</span><br><span class="line">     pig &#x3D; 5,</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> function _M.get_age(name)</span><br><span class="line">     return data[name]</span><br><span class="line"> end</span><br><span class="line"> return _M</span><br></pre></td></tr></table></figure>

<h2 id="2、-nginx-conf文件"><a href="#2、-nginx-conf文件" class="headerlink" title="2、 nginx.conf文件"></a>2、 nginx.conf文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lua_package_path &quot;&#x2F;usr&#x2F;local&#x2F;nginx-1.14.2&#x2F;lua_scripts&#x2F;?.lua;;&quot;;</span><br><span class="line"> server &#123;</span><br><span class="line">     ...</span><br><span class="line">     location &#x2F;lua &#123;</span><br><span class="line">         content_by_lua_block &#123;</span><br><span class="line">            local mydata &#x3D; require &quot;mydata&quot;</span><br><span class="line">            ngx.say(mydata.get_age(&quot;dog&quot;))</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<h2 id="可能的错误"><a href="#可能的错误" class="headerlink" title="可能的错误"></a>可能的错误</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 1、动态库找不到</span><br><span class="line">.&#x2F;sbin&#x2F;nginx: error while loading shared libraries: libluajit-5.1.so.2: cannot open shared object file: No such file or directory</span><br><span class="line"># 解决办法：</span><br><span class="line">echo &quot;&#x2F;usr&#x2F;local&#x2F;lib&quot; &gt; &#x2F;etc&#x2F;ld.so.conf.d&#x2F;usr_local_lib.conf</span><br><span class="line">ldconfig</span><br><span class="line"></span><br><span class="line"># 2、warn提示</span><br><span class="line">nginx: [alert] detected a LuaJIT version which is not OpenResty&#39;s; many optimizations will be disabled and performance will be compromised (see https:&#x2F;&#x2F;github.com&#x2F;openresty&#x2F;luajit2 for OpenResty&#39;s LuaJIT or, even better, consider using the OpenResty releases from https:&#x2F;&#x2F;openresty.org&#x2F;en&#x2F;download.html)</span><br><span class="line"># 告诉你，你不要用这个luajit版本，可以用openresty提供的luajit优化版本，或者干脆直接用openresty</span><br></pre></td></tr></table></figure>

<h1 id="安装lua-redis"><a href="#安装lua-redis" class="headerlink" title="安装lua_redis"></a>安装lua_redis</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;codeload.github.com&#x2F;openresty&#x2F;lua-resty-redis&#x2F;zip&#x2F;master</span><br><span class="line">unzip master</span><br><span class="line">cd lua-resty-redis-master</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/04/06/redis5%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/redis5%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/" itemprop="url">Redis5集群搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T00:00:00+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h1 id="1、-环境信息"><a href="#1、-环境信息" class="headerlink" title="1、 环境信息"></a>1、 环境信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">centos7</span><br><span class="line">redis5</span><br></pre></td></tr></table></figure>

<h1 id="2、整体集群信息"><a href="#2、整体集群信息" class="headerlink" title="2、整体集群信息"></a>2、整体集群信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 以直接在一台机器上实现上述的伪集群，因为端口号特意设置为不同的。</span><br><span class="line"># 重点：不论机器多少，对于部署过程都是一样的，只不过是在不同机器启动redis-server而已</span><br><span class="line">192.168.100.242 (6381- 6386共6个端口）</span><br><span class="line"># 注意事项：如果你的服务器有多个IP，那你操作下面步骤时，尽量使用你的客户端能够访问的IP</span><br></pre></td></tr></table></figure>

<h1 id="3、每台服务器上面都要下载安装"><a href="#3、每台服务器上面都要下载安装" class="headerlink" title="3、每台服务器上面都要下载安装"></a>3、每台服务器上面都要下载安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.3.tar.gz</span><br><span class="line">tar -zxvf redis-5.0.3.tar.gz</span><br><span class="line">cd redis-5.0.3 </span><br><span class="line">make</span><br><span class="line"># 安装到 &#x2F;usr&#x2F;local&#x2F;redis 目录中 安装的文件只有一个bin目录</span><br><span class="line">make install PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis&#x2F; </span><br><span class="line"></span><br><span class="line"># 创建配置文件和data存放目录</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf &#x2F;usr&#x2F;local&#x2F;redis&#x2F;data</span><br></pre></td></tr></table></figure>
<h1 id="4、准备6个redis-conf配置文件（为了方便学习，redis-conf根据不同端口来命名，方便一台机器上构建伪集群）"><a href="#4、准备6个redis-conf配置文件（为了方便学习，redis-conf根据不同端口来命名，方便一台机器上构建伪集群）" class="headerlink" title="4、准备6个redis.conf配置文件（为了方便学习，redis.conf根据不同端口来命名，方便一台机器上构建伪集群）"></a>4、准备6个redis.conf配置文件（为了方便学习，redis.conf根据不同端口来命名，方便一台机器上构建伪集群）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 配置文件进行了精简，完整配置可自行和官方提供的完整conf文件进行对照。端口号自行对应修改</span><br><span class="line">#后台启动的意思</span><br><span class="line">daemonize yes </span><br><span class="line"> #端口号</span><br><span class="line">port 6381</span><br><span class="line"># IP绑定，redis不建议对公网开放，直接绑定0.0.0.0没毛病</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"># redis数据文件存放的目录</span><br><span class="line">dir &#x2F;usr&#x2F;local&#x2F;redis&#x2F;data</span><br><span class="line"># 开启AOF</span><br><span class="line">appendonly yes</span><br><span class="line"> # 开启集群</span><br><span class="line">cluster-enabled yes</span><br><span class="line"># 会自动生成在上面配置的dir目录下</span><br><span class="line">cluster-config-file nodes-6381.conf </span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"># 这个文件会自动生成</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6381.pid</span><br></pre></td></tr></table></figure>

<h1 id="5、启动6个Redis实例"><a href="#5、启动6个Redis实例" class="headerlink" title="5、启动6个Redis实例"></a>5、启动6个Redis实例</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 一定要注意每个配置文件中的端口号哦</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;6381.conf</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;6382.conf</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;6383.conf</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;6384.conf</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;6385.conf</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;6386.conf</span><br></pre></td></tr></table></figure>
<h1 id="6、-创建cluster"><a href="#6、-创建cluster" class="headerlink" title="6、 创建cluster"></a>6、 创建cluster</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"># 5.0版本的方式</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli --cluster create 192.168.100.242:6381 192.168.100.242:6382 \</span><br><span class="line">192.168.100.242:6383 192.168.100.242:6384 192.168.100.242:6385 192.168.100.242:6386 \</span><br><span class="line">--cluster-replicas 1</span><br><span class="line"></span><br><span class="line"># 自动设置主从，而且会提示你，是否运行使用自动的配置</span><br><span class="line">Can I set the above configuration? (type &#39;yes&#39; to accept): yes</span><br><span class="line"># 执行后的信息</span><br><span class="line">&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...</span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 192.168.100.242:6384 to 192.168.100.242:6381</span><br><span class="line">Adding replica 192.168.100.242:6385 to 192.168.100.242:6382</span><br><span class="line">Adding replica 192.168.100.242:6386 to 192.168.100.242:6383</span><br><span class="line">&gt;&gt;&gt; Trying to optimize slaves allocation for anti-affinity</span><br><span class="line">[WARNING] Some slaves are in the same host as their master</span><br><span class="line">M: 68326caa0238cb877afc3e6df23eb92558fcbc3c 192.168.100.242:6381</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: 764500b86fadebd535ac2b5b778a73486fe7d2b7 192.168.100.242:6382</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 93293699b8966ccc202bb29c659a9f60e26e4c86 192.168.100.242:6383</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: a842c5188c441453fd303520424132d45914fe5b 192.168.100.242:6384</span><br><span class="line">   replicates 764500b86fadebd535ac2b5b778a73486fe7d2b7</span><br><span class="line">S: 0a7061773b2512c91b6173bc27451b19fe02f269 192.168.100.242:6385</span><br><span class="line">   replicates 93293699b8966ccc202bb29c659a9f60e26e4c86</span><br><span class="line">S: 42806ad3f740f639ec321b78ea492c42a4040176 192.168.100.242:6386</span><br><span class="line">   replicates 68326caa0238cb877afc3e6df23eb92558fcbc3c</span><br><span class="line">Can I set the above configuration? (type &#39;yes&#39; to accept): yes</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.100.242:6381)</span><br><span class="line">M: 68326caa0238cb877afc3e6df23eb92558fcbc3c 192.168.100.242:6381</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 0a7061773b2512c91b6173bc27451b19fe02f269 192.168.100.242:6385</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 93293699b8966ccc202bb29c659a9f60e26e4c86</span><br><span class="line">S: a842c5188c441453fd303520424132d45914fe5b 192.168.100.242:6384</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 764500b86fadebd535ac2b5b778a73486fe7d2b7</span><br><span class="line">M: 93293699b8966ccc202bb29c659a9f60e26e4c86 192.168.100.242:6383</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 764500b86fadebd535ac2b5b778a73486fe7d2b7 192.168.100.242:6382</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 42806ad3f740f639ec321b78ea492c42a4040176 192.168.100.242:6386</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 68326caa0238cb877afc3e6df23eb92558fcbc3c</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<h1 id="7、-集群检验和测试"><a href="#7、-集群检验和测试" class="headerlink" title="7、 集群检验和测试"></a>7、 集群检验和测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 检查集群，查看所有节点信息</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli -c -h 192.168.100.242 -p 6381 cluster nodes</span><br><span class="line"># 执行后的信息</span><br><span class="line">[root@node3 redis]# &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli -c -h 192.168.100.242 -p 6381 cluster nodes</span><br><span class="line">0a7061773b2512c91b6173bc27451b19fe02f269 192.168.100.242:6385@16385 slave 93293699b8966ccc202bb29c659a9f60e26e4c86 0 1550635081000 5 connected</span><br><span class="line">a842c5188c441453fd303520424132d45914fe5b 192.168.100.242:6384@16384 slave 764500b86fadebd535ac2b5b778a73486fe7d2b7 0 1550635081565 4 connected</span><br><span class="line">93293699b8966ccc202bb29c659a9f60e26e4c86 192.168.100.242:6383@16383 master - 0 1550635081665 3 connected 10923-16383</span><br><span class="line">764500b86fadebd535ac2b5b778a73486fe7d2b7 192.168.100.242:6382@16382 master - 0 1550635081000 2 connected 5461-10922</span><br><span class="line">68326caa0238cb877afc3e6df23eb92558fcbc3c 192.168.100.242:6381@16381 myself,master - 0 1550635080000 1 connected 0-5460</span><br><span class="line">42806ad3f740f639ec321b78ea492c42a4040176 192.168.100.242:6386@16386 slave 68326caa0238cb877afc3e6df23eb92558fcbc3c 0 1550635080664 6 connected</span><br><span class="line"># 节点id ip+端口 角色 masterid 处理的ping数量 最后一个pong时间 节点配置版本 节点连接状态 slot槽分配情况</span><br><span class="line"></span><br><span class="line"># 测试Redis Cluster的一种简单方法是使用redis-cli命令行实用程序</span><br><span class="line"># -c 是支持cluster重定向</span><br><span class="line">[root@node3 redis]# &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli -c -h 192.168.100.242 -p 6381</span><br><span class="line">192.168.100.242:6381&gt; set a 1</span><br><span class="line">-&gt; Redirected to slot [15495] located at 192.168.100.242:6383</span><br><span class="line">OK</span><br><span class="line">192.168.100.242:6383&gt; get a</span><br><span class="line">&quot;1&quot;</span><br><span class="line">192.168.100.242:6383&gt; set hello tony</span><br><span class="line">-&gt; Redirected to slot [866] located at 192.168.100.242:6381</span><br><span class="line">OK</span><br><span class="line">192.168.100.242:6381&gt; get hello</span><br><span class="line">&quot;tony&quot;</span><br><span class="line">192.168.100.242:6381&gt; get a</span><br><span class="line">-&gt; Redirected to slot [15495] located at 192.168.100.242:6383</span><br><span class="line">&quot;1&quot;</span><br><span class="line"></span><br><span class="line"># 查看一个key属于哪一个节点</span><br><span class="line">CLUSTER KEYSLOT key</span><br></pre></td></tr></table></figure>

<h1 id="8、集群slot数量整理-reshard"><a href="#8、集群slot数量整理-reshard" class="headerlink" title="8、集群slot数量整理 reshard"></a>8、集群slot数量整理 reshard</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#  &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli --cluster help 可以查看所有这个命令和子命令的帮助信息</span><br><span class="line"></span><br><span class="line"># 默认是master平均分了0-16383的所有虚拟slot</span><br><span class="line"># 可以进行调整，部分节点放多一点slot(槽或者位置)。</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli --cluster reshard  &lt;host&gt;:&lt;port&gt; --cluster-from &lt;node-id&gt; --cluster-to &lt;node-id&gt; --cluster-slots &lt;number of slots&gt; --cluster-yes</span><br><span class="line"></span><br><span class="line"># 重新检查集群</span><br><span class="line">[root@node3 redis]# &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli --cluster check 192.168.100.242:6382</span><br><span class="line">192.168.100.242:6382 (764500b8...) -&gt; 0 keys | 5462 slots | 1 slaves.</span><br><span class="line">192.168.100.242:6383 (93293699...) -&gt; 1 keys | 5461 slots | 1 slaves.</span><br><span class="line">192.168.100.242:6381 (68326caa...) -&gt; 1 keys | 5461 slots | 1 slaves.</span><br><span class="line">[OK] 2 keys in 3 masters.</span><br><span class="line">0.00 keys per slot on average.</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.100.242:6382)</span><br><span class="line">M: 764500b86fadebd535ac2b5b778a73486fe7d2b7 192.168.100.242:6382</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: a842c5188c441453fd303520424132d45914fe5b 192.168.100.242:6384</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 764500b86fadebd535ac2b5b778a73486fe7d2b7</span><br><span class="line">M: 93293699b8966ccc202bb29c659a9f60e26e4c86 192.168.100.242:6383</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 42806ad3f740f639ec321b78ea492c42a4040176 192.168.100.242:6386</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 68326caa0238cb877afc3e6df23eb92558fcbc3c</span><br><span class="line">S: 0a7061773b2512c91b6173bc27451b19fe02f269 192.168.100.242:6385</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 93293699b8966ccc202bb29c659a9f60e26e4c86</span><br><span class="line">M: 68326caa0238cb877afc3e6df23eb92558fcbc3c 192.168.100.242:6381</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>
<h1 id="9、-测试自动故障转移"><a href="#9、-测试自动故障转移" class="headerlink" title="9、 测试自动故障转移"></a>9、 测试自动故障转移</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># cluster集群不保证数据一致，数据也可能丢失</span><br><span class="line"># 首先是运行客户端不断的写入或读取数据，以便能够发现问题</span><br><span class="line"># 然后是模拟节点故障：找一个主节点关闭，主从故障切换的过程中，这个时间端的操作，客户端而言，只能是失败</span><br><span class="line"># 官方描述 https:&#x2F;&#x2F;redis.io&#x2F;topics&#x2F;cluster-spec  </span><br><span class="line">There is always a window of time when it is possible to lose writes during partitions.</span><br><span class="line">分区的时间窗口内总是有可能丢失写操作。</span><br></pre></td></tr></table></figure>

<h1 id="10、手动故障转移"><a href="#10、手动故障转移" class="headerlink" title="10、手动故障转移"></a>10、手动故障转移</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 可能某个节点需要维护（机器下线、硬件升级、系统版本调整等等场景），需要手动的实现转移</span><br><span class="line"># 在slave节点上执行命令</span><br><span class="line">CLUSTER FAILOVER </span><br><span class="line"># 注：CLUSTER  help 可以看到帮助文档和简介。 相对安全的做法</span><br></pre></td></tr></table></figure>

<h1 id="11、扩容"><a href="#11、扩容" class="headerlink" title="11、扩容"></a>11、扩容</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 1、 启动新节点</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;6387.conf</span><br><span class="line"></span><br><span class="line"># 2、 加入到已经存在的集群作为master</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli --cluster add-node 192.168.100.242:6387 192.168.100.242:6382</span><br><span class="line"># 本质就是发送一个新节点通过 CLUSTER MEET命令加入集群</span><br><span class="line"># 新节点没有分配hash槽</span><br><span class="line"></span><br><span class="line"># 3、 加入到已经存在的集群作为slave</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli --cluster add-node 192.168.100.242:7006 192.168.100.242:7000 --cluster-slave</span><br><span class="line"># 可以手工指定master，否则就是选择一个slave数量较少的master </span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli --cluster add-node 192.168.100.242:7006 192.168.100.242:7000 --cluster-slave --cluster-master-id &lt;node-id&gt;</span><br><span class="line"># 还可以将空master，转换为slave</span><br><span class="line">cluster replicate &lt;master-node-id&gt;</span><br><span class="line"></span><br><span class="line"># 4、 检查集群</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli --cluster check 192.168.100.242:6382</span><br></pre></td></tr></table></figure>

<h1 id="12、缩容（删除节点）"><a href="#12、缩容（删除节点）" class="headerlink" title="12、缩容（删除节点）"></a>12、缩容（删除节点）</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 注意：删除master的时候要把数据清空或者分配给其他主节点</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli --cluster del-node 192.168.100.242:6381 &lt;node-id&gt;</span><br></pre></td></tr></table></figure>

<h1 id="13、关心的问题"><a href="#13、关心的问题" class="headerlink" title="13、关心的问题"></a>13、关心的问题</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 1、 增加了slot槽的计算，是不是比单机性能差？</span><br><span class="line">共16384个槽，slots槽计算方式公开的，java客户端中就使用了：HASH_SLOT &#x3D; CRC16(key) mod 16384</span><br><span class="line">为了避免每次都需要服务器计算重定向，优秀的java客户端都实现了本地计算，和服务器slots分配进行映射，有变动时再更新本地内容。</span><br><span class="line"></span><br><span class="line"># 2、 redis集群大小</span><br><span class="line">理论是可以做到16384个槽，但是redis官方建议是最大1000个实例</span><br><span class="line"></span><br><span class="line"># 3、 批量操作或者</span><br><span class="line"></span><br><span class="line"># 4、cluster meet命令中的bus-port是什么？</span><br><span class="line">MEET &lt;ip&gt; &lt;port&gt; [bus-port]</span><br><span class="line">每个Redis群集节点都有一个额外的TCP端口，用于接收来自其他Redis群集节点的传入连接</span><br><span class="line"></span><br><span class="line"># 5、集群节点间的通信方式</span><br><span class="line">每个节点使用TCP连接与每个其他节点连接。</span><br><span class="line"></span><br><span class="line"># 6、ask和moved重定向的区别</span><br><span class="line">重定向包括两种情况</span><br><span class="line">如果是确定slot不属于当前节点，redis会返回moved</span><br><span class="line">如果当前redis节点正在处理slot迁移，则代表此处请求对应的key暂时不在此节点，返回ask，告诉客户端本次请求重定向</span><br><span class="line"></span><br><span class="line"># 7、数据倾斜和访问倾斜的问题</span><br><span class="line">解决办法 调整key的策略 + slot迁移</span><br><span class="line">迁移过程如下，完整的迁移流程：</span><br><span class="line">在迁移目的节点执行cluster setslot &lt;slot&gt; IMPORTING &lt;node ID&gt;命令，指明需要迁移的slot和迁移源节点。</span><br><span class="line">在迁移源节点执行cluster setslot &lt;slot&gt; MIGRATING &lt;node ID&gt;命令，指明需要迁移的slot和迁移目的节点。</span><br><span class="line">在迁移源节点执行cluster getkeysinslot获取该slot的key列表。</span><br><span class="line">在迁移源节点执行对每个key执行migrate命令，该命令会同步把该key迁移到目的节点。</span><br><span class="line">在迁移源节点反复执行cluster getkeysinslot命令，直到该slot的列表为空。</span><br><span class="line">在迁移源节点和目的节点执行cluster setslot &lt;slot&gt; NODE &lt;node ID&gt;，完成迁移操作。</span><br></pre></td></tr></table></figure>


          
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/04/06/redis-info%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/redis-info%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/" itemprop="url">Redis-Info命令详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T00:00:00+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h1 id="Server-服务器基本信息"><a href="#Server-服务器基本信息" class="headerlink" title="Server 服务器基本信息"></a>Server 服务器基本信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># redis版本号</span><br><span class="line">redis_version:5.0.3</span><br><span class="line"># redis源码包git信息</span><br><span class="line">redis_git_sha1:00000000</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:da69b07a37c06dc8</span><br><span class="line"># 运行模式(“独立”，“哨兵”或“集群”)</span><br><span class="line">redis_mode:standalone</span><br><span class="line"># 操作系统信息</span><br><span class="line">os:Linux 3.10.0-514.el7.x86_64 x86_64</span><br><span class="line"># 64位架构</span><br><span class="line">arch_bits:64</span><br><span class="line"># 编译运行的底层依赖信息</span><br><span class="line">multiplexing_api:epoll</span><br><span class="line">atomicvar_api:atomic-builtin</span><br><span class="line">gcc_version:4.8.5</span><br><span class="line"># 进程ID</span><br><span class="line">process_id:10040</span><br><span class="line"># 实例运行的随机值标识符(sentinel和集群中有用)</span><br><span class="line">run_id:df903681f11f712523e0615cd4c7e45afbf500b6</span><br><span class="line"># 端口</span><br><span class="line">tcp_port:6379</span><br><span class="line"># 运行时长</span><br><span class="line">uptime_in_seconds:42593</span><br><span class="line"># 运行时长(天)</span><br><span class="line">uptime_in_days:0</span><br><span class="line"># 服务器的频率设置</span><br><span class="line">hz:10</span><br><span class="line">configured_hz:10</span><br><span class="line"># LRU运作的时钟(分钟为单位)</span><br><span class="line">lru_clock:7473903</span><br><span class="line"># 可执行文件</span><br><span class="line">executable:&#x2F;usr&#x2F;local&#x2F;redis&#x2F;.&#x2F;bin&#x2F;redis-server</span><br><span class="line"># 当前读取的配置</span><br><span class="line">config_file:&#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;redis_6379.conf</span><br></pre></td></tr></table></figure>

<h1 id="Clients-客户端连接信息"><a href="#Clients-客户端连接信息" class="headerlink" title="Clients 客户端连接信息"></a>Clients 客户端连接信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 连接数</span><br><span class="line">connected_clients:1</span><br><span class="line"># 客户端输入缓冲区</span><br><span class="line">client_recent_max_input_buffer:2</span><br><span class="line"># 客户端输出缓冲区</span><br><span class="line">client_recent_max_output_buffer:0</span><br><span class="line"># 阻塞的客户端数量(卡住了就看看这个)</span><br><span class="line">blocked_clients:0</span><br></pre></td></tr></table></figure>

<h1 id="Memory内存信息"><a href="#Memory内存信息" class="headerlink" title="Memory内存信息"></a>Memory内存信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"># 内存总量(字节数)</span><br><span class="line">used_memory:854280</span><br><span class="line"># 内存总量(更方便查看的格式)</span><br><span class="line">used_memory_human:834.26K</span><br><span class="line"># 已分配的内存总量</span><br><span class="line">used_memory_rss:8388608</span><br><span class="line">used_memory_rss_human:8.00M</span><br><span class="line"># 内存消耗峰值</span><br><span class="line">used_memory_peak:854280</span><br><span class="line">used_memory_peak_human:834.26K</span><br><span class="line"># 峰值内存占用的内存百分比</span><br><span class="line">used_memory_peak_perc:100.15%</span><br><span class="line"># 内部机制所需的内存</span><br><span class="line">used_memory_overhead:840838</span><br><span class="line"># 启动时消耗的内存</span><br><span class="line">used_memory_startup:791032</span><br><span class="line"># 数据占用的内存大小</span><br><span class="line">used_memory_dataset:13442</span><br><span class="line"># 数据占用的内存大小百分比</span><br><span class="line">used_memory_dataset_perc:21.25%</span><br><span class="line"># 未说明（从名字可以看出是内存申请的信息）</span><br><span class="line">allocator_allocated:844856</span><br><span class="line">allocator_active:1011712</span><br><span class="line">allocator_resident:3665920</span><br><span class="line"># 整个系统内存</span><br><span class="line">total_system_memory:1041199104</span><br><span class="line">total_system_memory_human:992.96M</span><br><span class="line"># Lua脚本存储占用的内存</span><br><span class="line">used_memory_lua:37888</span><br><span class="line">used_memory_lua_human:37.00K</span><br><span class="line"># 未说明</span><br><span class="line">used_memory_scripts:0</span><br><span class="line">used_memory_scripts_human:0B</span><br><span class="line">number_of_cached_scripts:0</span><br><span class="line"># 最大内存配置</span><br><span class="line">maxmemory:0</span><br><span class="line">maxmemory_human:0B</span><br><span class="line"># 内存管理策略</span><br><span class="line">maxmemory_policy:noeviction</span><br><span class="line"># 官方未说明</span><br><span class="line">allocator_frag_ratio:1.20</span><br><span class="line">allocator_frag_bytes:166856</span><br><span class="line">allocator_rss_ratio:3.62</span><br><span class="line">allocator_rss_bytes:2654208</span><br><span class="line">rss_overhead_ratio:2.29</span><br><span class="line">rss_overhead_bytes:4722688</span><br><span class="line">mem_fragmentation_ratio:10.33</span><br><span class="line">mem_fragmentation_bytes:7576576</span><br><span class="line">mem_not_counted_for_evict:0</span><br><span class="line">mem_replication_backlog:0</span><br><span class="line">mem_clients_slaves:0</span><br><span class="line">mem_clients_normal:49694</span><br><span class="line">mem_aof_buffer:0</span><br><span class="line"># 内存分配器，在编译时选择</span><br><span class="line">mem_allocator:jemalloc-5.1.0</span><br><span class="line"># 碎片整理是否存于活动状态</span><br><span class="line">active_defrag_running:0</span><br><span class="line"># 等待被释放的对象数量</span><br><span class="line">lazyfree_pending_objects:0</span><br></pre></td></tr></table></figure>

<h1 id="Persistence持久化相关"><a href="#Persistence持久化相关" class="headerlink" title="Persistence持久化相关"></a>Persistence持久化相关</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"># 表示Redis是否正在加载备份文件的标志</span><br><span class="line">loading:0</span><br><span class="line"># 从最近一次转储至今，RDB的修改次数</span><br><span class="line">rdb_changes_since_last_save:2</span><br><span class="line"># 表示Redis正在保存RDB的标志</span><br><span class="line">rdb_bgsave_in_progress:0</span><br><span class="line"># 上次RDB成功保存的时间戳</span><br><span class="line">rdb_last_save_time:1550935182</span><br><span class="line"># 最后一次RDB保存操作的状态</span><br><span class="line">rdb_last_bgsave_status:ok</span><br><span class="line"># 最后一次RDB保存操作的持续时间（以秒为单位）</span><br><span class="line">rdb_last_bgsave_time_sec:-1</span><br><span class="line"># 正在进行的RDB保存操作的持续时间（如果有）</span><br><span class="line">rdb_current_bgsave_time_sec:-1</span><br><span class="line"># 上次RBD保存操作期间写时复制分配的字节大小</span><br><span class="line">rdb_last_cow_size:0</span><br><span class="line"># 表示AOF记录的标志已激活</span><br><span class="line">aof_enabled:1</span><br><span class="line"># 表示AOF重写操作的标志正在进行中</span><br><span class="line">aof_rewrite_in_progress:0</span><br><span class="line"># 一旦正在进行的RDB保存完成，将指定表示AOF重写操作的标志。</span><br><span class="line">aof_rewrite_scheduled:0</span><br><span class="line"># 最后一次AOF重写操作的持续时间，以秒为单位</span><br><span class="line">aof_last_rewrite_time_sec:-1</span><br><span class="line"># 正在进行的AOF重写操作的持续时间（如果有）</span><br><span class="line">aof_current_rewrite_time_sec:-1</span><br><span class="line"># 最后一次AOF重写操作的状态</span><br><span class="line">aof_last_bgrewrite_status:ok</span><br><span class="line"># 最后一次写入操作到AOF的状态</span><br><span class="line">aof_last_write_status:ok</span><br><span class="line"># 上次AOF重写操作期间写时复制分配的大小（以字节为单位）</span><br><span class="line">aof_last_cow_size:0</span><br><span class="line"># AOF当前文件大小</span><br><span class="line">aof_current_size:77</span><br><span class="line"># 最新启动或重写时的AOF文件大小</span><br><span class="line">aof_base_size:77</span><br><span class="line"># 一旦正在进行的RDB保存完成，将指定表示AOF重写操作的标志。</span><br><span class="line">aof_pending_rewrite:0</span><br><span class="line"># AOF缓冲区的大小</span><br><span class="line">aof_buffer_length:0</span><br><span class="line"># AOF重写缓冲区的大小</span><br><span class="line">aof_rewrite_buffer_length:0</span><br><span class="line"># fsync挂起作业数</span><br><span class="line">aof_pending_bio_fsync:0</span><br><span class="line"># 延迟fsync计数器</span><br><span class="line">aof_delayed_fsync:0</span><br><span class="line"># 如果数据恢复中可能会有这些值</span><br><span class="line"># loading_start_time：加载操作开始的时间戳</span><br><span class="line"># loading_total_bytes：文件总大小</span><br><span class="line"># loading_loaded_bytes：已加载的字节数</span><br><span class="line"># loading_loaded_perc：相同的值表示为百分比</span><br><span class="line"># loading_eta_seconds：ETA在几秒钟内完成负载</span><br></pre></td></tr></table></figure>

<h1 id="Stats-试试监控信息"><a href="#Stats-试试监控信息" class="headerlink" title="Stats 试试监控信息"></a>Stats 试试监控信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># Redis服务器接受的连接总数</span><br><span class="line">total_connections_received:1</span><br><span class="line"># Redis服务器处理的命令总数</span><br><span class="line">total_commands_processed:1</span><br><span class="line"># 每秒钟处理的命令数量</span><br><span class="line">instantaneous_ops_per_sec:0</span><br><span class="line"># 通过网络接收的数据总量，以字节为单位</span><br><span class="line">total_net_input_bytes:34</span><br><span class="line"># 通过网络发送的数据总量，以字节为单位</span><br><span class="line">total_net_output_bytes:7</span><br><span class="line"># 每秒钟接收数据的速率，以kbps为单位</span><br><span class="line">instantaneous_input_kbps:0.00</span><br><span class="line"># 每秒钟发送数据的速率，以kbps为单位</span><br><span class="line">instantaneous_output_kbps:0.00</span><br><span class="line"># Redis服务器由于maxclients限制而拒绝的连接数量</span><br><span class="line">rejected_connections:0</span><br><span class="line"># Redis主机和从机进行完全同步的次数</span><br><span class="line">sync_full:0</span><br><span class="line"># Redis服务器接受PSYNC请求的次数</span><br><span class="line">sync_partial_ok:0</span><br><span class="line"># Redis服务器拒绝PSYNC请求的次数</span><br><span class="line">sync_partial_err:0</span><br><span class="line"># 键过期事件的总数</span><br><span class="line">expired_keys:0</span><br><span class="line">expired_stale_perc:0.00</span><br><span class="line">expired_time_cap_reached_count:0</span><br><span class="line"># 由于maxmemory限制，而被回收内存的键的总数</span><br><span class="line">evicted_keys:0</span><br><span class="line"># 在主字典中成功查找到键的次数</span><br><span class="line">keyspace_hits:1</span><br><span class="line"># 在主字典中未能成功查找到键的次数</span><br><span class="line">keyspace_misses:0</span><br><span class="line"># 发布&#x2F;订阅频道的总数量</span><br><span class="line">pubsub_channels:0</span><br><span class="line"># 客户端订阅的发布&#x2F;订阅模式的总数量</span><br><span class="line">pubsub_patterns:0</span><br><span class="line"># 最近一次fork操作消耗的时间，以微秒为单位</span><br><span class="line">latest_fork_usec:0</span><br><span class="line"># 迁移已缓存的套接字的数量</span><br><span class="line">migrate_cached_sockets:0</span><br><span class="line"># 为实现key过期而跟踪的key数数量（仅适用于可写副本）</span><br><span class="line">slave_expires_tracked_keys:0</span><br><span class="line"># 碎片整理过程执行的值重新分配的数量</span><br><span class="line">active_defrag_hits:0</span><br><span class="line"># 碎片整理过程启动的中止值重新分配数</span><br><span class="line">active_defrag_misses:0</span><br><span class="line"># 碎片整理的key数量</span><br><span class="line">active_defrag_key_hits:0</span><br><span class="line"># 碎片整理过程跳过的key数量</span><br><span class="line">active_defrag_key_misses:0</span><br></pre></td></tr></table></figure>

<h1 id="Replication主从复制相关信息"><a href="#Replication主从复制相关信息" class="headerlink" title="Replication主从复制相关信息"></a>Replication主从复制相关信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 角色 master或者 slave</span><br><span class="line">role:master</span><br><span class="line"># 已连接的Redis从机的数量</span><br><span class="line">connected_slaves:0</span><br><span class="line"># 主从复制过程中master的标识id</span><br><span class="line">master_replid:6ea01bd968c7f14cb6de138462ddaf11930a4269</span><br><span class="line">master_replid2:0000000000000000000000000000000000000000</span><br><span class="line"># 全局的复制偏移量</span><br><span class="line">master_repl_offset:0</span><br><span class="line">second_repl_offset:-1</span><br><span class="line"># 表示Redis服务器是否为部分同步开启复制备份日志</span><br><span class="line">repl_backlog_active:0</span><br><span class="line"># 备份日志的循环缓冲区的大小</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line"># 备份日志缓冲区中的首个字节的复制偏移量</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line"># 备份日志的实际数据长度</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"># 主从复制情况下可能会有的一些额外信息</span><br><span class="line"># master_host：Redis主机的主机名或IP地址</span><br><span class="line"># master_port：Redis主机监听的TCP端口</span><br><span class="line"># master_link_status：链路状态（连接&#x2F;断开</span><br><span class="line"># master_last_io_seconds_ago：最近一次和Redis主机交互至今的消耗时间，以秒为单位</span><br><span class="line"># master_sync_in_progress：表示Redis主机正在将数据同步至从机</span><br><span class="line"># master_sync_left_bytes：在同步完成之前，还剩余的数据总量，以字节为单位</span><br><span class="line"># master_sync_last_io_seconds_ago：在一次SYNC操作期间，最近一次传输数据的I&#x2F;O操作至今的消耗时间，以秒为单位</span><br><span class="line"># master_link_down_since_seconds：从链路断开至今的时间，以秒为单位</span><br></pre></td></tr></table></figure>

<h1 id="CPU信息"><a href="#CPU信息" class="headerlink" title="CPU信息"></a>CPU信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 服务器耗费的系统 CPU</span><br><span class="line">used_cpu_sys:26.932586</span><br><span class="line"># 服务器耗费的用户 CPU</span><br><span class="line">used_cpu_user:36.964424</span><br><span class="line"># 后台进程耗费的系统 CPU</span><br><span class="line">used_cpu_sys_children:0.000000</span><br><span class="line"># 后台进程耗费的用户 CPU</span><br><span class="line">used_cpu_user_children:0.000000</span><br></pre></td></tr></table></figure>

<h1 id="Cluster集群信息"><a href="#Cluster集群信息" class="headerlink" title="Cluster集群信息"></a>Cluster集群信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 一个标志值，记录集群功能是否已经开启</span><br><span class="line">cluster_enabled:0</span><br></pre></td></tr></table></figure>

<h1 id="Keyspace键存储空间信息"><a href="#Keyspace键存储空间信息" class="headerlink" title="Keyspace键存储空间信息"></a>Keyspace键存储空间信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 数据库的key数量、处于有效时间内的key数量，过期key数量</span><br><span class="line">db0:keys&#x3D;2,expires&#x3D;0,avg_ttl&#x3D;0</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/04/06/rabbitmq%E5%8D%95%E6%9C%BA%E5%88%B0%E9%9B%86%E7%BE%A4%E5%AE%8C%E6%95%B4%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/rabbitmq%E5%8D%95%E6%9C%BA%E5%88%B0%E9%9B%86%E7%BE%A4%E5%AE%8C%E6%95%B4%E6%90%AD%E5%BB%BA/" itemprop="url">RabbitMQ的安装及使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T00:00:00+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h1 id="RabbitMQ-安装和使用"><a href="#RabbitMQ-安装和使用" class="headerlink" title="RabbitMQ 安装和使用"></a><strong>RabbitMQ 安装和使用</strong></h1><h2 id="一、安装依赖环境"><a href="#一、安装依赖环境" class="headerlink" title="一、安装依赖环境"></a><strong>一、安装依赖环境</strong></h2><ol>
<li><p>在 <a href="http://www.rabbitmq.com/which-erlang.html" target="_blank" rel="noopener">http://www.rabbitmq.com/which-erlang.html</a> 页面查看安装rabbitmq需要安装erlang对应的版本</p>
</li>
<li><p>在 <a href="https://github.com/rabbitmq/erlang-rpm/releases" target="_blank" rel="noopener">https://github.com/rabbitmq/erlang-rpm/releases</a> 页面找到需要下载的erlang版本，<code>erlang-*.centos.x86_64.rpm</code>就是centos版本的。</p>
</li>
<li><p>复制下载地址后，使用wget命令下载</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -P /home/download https://github.com/rabbitmq/erlang-rpm/releases/download/v21.2.3/erlang-21.2.3-1.el7.centos.x86_64.rpm</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 Erlang</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -Uvh /home/download/erlang-21.2.3-1.el7.centos.x86_64.rpm</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 socat</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y socat</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="二、安装RabbitMQ"><a href="#二、安装RabbitMQ" class="headerlink" title="二、安装RabbitMQ"></a><strong>二、安装RabbitMQ</strong></h2><ol>
<li><p>在<a href="http://www.rabbitmq.com/download.html" target="_blank" rel="noopener">官方下载页面</a>找到CentOS7版本的下载链接，下载rpm安装包</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -P /home/download https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.7.9/rabbitmq-server-3.7.9-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure>
<p><strong><code>提示：可以在</code><a href="https://github.com/rabbitmq/rabbitmq-server/tags`下载历史版本`" target="_blank" rel="noopener">https://github.com/rabbitmq/rabbitmq-server/tags`下载历史版本`</a></strong></p>
</li>
<li><p>安装RabbitMQ</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm -Uvh /home/download/rabbitmq-server-3.7.9-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="三、启动和关闭"><a href="#三、启动和关闭" class="headerlink" title="三、启动和关闭"></a><strong>三、启动和关闭</strong></h2><ul>
<li><p>启动服务</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start rabbitmq-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看状态</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止服务</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop rabbitmq-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置开机启动</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> rabbitmq-server</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="四、开启Web管理插件"><a href="#四、开启Web管理插件" class="headerlink" title="四、开启Web管理插件"></a><strong>四、开启Web管理插件</strong></h2><ol>
<li><p>开启插件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins <span class="built_in">enable</span> rabbitmq_management</span><br></pre></td></tr></table></figure>
<p><strong><code>说明：rabbitmq有一个默认的guest用户，但只能通过localhost访问，所以需要添加一个能够远程访问的用户。</code></strong></p>
</li>
<li><p>添加用户</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl add_user admin admin</span><br></pre></td></tr></table></figure>
</li>
<li><p>为用户分配操作权限</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure>
</li>
<li><p>为用户分配资源权限</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p / admin <span class="string">".*"</span> <span class="string">".*"</span> <span class="string">".*"</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<h2 id="五、防火墙添加端口"><a href="#五、防火墙添加端口" class="headerlink" title="五、防火墙添加端口"></a><strong>五、防火墙添加端口</strong></h2><ul>
<li>RabbitMQ 服务启动后，还不能进行外部通信，需要将端口添加都防火墙</li>
</ul>
<ol>
<li><p>添加端口</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=4369/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=5672/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=25672/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=15672/tcp --permanent</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启防火墙</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h1 id="多机多节点集群部署"><a href="#多机多节点集群部署" class="headerlink" title="多机多节点集群部署"></a><strong>多机多节点集群部署</strong></h1><h2 id="一、-环境准备"><a href="#一、-环境准备" class="headerlink" title="一、 环境准备"></a><strong>一、 环境准备</strong></h2><ul>
<li><p>准备三台安装好RabbitMQ 的机器，安装方法见 <a href="#rabbitmq-安装和使用">安装步骤</a></p>
<ul>
<li>10.10.1.41</li>
<li>10.10.1.42</li>
<li>10.10.1.43</li>
</ul>
<p><strong><code>提示：如果使用虚拟机，可以在一台VM上安装好RabbitMQ后，创建快照，从快照创建链接克隆，会节省很多磁盘空间</code></strong></p>
</li>
</ul>
<h2 id="二、修改配置文件"><a href="#二、修改配置文件" class="headerlink" title="二、修改配置文件"></a><strong>二、修改配置文件</strong></h2><ol>
<li><p>修改<code>10.10.1.41</code>机器上的<code>/etc/hosts</code>文件</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加IP和节点名</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.10.1.41 node1</span><br><span class="line">10.10.1.42 node2</span><br><span class="line">10.10.1.43 node3</span><br></pre></td></tr></table></figure></li>
<li><p>修改对应主机的hostname</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hostname node1</span><br><span class="line">hostname node2</span><br><span class="line">hostname node3</span><br></pre></td></tr></table></figure></li>
<li><p>将<code>10.10.1.41</code>上的hosts文件复制到另外两台机器上</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo scp /etc/hosts root@node2:/etc/</span><br><span class="line">sudo scp /etc/hosts root@node3:/etc/</span><br></pre></td></tr></table></figure>
<p><strong><code>说明：命令中的root是目标机器的用户名，命令执行后，可能会提示需要输入密码，输入对应用户的密码就行了</code></strong></p>
</li>
<li><p>将<code>10.10.1.41</code>上的<code>/var/lib/rabbitmq/.erlang.cookie</code>文件复制到另外两台机器上</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@node2:/var/lib/rabbitmq/</span><br><span class="line">scp /var/lib/rabbitmq/.erlang.cookie root@node3:/var/lib/rabbitmq/</span><br></pre></td></tr></table></figure>
<p><strong><code>提示：如果是通过克隆的VM，可以省略这一步</code></strong></p>
</li>
</ol>
<h2 id="三、防火墙添加端口"><a href="#三、防火墙添加端口" class="headerlink" title="三、防火墙添加端口"></a><strong>三、防火墙添加端口</strong></h2><ul>
<li>给每台机器的防火墙添加端口</li>
</ul>
<ol>
<li><p>添加端口</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=4369/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=5672/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=25672/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=15672/tcp --permanent</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启防火墙</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="四、启动RabbitMQ"><a href="#四、启动RabbitMQ" class="headerlink" title="四、启动RabbitMQ"></a><strong>四、启动RabbitMQ</strong></h3><ol>
<li><p>启动每台机器的RabbitMQ</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start rabbitmq-server</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure>
</li>
<li><p>将<code>10.10.1.42</code>加入到集群</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止RabbitMQ 应用</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"><span class="comment"># 重置RabbitMQ 设置</span></span><br><span class="line">rabbitmqctl reset</span><br><span class="line"><span class="comment"># 加入到集群</span></span><br><span class="line">rabbitmqctl join_cluster rabbit@node1 --ram</span><br><span class="line"><span class="comment"># 启动RabbitMQ 应用</span></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看集群状态，看到<code>running_nodes,[rabbit@node1,rabbit@node2]</code>表示节点启动成功</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure>
<p><strong><code>提示：在管理界面可以更直观的看到集群信息</code></strong></p>
</li>
<li><p>将<code>10.10.1.43</code>加入到集群</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止 RabbitMQ 应用</span></span><br><span class="line">rabbitmqctl stop_app</span><br><span class="line"><span class="comment"># 重置 RabbitMQ 设置</span></span><br><span class="line">rabbitmqctl reset</span><br><span class="line"><span class="comment"># 节点加入到集群</span></span><br><span class="line">rabbitmqctl join_cluster rabbit@node1 --ram</span><br><span class="line"><span class="comment"># 启动 RabbitMQ 应用</span></span><br><span class="line">rabbitmqctl start_app</span><br></pre></td></tr></table></figure>
</li>
<li><p>重复地3步，查看集群状态</p>
</li>
</ol>
<hr>
<h1 id="单机多节点部署"><a href="#单机多节点部署" class="headerlink" title="单机多节点部署"></a><strong>单机多节点部署</strong></h1><h2 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a><strong>一、环境准备</strong></h2><ul>
<li>准备一台已经安装好RabbitMQ 的机器，安装方法见 <a href="#rabbitmq-安装和使用">安装步骤</a><ul>
<li>10.10.1.41</li>
</ul>
</li>
</ul>
<h2 id="二、启动RabbitMQ"><a href="#二、启动RabbitMQ" class="headerlink" title="二、启动RabbitMQ"></a><strong>二、启动RabbitMQ</strong></h2><ol>
<li><p>在启动前，先修改RabbitMQ 的默认节点名（非必要），在<code>/etc/rabbitmq/rabbitmq-env.conf</code>增加以下内容</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># RabbitMQ 默认节点名，默认是rabbit</span></span><br><span class="line">NODENAME=rabbit1</span><br></pre></td></tr></table></figure>
</li>
<li><p>RabbitMQ 默认是使用服务的启动的，单机多节点时需要改为手动启动，先停止运行中的RabbitMQ 服务</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl stop rabbitmq-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动第一个节点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动第二个节点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RABBITMQ_NODE_PORT=5673 RABBITMQ_SERVER_START_ARGS=<span class="string">"-rabbitmq_management listener [&#123;port,15673&#125;]"</span> RABBITMQ_NODENAME=rabbit2 rabbitmq-server -detached</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动第三个节点</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RABBITMQ_NODE_PORT=5674 RABBITMQ_SERVER_START_ARGS=<span class="string">"-rabbitmq_management listener [&#123;port,15674&#125;]"</span> RABBITMQ_NODENAME=rabbit3 rabbitmq-server -detached</span><br></pre></td></tr></table></figure>
</li>
<li><p>将rabbit2加入到集群</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止 rabbit2 的应用</span></span><br><span class="line">rabbitmqctl -n rabbit2 stop_app</span><br><span class="line"><span class="comment"># 重置 rabbit2 的设置</span></span><br><span class="line">rabbitmqctl -n rabbit2 reset</span><br><span class="line"><span class="comment"># rabbit2 节点加入到 rabbit1的集群中</span></span><br><span class="line">rabbitmqctl -n rabbit2 join_cluster rabbit1 --ram</span><br><span class="line"><span class="comment"># 启动 rabbit2 节点</span></span><br><span class="line">rabbitmqctl -n rabbit2 start_app</span><br></pre></td></tr></table></figure>
</li>
<li><p>将rabbit3加入到集群</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止 rabbit3 的应用</span></span><br><span class="line">rabbitmqctl -n rabbit3 stop_app</span><br><span class="line"><span class="comment"># 重置 rabbit3 的设置</span></span><br><span class="line">rabbitmqctl -n rabbit3 reset</span><br><span class="line"><span class="comment"># rabbit3 节点加入到 rabbit1的集群中</span></span><br><span class="line">rabbitmqctl -n rabbit3 join_cluster rabbit1 --ram</span><br><span class="line"><span class="comment"># 启动 rabbit3 节点</span></span><br><span class="line">rabbitmqctl -n rabbit3 start_app</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看集群状态，看到<code>{running_nodes,[rabbit3@node1,rabbit2@node1,rabbit1@node1]}</code>说明节点已启动成功。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl cluster_status</span><br></pre></td></tr></table></figure>
<p><strong><code>提示：在管理界面可以更直观的看到集群信息</code></strong></p>
</li>
</ol>
<h2 id="三、防火墙添加端口-1"><a href="#三、防火墙添加端口-1" class="headerlink" title="三、防火墙添加端口"></a><strong>三、防火墙添加端口</strong></h2><ul>
<li>需要将每个节点的端口都添加到防火墙</li>
</ul>
<ol>
<li><p>添加端口</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=4369/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=5672/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=25672/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=15672/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=5673/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=25673/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=15673/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=5674/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=25674/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=15674/tcp --permanent</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启防火墙</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>

</li>
</ol>
<hr>
<h1 id="镜像队列模式集群"><a href="#镜像队列模式集群" class="headerlink" title="镜像队列模式集群"></a><strong>镜像队列模式集群</strong></h1><ul>
<li><p>镜像队列属于RabbitMQ 的高可用方案，见：<a href="https://www.rabbitmq.com/ha.html#mirroring-arguments" target="_blank" rel="noopener">https://www.rabbitmq.com/ha.html#mirroring-arguments</a></p>
</li>
<li><p>通过前面的步骤搭建的集群属于普通模式集群，是通过共享元数据实现集群</p>
</li>
<li><p>开启镜像队列模式需要在管理页面添加策略，添加方式：</p>
<ol>
<li><p>进入管理页面 -&gt; Admin -&gt; Policies（在页面右侧）-&gt; Add / update a policy</p>
</li>
<li><p>在表单中填入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">      name: ha-all</span><br><span class="line">   Pattern: ^</span><br><span class="line">  Apply to: Queues</span><br><span class="line">  Priority: 0</span><br><span class="line">Definition: ha-mode &#x3D; all</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong></p>
<p>name: 策略名称，如果使用已有的名称，保存后将会修改原来的信息</p>
<p>Apply to：策略应用到什么对象上</p>
<p>Pattern：策略应用到对象时，对象名称的匹配规则（正则表达式）</p>
<p>Priority：优先级，数值越大，优先级越高，相同优先级取最后一个</p>
<p>Definition：策略定义的类容，对于镜像队列的配置来说，只需要包含3个部分: <code>ha-mode</code> 、<code>ha-params</code> 和 <code>ha-sync-mode</code>。其中，<code>ha-sync-mode</code>是同步的方式，自动还是手动，默认是自动。<code>ha-mode</code> 和 <code>ha-params</code> 组合使用。组合方式如下：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center">ha-mode</th>
<th align="center">ha-params</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">all</td>
<td align="center">(empty)</td>
<td align="left">队列镜像到集群类所有节点</td>
</tr>
<tr>
<td align="center">exactly</td>
<td align="center">count</td>
<td align="left">队列镜像到集群内指定数量的节点。如果集群内节点数少于此值，队列将会镜像到所有节点。如果大于此值，而且一个包含镜像的节点停止，则新的镜像不会在其它节点创建。</td>
</tr>
<tr>
<td align="center">nodes</td>
<td align="center">nodename</td>
<td align="left">队列镜像到指定节点，指定的节点不在集群中不会报错。当队列申明时，如果指定的节点不在线，则队列会被创建在客户端所连接的节点上。</td>
</tr>
</tbody></table>
</li>
<li><p>镜像队列模式相比较普通模式，镜像模式会占用更多的带宽来进行同步，所以镜像队列的吞吐量会低于普通模式</p>
</li>
<li><p>但普通模式不能实现高可用，某个节点挂了后，这个节点上的消息将无法被消费，需要等待节点启动后才能被消费。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/04/06/rocketmq%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/rocketmq%E5%8F%AF%E8%A7%86%E5%8C%96%E7%AE%A1%E7%90%86/" itemprop="url">RocketMQ可视化管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T00:00:00+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<blockquote>
<p>rocketmq默认不带可视化控制台，需要去单独编译一个工具 <a href="https://github.com/apache/rocketmq-externals" target="_blank" rel="noopener">https://github.com/apache/rocketmq-externals</a></p>
</blockquote>
<h3 id="1-git-clone源码"><a href="#1-git-clone源码" class="headerlink" title="1. git clone源码"></a>1. git clone源码</h3><figure class="highlight plain"><figcaption><span>clone</span><a href="https://github.com/apache/rocketmq-externals```" target="_blank" rel="noopener">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2. 切换版本 </span><br><span class="line">&#96;&#96;&#96; git checkout rocketmq-console-1.0.0</span><br></pre></td></tr></table></figure>

<h3 id="3-编译为jar"><a href="#3-编译为jar" class="headerlink" title="3. 编译为jar"></a>3. 编译为jar</h3><figure class="highlight plain"><figcaption><span>clean package -Dmaven.test.skip</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 4. 启动</span><br></pre></td></tr></table></figure>
<h1 id="jar包在target目录下面，你可以放在一台服务器上面运行"><a href="#jar包在target目录下面，你可以放在一台服务器上面运行" class="headerlink" title="jar包在target目录下面，你可以放在一台服务器上面运行"></a>jar包在target目录下面，你可以放在一台服务器上面运行</h1><p>java -jar rocketmq-console-ng-1.0.0.jar –server.port=8081–rocketmq.config.namesrvAddr=192.168.100.242:9876</p>
<h1 id="–server-port-springboot内置tomcat的端口号，默认8080；"><a href="#–server-port-springboot内置tomcat的端口号，默认8080；" class="headerlink" title="–server.port springboot内置tomcat的端口号，默认8080；"></a>–server.port springboot内置tomcat的端口号，默认8080；</h1><h1 id="–rocketmq-config-namesrvAddr-nameserver的地址"><a href="#–rocketmq-config-namesrvAddr-nameserver的地址" class="headerlink" title="–rocketmq.config.namesrvAddr  nameserver的地址"></a>–rocketmq.config.namesrvAddr  nameserver的地址</h1><p>```</p>

          
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/04/06/redis%E5%93%A8%E5%85%B5%E9%AB%98%E5%8F%AF%E7%94%A8%E6%90%AD%E5%BB%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/redis%E5%93%A8%E5%85%B5%E9%AB%98%E5%8F%AF%E7%94%A8%E6%90%AD%E5%BB%BA/" itemprop="url">Redis哨兵高可用搭建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T00:00:00+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p> [TOC]</p>
<h1 id="Redis下载安装"><a href="#Redis下载安装" class="headerlink" title="Redis下载安装"></a>Redis下载安装</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">下载redis</span><br><span class="line">https:&#x2F;&#x2F;redis.io&#x2F;download</span><br><span class="line"># 下载</span><br><span class="line">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-5.0.3.tar.gz</span><br><span class="line"># Installation</span><br><span class="line">tar xzf redis-5.0.3.tar.gz</span><br><span class="line">cd redis-5.0.3</span><br><span class="line">make</span><br><span class="line"># 创建文件夹 </span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;redis&#x2F;data</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;redis&#x2F;logs</span><br><span class="line"># run</span><br><span class="line">src&#x2F;redis-server</span><br><span class="line"></span><br><span class="line"># warning 1 &gt; 提示修改 linux内核参数</span><br><span class="line"># WARNING: The TCP backlog setting of 511 cannot be enforced because &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn is set to the lower value of 128.</span><br><span class="line">echo 1024 &gt;&#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn</span><br><span class="line"></span><br><span class="line"># warn 2 &gt; 提示如下</span><br><span class="line"># WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add &#39;vm.overcommit_memory &#x3D; 1&#39; to &#x2F;etc&#x2F;sysctl.conf and then reboot or run the command &#39;sysctl vm.overcommit_memory&#x3D;1&#39; for this to take effect.</span><br><span class="line">echo &quot;vm.overcommit_memory &#x3D; 1&quot; &gt;&gt; &#x2F;etc&#x2F;sysctl.conf</span><br><span class="line">sysctl vm.overcommit_memory&#x3D;1</span><br><span class="line"></span><br><span class="line"># warning 3</span><br><span class="line"># WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command &#39;echo never &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled&#39; as root, and add it to your &#x2F;etc&#x2F;rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled</span><br><span class="line">echo never &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 云服务器要注意ip要写对，端口要开放</span><br><span class="line"># 虚拟机要注意防火墙要关闭 systemctl stop firewalld.service</span><br></pre></td></tr></table></figure>

<h1 id="准备配置文件"><a href="#准备配置文件" class="headerlink" title="准备配置文件"></a>准备配置文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 配置文件进行了精简，完整配置可自行和官方提供的完整conf文件进行对照。端口号自行对应修改</span><br><span class="line">#后台启动的意思</span><br><span class="line">daemonize yes </span><br><span class="line"> #端口号(如果同一台服务器上启动，注意要修改为不同的端口)</span><br><span class="line">port 6380</span><br><span class="line"># IP绑定，redis不建议对公网开放，直接绑定0.0.0.0没毛病</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"># 这个文件会自动生成(如果同一台服务器上启动，注意要修改为不同的端口)</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_6380.pid</span><br></pre></td></tr></table></figure>

<h1 id="准备三个redis服务"><a href="#准备三个redis服务" class="headerlink" title="准备三个redis服务"></a>准备三个redis服务</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 1、启动三个Redis</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;redis-6380.conf</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;redis-6381.conf</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;redis-6382.conf</span><br><span class="line"></span><br><span class="line"># 2、配置为 1主2从</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli -p 6381 slaveof 192.168.100.241 6380</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli -p 6382 slaveof 192.168.100.241 6380</span><br><span class="line"></span><br><span class="line"># 3、检查集群</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli -p 6380 info Replication</span><br></pre></td></tr></table></figure>

<h1 id="准备哨兵配置文件"><a href="#准备哨兵配置文件" class="headerlink" title="准备哨兵配置文件"></a>准备哨兵配置文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 配置文件：sentinel.conf，在sentinel运行期间是会被动态修改的</span><br><span class="line"># sentinel如果重启时，根据这个配置来恢复其之前所监控的redis集群的状态</span><br><span class="line"># 绑定IP</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"># 后台运行</span><br><span class="line">daemonize yes</span><br><span class="line"># 默认yes，没指定密码或者指定IP的情况下，外网无法访问</span><br><span class="line">protected-mode no</span><br><span class="line"># 哨兵的端口，客户端通过这个端口来发现redis</span><br><span class="line">port 26380</span><br><span class="line"># 哨兵自己的IP，手动设定也可自动发现，用于与其他哨兵通信</span><br><span class="line"># sentinel announce-ip</span><br><span class="line"># 临时文件夹</span><br><span class="line">dir &#x2F;tmp</span><br><span class="line"># 日志</span><br><span class="line">logfile &quot;&#x2F;usr&#x2F;local&#x2F;redis&#x2F;logs&#x2F;sentinel-26380.log&quot;</span><br><span class="line"># sentinel监控的master的名字叫做mymaster,初始地址为 192.168.100.241 6380,2代表两个及以上哨兵认定为死亡，才认为是真的死亡</span><br><span class="line">sentinel monitor mymaster 192.168.100.241 6380 2</span><br><span class="line"># 发送心跳PING来确认master是否存活</span><br><span class="line"># 如果master在“一定时间范围”内不回应PONG 或者是回复了一个错误消息，那么这个sentinel会主观地(单方面地)认为这个master已经不可用了</span><br><span class="line">sentinel down-after-milliseconds mymaster 1000</span><br><span class="line"># 如果在该时间（ms）内未能完成failover操作，则认为该failover失败</span><br><span class="line">sentinel failover-timeout mymaster 3000</span><br><span class="line"># 指定了在执行故障转移时，最多可以有多少个从Redis实例在同步新的主实例，在从Redis实例较多的情况下这个数字越小，同步的时间越长，完成故障转移所需的时间就越长</span><br><span class="line">sentinel parallel-syncs mymaster 1</span><br></pre></td></tr></table></figure>

<h1 id="启动哨兵集群"><a href="#启动哨兵集群" class="headerlink" title="启动哨兵集群"></a>启动哨兵集群</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;sentinel-26380.conf --sentinel</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;sentinel-26381.conf --sentinel</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server &#x2F;usr&#x2F;local&#x2F;redis&#x2F;conf&#x2F;sentinel-26382.conf --sentinel</span><br></pre></td></tr></table></figure>

<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 停掉master，主从切换过程</span><br><span class="line">启动哨兵(客户端通过哨兵发现Redis实例信息)</span><br><span class="line">哨兵通过连接master发现主从集群内的所有实例信息</span><br><span class="line">哨兵监控redis实例的健康状况</span><br><span class="line">哨兵一旦发现master不能正常提供服务，则通知给其他哨兵</span><br><span class="line">当一定数量的哨兵都认为master挂了</span><br><span class="line">选举一个哨兵作为故障转移的执行者</span><br><span class="line">执行者在slave中选取一个作为新的master</span><br><span class="line">将其他slave重新设定为新master的从属</span><br></pre></td></tr></table></figure>

<h1 id="哨兵同步pubsub机制发出来的消息"><a href="#哨兵同步pubsub机制发出来的消息" class="headerlink" title="哨兵同步pubsub机制发出来的消息"></a>哨兵同步pubsub机制发出来的消息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># https:&#x2F;&#x2F;redis.io&#x2F;topics&#x2F;sentinel#pubsub-messages</span><br><span class="line">+reset-master &lt;instance details&gt; -- 当master被重置时.</span><br><span class="line">+slave &lt;instance details&gt; -- 当检测到一个slave并添加进slave列表时.</span><br><span class="line">+failover-state-reconf-slaves &lt;instance details&gt; -- Failover状态变为reconf-slaves状态时</span><br><span class="line">+failover-detected &lt;instance details&gt; -- 当failover发生时</span><br><span class="line">+slave-reconf-sent &lt;instance details&gt; -- sentinel发送SLAVEOF命令把它重新配置时</span><br><span class="line">+slave-reconf-inprog &lt;instance details&gt; -- slave被重新配置为另外一个master的slave，但数据复制还未发生时。</span><br><span class="line">+slave-reconf-done &lt;instance details&gt; -- slave被重新配置为另外一个master的slave并且数据复制已经与master同步时。</span><br><span class="line">-dup-sentinel &lt;instance details&gt; -- 删除指定master上的冗余sentinel时 (当一个sentinel重新启动时，可能会发生这个事件).</span><br><span class="line">+sentinel &lt;instance details&gt; -- 当master增加了一个sentinel时。</span><br><span class="line">+sdown &lt;instance details&gt; -- 进入SDOWN状态时;</span><br><span class="line">-sdown &lt;instance details&gt; -- 离开SDOWN状态时。</span><br><span class="line">+odown &lt;instance details&gt; -- 进入ODOWN状态时。</span><br><span class="line">-odown &lt;instance details&gt; -- 离开ODOWN状态时。</span><br><span class="line">+new-epoch &lt;instance details&gt; -- 当前配置版本被更新时。</span><br><span class="line">+try-failover &lt;instance details&gt; -- 达到failover条件，正等待其他sentinel的选举。</span><br><span class="line">+elected-leader &lt;instance details&gt; -- 被选举为去执行failover的时候。</span><br><span class="line">+failover-state-select-slave &lt;instance details&gt; -- 开始要选择一个slave当选新master时。</span><br><span class="line">+no-good-slave &lt;instance details&gt; -- 没有合适的slave来担当新master</span><br><span class="line">+selected-slave &lt;instance details&gt; -- 找到了一个适合的slave来担当新master</span><br><span class="line">+promoted-slave -- 确认成功</span><br><span class="line">+failover-state-reconf-slaves -- 开始对slaves进行reconfig操作</span><br><span class="line">+slave-reconf-sent -- 向指定的slave发送“slaveof”指令，告知此slave跟随新的master</span><br><span class="line">+slave-reconf-inprog -- 此slave正在执行slaveof + SYNC过程，slave收到“+slave-reconf-sent”之后将会执行slaveof操作</span><br><span class="line">+slave-reconf-done -- 此slave同步完成，此后leader可以继续下一个slave的reconfig操作</span><br><span class="line">failover-state-send-slaveof-noone &lt;instance details&gt; -- 当把选择为新master的slave的身份进行切换的时候。</span><br><span class="line">failover-end-for-timeout &lt;instance details&gt; -- failover由于超时而失败时。</span><br><span class="line">failover-end &lt;instance details&gt; -- failover成功完成,故障转移结束</span><br><span class="line">switch-master &lt;master name&gt; &lt;oldip&gt; &lt;oldport&gt; &lt;newip&gt; &lt;newport&gt; -- 当master的地址发生变化时。通常这是客户端最感兴趣的消息了。</span><br><span class="line">+tilt -- 进入Tilt模式。</span><br><span class="line">-tilt -- 退出Tilt模式。</span><br></pre></td></tr></table></figure>

<h1 id="哨兵日志分析"><a href="#哨兵日志分析" class="headerlink" title="哨兵日志分析"></a>哨兵日志分析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">sdow (sdown subjectively down)</span><br><span class="line">odown (objectively down)</span><br><span class="line"># 通过日志逐步分析</span><br><span class="line">996:X 23 Nov 01:00:30.020 # +sdown master mymaster 60.205.209.106 6381</span><br><span class="line">996:X 23 Nov 01:00:30.143 # +new-epoch 4</span><br><span class="line">996:X 23 Nov 01:00:30.144 # +vote-for-leader 699538b978f33f677c8be471eed344b3933eca8c 4</span><br><span class="line">996:X 23 Nov 01:00:31.111 # +odown master mymaster 60.205.209.106 6381 #quorum 3&#x2F;2</span><br><span class="line">996:X 23 Nov 01:00:31.111 # Next failover delay: I will not start a failover before Thu Nov 23 01:00:36 2017</span><br><span class="line">996:X 23 Nov 01:00:31.200 # +config-update-from sentinel 699538b978f33f677c8be471eed344b3933eca8c 172.17.171.34 26381 @ mymaster 60.205.209.106 6381</span><br><span class="line">996:X 23 Nov 01:00:31.200 # +switch-master mymaster 60.205.209.106 6381 60.205.209.106 6380</span><br><span class="line">996:X 23 Nov 01:00:31.200 * +slave slave 60.205.209.106:6382 60.205.209.106 6382 @ mymaster 60.205.209.106 6380</span><br><span class="line">996:X 23 Nov 01:00:31.200 * +slave slave 60.205.209.106:6381 60.205.209.106 6381 @ mymaster 60.205.209.106 6380</span><br><span class="line">996:X 23 Nov 01:00:32.233 # +sdown slave 60.205.209.106:6381 60.205.209.106 6381 @ mymaster 60.205.209.106 6380</span><br><span class="line">1073:X 23 Nov 01:00:30.087 # +sdown master mymaster 60.205.209.106 6381</span><br><span class="line">1073:X 23 Nov 01:00:30.139 # +odown master mymaster 60.205.209.106 6381 #quorum 3&#x2F;2</span><br><span class="line">1073:X 23 Nov 01:00:30.139 # +new-epoch 4</span><br><span class="line">1073:X 23 Nov 01:00:30.139 # +try-failover master mymaster 60.205.209.106 6381</span><br><span class="line">1073:X 23 Nov 01:00:30.141 # +vote-for-leader 699538b978f33f677c8be471eed344b3933eca8c 4</span><br><span class="line">1073:X 23 Nov 01:00:30.142 # 8412b6b2ac39a3d36c171590cd23cbe025517c15 voted for 8412b6b2ac39a3d36c171590cd23cbe025517c15 4</span><br><span class="line">1073:X 23 Nov 01:00:30.144 # f8c7e052744926747ef1f31c27da4721fde3faf4 voted for 699538b978f33f677c8be471eed344b3933eca8c 4</span><br><span class="line">1073:X 23 Nov 01:00:30.232 # +elected-leader master mymaster 60.205.209.106 6381</span><br><span class="line">1073:X 23 Nov 01:00:30.232 # +failover-state-select-slave master mymaster 60.205.209.106 6381</span><br><span class="line">1073:X 23 Nov 01:00:30.294 # +selected-slave slave 60.205.209.106:6380 60.205.209.106 6380 @ mymaster 60.205.209.106 6381</span><br><span class="line">1073:X 23 Nov 01:00:30.294 * +failover-state-send-slaveof-noone slave 60.205.209.106:6380 60.205.209.106 6380 @ mymaster 60.205.209.106 6381</span><br><span class="line">1073:X 23 Nov 01:00:30.356 * +failover-state-wait-promotion slave 60.205.209.106:6380 60.205.209.106 6380 @ mymaster 60.205.209.106 6381</span><br><span class="line">1073:X 23 Nov 01:00:31.153 # +promoted-slave slave 60.205.209.106:6380 60.205.209.106 6380 @ mymaster 60.205.209.106 6381</span><br><span class="line">1073:X 23 Nov 01:00:31.153 # +failover-state-reconf-slaves master mymaster 60.205.209.106 6381</span><br><span class="line">1073:X 23 Nov 01:00:31.200 * +slave-reconf-sent slave 60.205.209.106:6382 60.205.209.106 6382 @ mymaster 60.205.209.106 6381</span><br><span class="line">1073:X 23 Nov 01:00:32.149 * +slave-reconf-inprog slave 60.205.209.106:6382 60.205.209.106 6382 @ mymaster 60.205.209.106 6381</span><br><span class="line">1073:X 23 Nov 01:00:32.149 * +slave-reconf-done slave 60.205.209.106:6382 60.205.209.106 6382 @ mymaster 60.205.209.106 6381</span><br><span class="line">1073:X 23 Nov 01:00:32.220 # -odown master mymaster 60.205.209.106 6381</span><br><span class="line">1073:X 23 Nov 01:00:32.220 # +failover-end master mymaster 60.205.209.106 6381</span><br><span class="line">1073:X 23 Nov 01:00:32.220 # +switch-master mymaster 60.205.209.106 6381 60.205.209.106 6380</span><br><span class="line">1073:X 23 Nov 01:00:32.220 * +slave slave 60.205.209.106:6382 60.205.209.106 6382 @ mymaster 60.205.209.106 6380</span><br><span class="line">1073:X 23 Nov 01:00:32.220 * +slave slave 60.205.209.106:6381 60.205.209.106 6381 @ mymaster 60.205.209.106 6380</span><br><span class="line">1073:X 23 Nov 01:00:33.227 # +sdown slave 60.205.209.106:6381 60.205.209.106 6381 @ mymaster 60.205.209.106 6380</span><br><span class="line">1009:X 23 Nov 01:00:30.039 # +sdown master mymaster 60.205.209.106 6381</span><br><span class="line">1009:X 23 Nov 01:00:30.139 # +odown master mymaster 60.205.209.106 6381 #quorum 2&#x2F;2</span><br><span class="line">1009:X 23 Nov 01:00:30.139 # +new-epoch 4</span><br><span class="line">1009:X 23 Nov 01:00:30.139 # +try-failover master mymaster 60.205.209.106 6381</span><br><span class="line">1009:X 23 Nov 01:00:30.142 # +vote-for-leader 8412b6b2ac39a3d36c171590cd23cbe025517c15 4</span><br><span class="line">1009:X 23 Nov 01:00:30.142 # 699538b978f33f677c8be471eed344b3933eca8c voted for 699538b978f33f677c8be471eed344b3933eca8c 4</span><br><span class="line">1009:X 23 Nov 01:00:30.144 # f8c7e052744926747ef1f31c27da4721fde3faf4 voted for 699538b978f33f677c8be471eed344b3933eca8c 4</span><br><span class="line">1009:X 23 Nov 01:00:31.200 # +config-update-from sentinel 699538b978f33f677c8be471eed344b3933eca8c 172.17.171.34 26381 @ mymaster 60.205.209.106 6381</span><br><span class="line">1009:X 23 Nov 01:00:31.200 # +switch-master mymaster 60.205.209.106 6381 60.205.209.106 6380</span><br><span class="line">1009:X 23 Nov 01:00:31.200 * +slave slave 60.205.209.106:6382 60.205.209.106 6382 @ mymaster 60.205.209.106 6380</span><br><span class="line">1009:X 23 Nov 01:00:31.200 * +slave slave 60.205.209.106:6381 60.205.209.106 6381 @ mymaster 60.205.209.106 6380</span><br><span class="line">1009:X 23 Nov 01:00:32.258 # +sdown slave 60.205.209.106:6381 60.205.209.106 6381 @ mymaster 60.205.209.106 6380</span><br></pre></td></tr></table></figure>

<p>数据一致性的处理办法之一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 这些配置仅当redis为master时才有效</span><br><span class="line"># 当master不符合这些条件时，它将停止对外的服务。这种场景主要是用于master在网络上被孤立了。</span><br><span class="line">min-slaves-to-write 1</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/04/06/%E7%BA%BF%E4%B8%8A%E5%86%85%E5%AD%98CPU%E9%97%AE%E9%A2%98%E8%B7%9F%E8%B8%AA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/%E7%BA%BF%E4%B8%8A%E5%86%85%E5%AD%98CPU%E9%97%AE%E9%A2%98%E8%B7%9F%E8%B8%AA/" itemprop="url">线上内存CPU问题跟踪</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T00:00:00+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h1 id="1、资料"><a href="#1、资料" class="headerlink" title="1、资料"></a>1、资料</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">网易性能调优案例我这边的文档：</span><br><span class="line">http:&#x2F;&#x2F;note.youdao.com&#x2F;noteshare?id&#x3D;4e896cdc93694894bccd58174e1bda86&amp;sub&#x3D;03BA0EFE576247FBB7850155102B2A8D</span><br><span class="line"></span><br><span class="line">另外还有一篇也是fullGC相关的同事写的分享文档：</span><br><span class="line">https:&#x2F;&#x2F;note.youdao.com&#x2F;ynoteshare1&#x2F;index.html?id&#x3D;626a6d6f768e180c693911d26bca8318&amp;type&#x3D;note#&#x2F;</span><br></pre></td></tr></table></figure>

<h1 id="2、工具"><a href="#2、工具" class="headerlink" title="2、工具"></a>2、工具</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.eclipse.org&#x2F;mat&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;trust-freedom&#x2F;p&#x2F;6744948.html</span><br><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;82b25cf8cfde</span><br><span class="line"></span><br><span class="line">监控工具cat参考资料 http:&#x2F;&#x2F;www.iigrowing.cn&#x2F;cat_tong_yi_jian_kong_ping_tai_jian_dan_shi_yong.html</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;dianping&#x2F;cat</span><br></pre></td></tr></table></figure>

<h1 id="3、-GC日志"><a href="#3、-GC日志" class="headerlink" title="3、 GC日志"></a>3、 GC日志</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">GC：</span><br><span class="line"></span><br><span class="line">表明进行了一次垃圾回收，前面没有Full修饰，表明这是一次Minor GC ,注意它不表示只GC新生代，并且现有的不管是新生代还是老年代都会STW。</span><br><span class="line"></span><br><span class="line">Allocation Failure：</span><br><span class="line"></span><br><span class="line">表明本次引起GC的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</span><br><span class="line"></span><br><span class="line">ParNew：</span><br><span class="line"></span><br><span class="line">    表明本次GC发生在年轻代并且使用的是ParNew垃圾收集器。ParNew是一个Serial收集器的多线程版本，会使用多个CPU和线程完成垃圾收集工作（默认使用的线程数和CPU数相同，可以使用-XX：ParallelGCThreads参数限制）。该收集器采用复制算法回收内存，期间会停止其他工作线程，即Stop The World。</span><br><span class="line"></span><br><span class="line">367523K-&gt;1293K(410432K)：单位是KB</span><br><span class="line"></span><br><span class="line">三个参数分别为：GC前该内存区域(这里是年轻代)使用容量，GC后该内存区域使用容量，该内存区域总容量。</span><br><span class="line"></span><br><span class="line">0.0023988 secs：</span><br><span class="line"></span><br><span class="line">    该内存区域GC耗时，单位是秒</span><br><span class="line"></span><br><span class="line">522739K-&gt;156516K(1322496K)：</span><br><span class="line"></span><br><span class="line">三个参数分别为：堆区垃圾回收前的大小，堆区垃圾回收后的大小，堆区总大小。</span><br><span class="line"></span><br><span class="line">0.0025301 secs：</span><br><span class="line"></span><br><span class="line">该内存区域GC耗时，单位是秒</span><br><span class="line"></span><br><span class="line">[Times: user&#x3D;0.04 sys&#x3D;0.00, real&#x3D;0.01 secs]：</span><br><span class="line"></span><br><span class="line">    分别表示用户态耗时，内核态耗时和总耗时</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">分析下可以得出结论：</span><br><span class="line"></span><br><span class="line">    该次GC新生代减少了367523-1293&#x3D;366239K</span><br><span class="line"></span><br><span class="line">    Heap区总共减少了522739-156516&#x3D;366223K</span><br><span class="line"></span><br><span class="line">    366239 – 366223 &#x3D;17K，说明该次共有17K内存从年轻代移到了老年代，可以看出来数量并不多，说明都是生命周期短的对象，只是这种对象有很多。</span><br><span class="line"></span><br><span class="line">    我们需要的是尽量避免Full GC的发生，让对象尽可能的在年轻代就回收掉，所以这里可以稍微增加一点年轻代的大小，让那17K的数据也保存在年轻代中。</span><br></pre></td></tr></table></figure>

<h1 id="4、统一监控测试"><a href="#4、统一监控测试" class="headerlink" title="4、统一监控测试"></a>4、统一监控测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx512m -server -Xmx512m -server -verbose:gc -XX:+PrintGCDetails -cp om-demo-1.0.0.jar:netty-all-4.0.24.Final.jar:log4j-1.2.14.jar:cat-client-3.0.0.jar com.study.jvm.FullGCDemo1</span><br></pre></td></tr></table></figure>

<h1 id="5、jstack日志分析"><a href="#5、jstack日志分析" class="headerlink" title="5、jstack日志分析"></a>5、jstack日志分析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">线程dump信息说明：</span><br><span class="line">elasticsearch[Native][merge][T#1] 是我们为线程起的名字</span><br><span class="line">daemon 表示线程是否是守护线程</span><br><span class="line">prio 表示我们为线程设置的优先级</span><br><span class="line">os_prio 表示的对应的操作系统线程的优先级，由于并不是所有的操作系统都支持线程优先级，所以可能会出现都置为0的情况</span><br><span class="line">tid 是java中为这个线程的id</span><br><span class="line">nid 是这个线程对应的操作系统本地线程id，每一个java线程都有一个对应的操作系统线程</span><br><span class="line">wait on condition表示当前线程处于等待状态，但是并没列出具体原因</span><br><span class="line">java.lang.Thread.State: WAITING (parking) 也是表示的处于等待状态，括号中的内容说明了导致等待的原因，例如这里的parking说明是因为调用了 LockSupport.park方法导致等待</span><br></pre></td></tr></table></figure>

<h1 id="6、-堆外内存泄漏"><a href="#6、-堆外内存泄漏" class="headerlink" title="6、 堆外内存泄漏"></a>6、 堆外内存泄漏</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;gitbook.cn&#x2F;books&#x2F;5c47c4e291e0c40c7a462f05&#x2F;</span><br><span class="line">https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;cff037edb750</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;gperftools&#x2F;gperftools</span><br><span class="line">下载libunwind</span><br><span class="line">wget http:&#x2F;&#x2F;ftp.twaren.net&#x2F;Unix&#x2F;NonGNU&#x2F;libunwind&#x2F;libunwind-1.1.tar.gz</span><br><span class="line">tar -xvf libunwind-1.1.tar.gz</span><br><span class="line">cd libunwind-1.1</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;tools&#x2F;libunwind&#x2F; CFLAGS&#x3D;-U_FORTRIFY_SOURCE</span><br><span class="line">make</span><br><span class="line">make install </span><br><span class="line"></span><br><span class="line"># 下载 https:&#x2F;&#x2F;github.com&#x2F;gperftools&#x2F;gperftools&#x2F;releases</span><br><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;gperftools&#x2F;gperftools&#x2F;releases&#x2F;download&#x2F;gperftools-2.7&#x2F;gperftools-2.7.tar.gz</span><br><span class="line">tar -xvf gperftools-2.7.tar.gz</span><br><span class="line">cd gperftools-2.7</span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;tools&#x2F;gperftools LDFLAGS&#x3D;-L&#x2F;usr&#x2F;local&#x2F;tools&#x2F;libunwind&#x2F;lib CPPFLAGS&#x3D;-L&#x2F;usr&#x2F;local&#x2F;tools&#x2F;libunwind&#x2F;include</span><br><span class="line">make</span><br><span class="line">make install </span><br><span class="line"></span><br><span class="line"># 使用</span><br><span class="line"># 设定内存申请器</span><br><span class="line">export LD_PRELOAD&#x3D;&#x2F;usr&#x2F;local&#x2F;tools&#x2F;gperftools&#x2F;lib&#x2F;libtcmalloc.so</span><br><span class="line"># 指定内存分析结果存放路径</span><br><span class="line">mkdir &#x2F;tmp&#x2F;gperftool-heap</span><br><span class="line">export HEAPPROFILE&#x3D;&#x2F;tmp&#x2F;gperftool-heap&#x2F;heap</span><br><span class="line"></span><br><span class="line"># 结果分析</span><br><span class="line"> &#x2F;usr&#x2F;local&#x2F;tools&#x2F;gperftools&#x2F;bin&#x2F;pprof --text $JAVA_HOME&#x2F;bin&#x2F;java &#x2F;tmp&#x2F;gperftool-heap&#x2F;heap.0003.heap &gt; report.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 调用链</span><br><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;btraceio&#x2F;btrace&#x2F;releases&#x2F;download&#x2F;v1.3.11.3&#x2F;btrace-bin-1.3.11.3.tgz</span><br><span class="line">mkdir &#x2F;usr&#x2F;local&#x2F;tools&#x2F;btrace-bin-1.3.11.3</span><br><span class="line">mv btrace-bin-1.3.11.3.tgz &#x2F;usr&#x2F;local&#x2F;tools&#x2F;btrace-bin-1.3.11.3&#x2F;btrace-bin-1.3.11.3.tgz</span><br><span class="line">cd  &#x2F;usr&#x2F;local&#x2F;tools&#x2F;btrace-bin-1.3.11.3</span><br><span class="line">tar -xvf btrace-bin-1.3.11.3.tgz</span><br><span class="line">rm -rf btrace-bin-1.3.11.3.tgz</span><br><span class="line"></span><br><span class="line">.&#x2F;btrace -cp &#x2F;usr&#x2F;local&#x2F;tools&#x2F;btrace-bin-1.3.11.3&#x2F;build&#x2F; 6358 &#x2F;tmp&#x2F;test&#x2F;TraceMethodCaller.java </span><br><span class="line">或者 jvisualVM插件Btrace</span><br></pre></td></tr></table></figure>

<p>#</p>

          
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/04/06/redislive/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/06/redislive/" itemprop="url">Redis的安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-04-06T00:00:00+08:00">
                2020-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h1 id="1、-环境需要"><a href="#1、-环境需要" class="headerlink" title="1、 环境需要"></a>1、 环境需要</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">centos7</span><br><span class="line">默认的 python ，应该是2.7.x</span><br></pre></td></tr></table></figure>

<h1 id="2、安装pip"><a href="#2、安装pip" class="headerlink" title="2、安装pip"></a>2、安装pip</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 首先安装epel扩展源：</span><br><span class="line">yum -y install epel-release</span><br><span class="line"># 更新完成之后，就可安装pip：</span><br><span class="line">yum -y install python-pip</span><br><span class="line"># 安装完成之后清除cache：</span><br><span class="line">yum clean all</span><br></pre></td></tr></table></figure>

<h1 id="3、-安装redisLive依赖"><a href="#3、-安装redisLive依赖" class="headerlink" title="3、 安装redisLive依赖"></a>3、 安装redisLive依赖</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># tornado </span><br><span class="line">pip install tornado</span><br><span class="line"># redis.py （此处一定要注意redis.py的版本）</span><br><span class="line">pip install redis&#x3D;&#x3D;2.10.6</span><br><span class="line"># python-dateutil </span><br><span class="line">pip install python-dateutil</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 如果提示你要升级pip，就升级一下</span><br><span class="line">You are using pip version 8.1.2, however version 19.0.2 is available.</span><br><span class="line">You should consider upgrading via the &#39;pip install --upgrade pip&#39; command.</span><br></pre></td></tr></table></figure>

<h1 id="4、下载redisLive"><a href="#4、下载redisLive" class="headerlink" title="4、下载redisLive"></a>4、下载redisLive</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;nkrode&#x2F;RedisLive&#x2F;archive&#x2F;master.zip</span><br><span class="line">mv master.zip redisLive.zip</span><br><span class="line"># 解压</span><br><span class="line">unzip redisLive.zip -d &#x2F;usr&#x2F;local&#x2F;redisLive</span><br><span class="line"># 没有wget这个命令怎么办？百度一下怎么在centos7下面安装wget。</span><br></pre></td></tr></table></figure>
<h1 id="5、-配置"><a href="#5、-配置" class="headerlink" title="5、 配置"></a>5、 配置</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">cd  &#x2F;usr&#x2F;local&#x2F;redisLive&#x2F;RedisLive-master&#x2F;src</span><br><span class="line">cp redis-live.conf.example redis-live.conf</span><br><span class="line"># redis-live.conf配置文件示例内容如下 </span><br><span class="line"># RedisServers 要监控的节点，里面可以配置密码 &quot;password&quot; : &quot;some-password&quot;</span><br><span class="line"># RedisStatsServer redis方式存储监控数据，建议是独立的redis</span><br><span class="line"># 启动redis：&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server --protected-mode no 默认端口6379</span><br><span class="line"># SqliteStatsStore sqlite方式存储监控数据</span><br><span class="line"># &quot;DataStoreType&quot; : &quot;sqlite&quot; 切换监控数据的存储模式</span><br><span class="line">&#123;</span><br><span class="line">        &quot;RedisServers&quot;:</span><br><span class="line">        [ </span><br><span class="line">                &#123;</span><br><span class="line">                        &quot;server&quot;: &quot;192.168.100.242&quot;,</span><br><span class="line">                        &quot;port&quot; :6381</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                        &quot;server&quot;: &quot;192.168.100.242&quot;,</span><br><span class="line">                        &quot;port&quot; : 6382</span><br><span class="line">                &#125;</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">        &quot;DataStoreType&quot; : &quot;redis&quot;,</span><br><span class="line"></span><br><span class="line">        &quot;RedisStatsServer&quot;:</span><br><span class="line">        &#123;</span><br><span class="line">                &quot;server&quot; : &quot;192.168.100.242&quot;,</span><br><span class="line">                &quot;port&quot; :6379</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &quot;SqliteStatsStore&quot; :</span><br><span class="line">        &#123;</span><br><span class="line">                &quot;path&quot;: &quot;to your sql lite file&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5、-运行redisLive"><a href="#5、-运行redisLive" class="headerlink" title="5、 运行redisLive"></a>5、 运行redisLive</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;redisLive&#x2F;RedisLive-master&#x2F;src</span><br><span class="line"></span><br><span class="line"># 运行数据采集</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redisLive&#x2F;RedisLive-master&#x2F;src&#x2F;redis-monitor.py --duration&#x3D;120</span><br><span class="line"># 运行web控制台</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;redisLive&#x2F;RedisLive-master&#x2F;src&#x2F;redis-live.py</span><br><span class="line"># web gui页面</span><br><span class="line">http:&#x2F;&#x2F;192.168.100.242:8888&#x2F;index.html</span><br></pre></td></tr></table></figure>

<h1 id="6、运行时可能的异常"><a href="#6、运行时可能的异常" class="headerlink" title="6、运行时可能的异常"></a>6、运行时可能的异常</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># ImportError: No module named _sqlite3</span><br><span class="line">解决办法：</span><br></pre></td></tr></table></figure>

<h1 id="7、如果安装慢也可以参考该安装文档"><a href="#7、如果安装慢也可以参考该安装文档" class="headerlink" title="7、如果安装慢也可以参考该安装文档"></a>7、如果安装慢也可以参考该安装文档</h1><p><a href="https://blog.csdn.net/lihao21/article/details/72811455" target="_blank" rel="noopener">https://blog.csdn.net/lihao21/article/details/72811455</a></p>

          
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/03/31/Docker%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/31/Docker%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url">Docker简介及基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-31T00:00:00+08:00">
                2020-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-Docker-简介"><a href="#1-Docker-简介" class="headerlink" title="1. Docker 简介"></a>1. Docker 简介</h1><h2 id="1-1-docker-是什么"><a href="#1-1-docker-是什么" class="headerlink" title="1.1.   docker 是什么"></a>1.1.   docker 是什么</h2><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 <a href="https://github.com/moby/moby" target="_blank" rel="noopener">GitHub</a> 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 <a href="https://www.opencontainers.org/" target="_blank" rel="noopener">开放容器联盟（OCI）</a>。</p>
<p>Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 4 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。</p>
<p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。</p>
<p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p>
<p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134707.gif" alt="传统虚拟化"></p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134711.gif" alt="Docker"></p>
<h2 id="1-2-为什么要使用-docker"><a href="#1-2-为什么要使用-docker" class="headerlink" title="1.2.   为什么要使用 docker"></a>1.2.   为什么要使用 docker</h2><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p>
<p><strong>更高效的利用系统资源</strong></p>
<p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>
<p><strong>更快速的启动时间</strong></p>
<p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>
<p><strong>一致的运行环境</strong></p>
<p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p>
<p><strong>持续交付和部署</strong></p>
<p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p>
<p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。</p>
<p>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>
<p><strong>更轻松的迁移</strong></p>
<p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>
<p><strong>更轻松的维护和扩展</strong></p>
<p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>
<p><strong>对比传统虚拟机总结</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>容器</strong></th>
<th><strong>虚拟机</strong></th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>一般为 MB</td>
<td>一般为 GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
</tbody></table>
<h1 id="2-docker-基本概念"><a href="#2-docker-基本概念" class="headerlink" title="2. docker 基本概念"></a>2. docker 基本概念</h1><p>Docker 包括三个基本概念</p>
<p>l 镜像（Image）</p>
<p>l 容器（Container）</p>
<p>l 仓库（Repository）</p>
<p>理解了这三个概念，就理解了 Docker 的整个生命周期。</p>
<h2 id="2-1-docker-引擎"><a href="#2-1-docker-引擎" class="headerlink" title="2.1.   docker 引擎"></a>2.1.   docker 引擎</h2><p>Docker 引擎是一个包含以下主要组件的客户端服务器应用程序。</p>
<p>l 一种服务器，它是一种称为守护进程并且长时间运行的程序。</p>
<p>l REST API用于指定程序可以用来与守护进程通信的接口，并指示它做什么。</p>
<p>l 一个有命令行界面 (CLI) 工具的客户端。</p>
<p>Docker 引擎组件的流程如下图所示：</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134719.jpg" alt="https://www.funtl.com/assets/620140640_31678.png"></p>
<h2 id="2-2-docker-系统架构"><a href="#2-2-docker-系统架构" class="headerlink" title="2.2.   docker 系统架构"></a>2.2.   docker 系统架构</h2><p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程 API 来管理和创建 Docker 容器。</p>
<p>Docker 容器通过 Docker 镜像来创建。</p>
<p>容器与镜像的关系类似于面向对象编程中的对象与类。</p>
<table>
<thead>
<tr>
<th><strong>Docker</strong></th>
<th><strong>面向对象</strong></th>
</tr>
</thead>
<tbody><tr>
<td>容器</td>
<td>对象</td>
</tr>
<tr>
<td>镜像</td>
<td>类</td>
</tr>
</tbody></table>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134729.jpg" alt="https://www.funtl.com/assets/262150629_86976.png"></p>
<table>
<thead>
<tr>
<th><strong>标题</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>镜像(Images)</td>
<td>Docker 镜像是用于创建 Docker 容器的模板。</td>
</tr>
<tr>
<td>容器(Container)</td>
<td>容器是独立运行的一个或一组应用。</td>
</tr>
<tr>
<td>客户端(Client)</td>
<td>Docker 客户端通过命令行或者其他工具使用 Docker API (<a href="https://docs.docker.com/reference/api/docker_remote_api" target="_blank" rel="noopener">https://docs.docker.com/reference/api/docker_remote_api</a>)  与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td>主机(Host)</td>
<td>一个物理或者虚拟的机器用于执行  Docker 守护进程和容器。</td>
</tr>
<tr>
<td>仓库(Registry)</td>
<td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。</td>
</tr>
<tr>
<td>Docker Machine</td>
<td>Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td>
</tr>
</tbody></table>
<h2 id="2-3-docker-镜像"><a href="#2-3-docker-镜像" class="headerlink" title="2.3.   docker 镜像"></a>2.3.   docker 镜像</h2><p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu 16.04 最小系统的 root 文件系统。</p>
<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p><strong>分层存储</strong></p>
<p>因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<p>关于镜像构建，将会在后续相关章节中做进一步的讲解。</p>
<h2 id="2-4-docker-容器"><a href="#2-4-docker-容器" class="headerlink" title="2.4.   docker 容器"></a>2.4.   docker 容器</h2><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p>
<p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<h2 id="2-5-docker-仓库"><a href="#2-5-docker-仓库" class="headerlink" title="2.5.   docker 仓库"></a>2.5.   docker 仓库</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p>
<p>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p>
<p>以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，14.04, 16.04。我们可以通过 ubuntu:14.04，或者 ubuntu:16.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。</p>
<p>仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>
<h3 id="2-5-1-公有-Docker-Registry"><a href="#2-5-1-公有-Docker-Registry" class="headerlink" title="2.5.1. 公有 Docker Registry"></a>2.5.1. 公有 Docker Registry</h3><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 <a href="https://coreos.com/" target="_blank" rel="noopener">CoreOS </a>的 <a href="https://quay.io/repository/" target="_blank" rel="noopener">Quay.io</a>，CoreOS 相关的镜像存储在这里；Google 的 <a href="https://cloud.google.com/container-registry/" target="_blank" rel="noopener">Google Container Registry</a>，Kubernetes 的镜像使用的就是这个服务。</p>
<p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为加速器。常见的有 <a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云加速器</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a> 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。</p>
<p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://hub.tenxcloud.com/" target="_blank" rel="noopener">时速云镜像仓库</a>、<a href="https://c.163.com/hub#/m/library/" target="_blank" rel="noopener">网易云镜像服务</a>、<a href="https://hub.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场</a>、<a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">阿里云镜像库</a> 等。</p>
<h3 id="2-5-2-私有-Docker-Registry"><a href="#2-5-2-私有-Docker-Registry" class="headerlink" title="2.5.2. 私有 Docker Registry"></a>2.5.2. 私有 Docker Registry</h3><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://store.docker.com/images/registry/" target="_blank" rel="noopener">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。</p>
<p>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/" target="_blank" rel="noopener">Docker Registry API</a> 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 <a href="https://docs.docker.com/datacenter/dtr/2.0/" target="_blank" rel="noopener">Docker Trusted Registry</a> 中，提供了这些高级功能。</p>
<p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<a href="https://github.com/vmware/harbor" target="_blank" rel="noopener">VMWare Harbor</a> 和 <a href="https://www.sonatype.com/docker" target="_blank" rel="noopener">Sonatype Nexus</a>。</p>
<h1 id="3-docker-安装"><a href="#3-docker-安装" class="headerlink" title="3. docker 安装"></a>3. docker 安装</h1><p>Docker 在 1.13 版本之后，从 2017 年的 3 月 1 日开始，版本命名规则变为如下：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>版本格式</td>
<td>YY.MM</td>
</tr>
<tr>
<td>Stable 版本</td>
<td>每个季度发行</td>
</tr>
<tr>
<td>Edge 版本</td>
<td>每个月发行</td>
</tr>
</tbody></table>
<p>同时 Docker 划分为 CE 和 EE。CE 即社区版（免费，支持周期三个月），EE 即企业版，强调安全，付费使用。</p>
<p>Docker CE 每月发布一个 Edge 版本 (17.03, 17.04, 17.05…)，每三个月发布一个 Stable 版本 (17.03, 17.06, 17.09…)，Docker EE 和 Stable 版本号保持一致，但每个版本提供一年维护。</p>
<p>官方网站上有各种环境下的 <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">安装指南</a>，这里主要介绍 Docker CE 在 Linux 、Windows 10 (PC) 和 macOS 上的安装。</p>
<h2 id="3-1-ubuntu-安装docker"><a href="#3-1-ubuntu-安装docker" class="headerlink" title="3.1.   ubuntu 安装docker"></a>3.1.   ubuntu 安装docker</h2><p>警告：切勿在没有配置 Docker APT 源的情况下直接使用 apt 命令安装 Docker.</p>
<h3 id="3-1-1-准备工作"><a href="#3-1-1-准备工作" class="headerlink" title="3.1.1. 准备工作"></a><strong>3.1.1.</strong> <strong>准备工作</strong></h3><p><strong>1**</strong>、系统要求**</p>
<p>Docker CE 支持以下版本的 Ubuntu 操作系统：</p>
<p>l Artful 17.10 (Docker CE 17.11 Edge +)</p>
<p>l Xenial 16.04 (LTS)</p>
<p>l Trusty 14.04 (LTS)</p>
<p>Docker CE 可以安装在 64 位的 x86 平台或 ARM 平台上。Ubuntu 发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5 年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS 版本,当前最新的 LTS 版本为 Ubuntu 16.04。</p>
<p><strong>2**</strong>、卸载旧版本**</p>
<p>旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：</p>
<p>sudo apt-get remove docker docker-engine docker.io</p>
<p><strong>3**</strong>、Ubuntu 14.04 可选内核模块**</p>
<p>从 Ubuntu 14.04 开始，一部分内核模块移到了可选内核模块包 (linux-image-extra-*) ，以减少内核软件包的体积。正常安装的系统应该会包含可选内核模块包，而一些裁剪后的系统可能会将其精简掉。AUFS 内核驱动属于可选内核模块的一部分，作为推荐的 Docker 存储层驱动，一般建议安装可选内核模块包以使用 AUFS。</p>
<p>如果系统没有安装可选内核模块的话，可以执行下面的命令来安装可选内核模块包：</p>
<p>sudo apt-get update</p>
<p>sudo apt-get install linux-image-extra-$(uname -r) linux-image-extra-virtual</p>
<p><strong>4**</strong>、Ubuntu 16.04 +**</p>
<p>Ubuntu 16.04 + 上的 Docker CE 默认使用 overlay2 存储层驱动,无需手动配置。</p>
<h3 id="3-1-2-使用-APT-安装"><a href="#3-1-2-使用-APT-安装" class="headerlink" title="3.1.2. 使用 APT 安装"></a><strong>3.1.2.</strong> <strong>使用 APT 安装</strong></h3><p>安装必要的一些系统工具</p>
<p>sudo apt-get update</p>
<p>sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</p>
<p>安装 GPG 证书</p>
<p>curl -fsSL <a href="http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg" target="_blank" rel="noopener">http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg</a> | sudo apt-key add -</p>
<p>写入软件源信息</p>
<p>sudo add-apt-repository “deb [arch=amd64] <a href="http://mirrors.aliyun.com/docker-ce/linux/ubuntu" target="_blank" rel="noopener">http://mirrors.aliyun.com/docker-ce/linux/ubuntu</a> $(lsb_release -cs) stable”</p>
<p>更新并安装 Docker CE</p>
<p>sudo apt-get -y update</p>
<p>sudo apt-get -y install docker-ce</p>
<p>以上命令会添加稳定版本的 Docker CE APT 镜像源，如果需要最新或者测试版本的 Docker CE 请将 stable 改为 edge 或者 test。从 Docker 17.06 开始，edge test 版本的 APT 镜像源也会包含稳定版本的 Docker。</p>
<h3 id="3-1-3-使用脚本自动安装"><a href="#3-1-3-使用脚本自动安装" class="headerlink" title="3.1.3. 使用脚本自动安装"></a><strong>3.1.3.</strong> <strong>使用脚本自动安装</strong></h3><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装：</p>
<p>curl -fsSL get.docker.com -o get-docker.sh</p>
<p># 可能会出现 404 错误，请移步下面的特别说明</p>
<p>sudo sh get-docker.sh –mirror Aliyun</p>
<p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。</p>
<p><strong>特别说明</strong></p>
<p>2018 年 7 月 21 日，貌似阿里云这边在做调整，故导致 Docker 的 Aliyun 安装脚本不可用，是永久性还是临时性的尚不清除，如果你已经按照之前的操作安装 Docker，请按以下步骤进行修复并重新安装</p>
<p>l 如果已经使用了 Aliyun 脚本安装并成功的</p>
<p>ü 请先卸载 Docker，命令为：apt-get autoremove docker-ce</p>
<p>ü 删除 /etc/apt/sources.list.d 目录下的 docker.list 文件</p>
<p>l 使用 AzureChinaCloud 镜像脚本重新安装，命令为：sudo sh get-docker.sh –mirror AzureChinaCloud</p>
<h3 id="3-1-4-启动-Docker-CE"><a href="#3-1-4-启动-Docker-CE" class="headerlink" title="3.1.4. 启动 Docker CE"></a>3.1.4. 启动 Docker CE</h3><p>sudo systemctl enable docker</p>
<p>sudo systemctl start docker</p>
<p>Ubuntu 14.04 请使用以下命令启动：</p>
<p>sudo service docker start</p>
<h3 id="3-1-5-建立-docker-用户组"><a href="#3-1-5-建立-docker-用户组" class="headerlink" title="3.1.5. 建立 docker 用户组"></a>3.1.5. 建立 docker 用户组</h3><p>默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。</p>
<p>建立 docker 组：</p>
<p>sudo groupadd docker</p>
<p>将当前用户加入 docker 组：</p>
<p>sudo usermod -aG docker $USER</p>
<p>退出当前终端并重新登录，进行如下测试。</p>
<h3 id="3-1-6-测试-Docker-是否安装正确"><a href="#3-1-6-测试-Docker-是否安装正确" class="headerlink" title="3.1.6. 测试 Docker 是否安装正确"></a>3.1.6. 测试 Docker 是否安装正确</h3><p>docker run hello-world</p>
<p>Unable to find image ‘hello-world:latest’ locally</p>
<p>latest: Pulling from library/hello-world</p>
<p>ca4f61b1923c: Pull complete</p>
<p>Digest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905c</p>
<p>Status: Downloaded newer image for hello-world:latest</p>
<p>Hello from Docker!</p>
<p>This message shows that your installation appears to be working correctly.</p>
<p>To generate this message, Docker took the following steps:</p>
<p> \1. The Docker client contacted the Docker daemon.</p>
<p> \2. The Docker daemon pulled the “hello-world” image from the Docker Hub.</p>
<p>  (amd64)</p>
<p> \3. The Docker daemon created a new container from that image which runs the</p>
<p>  executable that produces the output you are currently reading.</p>
<p> \4. The Docker daemon streamed that output to the Docker client, which sent it</p>
<p>  to your terminal.</p>
<p>To try something more ambitious, you can run an Ubuntu container with:</p>
<p> $ docker run -it ubuntu bash</p>
<p>Share images, automate workflows, and more with a free Docker ID:</p>
<p> <a href="https://cloud.docker.com/" target="_blank" rel="noopener">https://cloud.docker.com/</a></p>
<p>For more examples and ideas, visit:</p>
<p> <a href="https://docs.docker.com/engine/userguide/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/</a></p>
<p>若能正常输出以上信息，则说明安装成功。</p>
<h3 id="3-1-7-镜像加速"><a href="#3-1-7-镜像加速" class="headerlink" title="3.1.7. 镜像加速"></a>3.1.7. 镜像加速</h3><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，强烈建议安装 Docker 之后配置 国内镜像加速。</p>
<h3 id="3-1-8-参考文档"><a href="#3-1-8-参考文档" class="headerlink" title="3.1.8. 参考文档"></a>3.1.8. 参考文档</h3><p><a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">Docker 官方 Ubuntu 安装文档</a></p>
<h2 id="3-2-centOS-安装-docker"><a href="#3-2-centOS-安装-docker" class="headerlink" title="3.2.   centOS 安装 docker"></a>3.2.   centOS 安装 docker</h2><p>警告：切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker.</p>
<h3 id="3-2-1-准备工作"><a href="#3-2-1-准备工作" class="headerlink" title="3.2.1. 准备工作"></a>3.2.1. 准备工作</h3><p><strong>1**</strong>、系统要求**</p>
<p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。</p>
<p><strong>2**</strong>、卸载旧版本**</p>
<p>旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：</p>
<p>sudo yum remove docker \</p>
<p>​         docker-client \</p>
<p>​         docker-client-latest \</p>
<p>​         docker-common \</p>
<p>​         docker-latest \</p>
<p>​         docker-latest-logrotate \</p>
<p>​         docker-logrotate \</p>
<p>​         docker-selinux \</p>
<p>​         docker-engine-selinux \</p>
<p>​         docker-engine</p>
<h3 id="3-2-2-使用-yum-安装"><a href="#3-2-2-使用-yum-安装" class="headerlink" title="3.2.2. 使用 yum 安装"></a>3.2.2. 使用 yum 安装</h3><p>执行以下命令安装依赖包：</p>
<p>sudo yum install -y yum-utils \</p>
<p>​      device-mapper-persistent-data \</p>
<p>​      lvm2</p>
<p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。</p>
<p>执行下面的命令添加 yum 软件源：</p>
<p>sudo yum-config-manager \</p>
<p>  –add-repo \</p>
<p>  <a href="https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</a></p>
<p># 官方源</p>
<p># sudo yum-config-manager \</p>
<p>#  –add-repo \</p>
<p>#  <a href="https://download.docker.com/linux/centos/docker-ce.repo" target="_blank" rel="noopener">https://download.docker.com/linux/centos/docker-ce.repo</a></p>
<p>如果需要最新版本的 Docker CE 请使用以下命令：</p>
<p>sudo yum-config-manager –enable docker-ce-edge</p>
<p>如果需要测试版本的 Docker CE 请使用以下命令：</p>
<p>sudo yum-config-manager –enable docker-ce-test</p>
<p><strong>安装 Docker CE</strong></p>
<p>更新 yum 软件源缓存，并安装 docker-ce。</p>
<p>sudo yum makecache fast</p>
<p>sudo yum install docker-ce</p>
<h3 id="3-2-3-使用脚本自动安装"><a href="#3-2-3-使用脚本自动安装" class="headerlink" title="3.2.3. 使用脚本自动安装"></a>3.2.3. 使用脚本自动安装</h3><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装：</p>
<p>curl -fsSL get.docker.com -o get-docker.sh</p>
<p>sudo sh get-docker.sh –mirror Aliyun</p>
<p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。</p>
<h3 id="3-2-4-启动-Docker-CE"><a href="#3-2-4-启动-Docker-CE" class="headerlink" title="3.2.4. 启动 Docker CE"></a>3.2.4. 启动 Docker CE</h3><p>sudo systemctl enable docker</p>
<p>sudo systemctl start docker</p>
<h3 id="3-2-5-建立-docker-用户组"><a href="#3-2-5-建立-docker-用户组" class="headerlink" title="3.2.5. 建立 docker 用户组"></a>3.2.5. 建立 docker 用户组</h3><p>默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。</p>
<p>建立 docker 组：</p>
<p>sudo groupadd docker</p>
<p>将当前用户加入 docker 组：</p>
<p>sudo usermod -aG docker $USER</p>
<p>退出当前终端并重新登录，进行如下测试。</p>
<h3 id="3-2-6-测试-Docker-是否安装正确"><a href="#3-2-6-测试-Docker-是否安装正确" class="headerlink" title="3.2.6. 测试 Docker 是否安装正确"></a>3.2.6. 测试 Docker 是否安装正确</h3><p>docker run hello-world</p>
<p>Unable to find image ‘hello-world:latest’ locally</p>
<p>latest: Pulling from library/hello-world</p>
<p>ca4f61b1923c: Pull complete</p>
<p>Digest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905c</p>
<p>Status: Downloaded newer image for hello-world:latest</p>
<p>Hello from Docker!</p>
<p>This message shows that your installation appears to be working correctly.</p>
<p>To generate this message, Docker took the following steps:</p>
<p> \1. The Docker client contacted the Docker daemon.</p>
<p> \2. The Docker daemon pulled the “hello-world” image from the Docker Hub.</p>
<p>  (amd64)</p>
<p> \3. The Docker daemon created a new container from that image which runs the</p>
<p>  executable that produces the output you are currently reading.</p>
<p> \4. The Docker daemon streamed that output to the Docker client, which sent it</p>
<p>  to your terminal.</p>
<p>To try something more ambitious, you can run an Ubuntu container with:</p>
<p> $ docker run -it ubuntu bash</p>
<p>Share images, automate workflows, and more with a free Docker ID:</p>
<p> <a href="https://cloud.docker.com/" target="_blank" rel="noopener">https://cloud.docker.com/</a></p>
<p>For more examples and ideas, visit:</p>
<p> <a href="https://docs.docker.com/engine/userguide/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/</a></p>
<p>若能正常输出以上信息，则说明安装成功。</p>
<h3 id="3-2-7-镜像加速"><a href="#3-2-7-镜像加速" class="headerlink" title="3.2.7. 镜像加速"></a>3.2.7. 镜像加速</h3><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，强烈建议安装 Docker 之后配置 国内镜像加速。</p>
<h3 id="3-2-8-添加内核参数"><a href="#3-2-8-添加内核参数" class="headerlink" title="3.2.8. 添加内核参数"></a>3.2.8. 添加内核参数</h3><p>默认配置下，如果在 CentOS 使用 Docker CE 看到下面的这些警告信息：</p>
<p>WARNING: bridge-nf-call-iptables is disabled</p>
<p>WARNING: bridge-nf-call-ip6tables is disabled</p>
<p>请添加内核配置参数以启用这些功能。</p>
<p>sudo tee -a /etc/sysctl.conf &lt;&lt;-EOF</p>
<p>net.bridge.bridge-nf-call-ip6tables = 1</p>
<p>net.bridge.bridge-nf-call-iptables = 1</p>
<p>EOF</p>
<p>然后重新加载 sysctl.conf 即可</p>
<p>sudo sysctl -p</p>
<h3 id="3-2-9-参考文档"><a href="#3-2-9-参考文档" class="headerlink" title="3.2.9. 参考文档"></a>3.2.9. 参考文档</h3><p><a href="https://docs.docker.com/engine/installation/linux/docker-ce/centos/" target="_blank" rel="noopener">Docker 官方 CentOS 安装文档</a>。</p>
<h2 id="3-3-mac-安装-docker"><a href="#3-3-mac-安装-docker" class="headerlink" title="3.3.   mac 安装 docker"></a>3.3.   mac 安装 docker</h2><h3 id="3-3-1-系统要求"><a href="#3-3-1-系统要求" class="headerlink" title="3.3.1. 系统要求"></a>3.3.1. 系统要求</h3><p><a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">Docker for Mac</a> 要求系统最低为 macOS 10.10.3 Yosemite。如果系统不满足需求，可以安装 <a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="noopener">Docker Toolbox</a>。</p>
<h3 id="3-3-2-安装"><a href="#3-3-2-安装" class="headerlink" title="3.3.2. 安装"></a>3.3.2. 安装</h3><p><strong>1**</strong>、使用 Homebrew 安装**</p>
<p>Homebrew 的 Cask 已经支持 Docker for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装：</p>
<p>brew cask install docker</p>
<p><strong>2**</strong>、手动下载安装**</p>
<p>如果需要手动下载，请点击以下链接下载 Stable 或 Edge 版本的 Docker for Mac。</p>
<p>如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将那只叫 Moby 的鲸鱼图标拖拽到 Application 文件夹即可（其间需要输入用户密码）。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134748.gif" alt="https://www.funtl.com/assets/install-mac-dmg.png"></p>
<h3 id="3-3-3-运行"><a href="#3-3-3-运行" class="headerlink" title="3.3.3. 运行"></a>3.3.3. 运行</h3><p>从应用中找到 Docker 图标并点击运行。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134756.gif" alt="https://www.funtl.com/assets/install-mac-apps.png"></p>
<p>运行之后，会在右上角菜单栏看到多了一个鲸鱼图标，这个图标表明了 Docker 的运行状态。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134801.gif" alt="https://www.funtl.com/assets/install-mac-menubar.png"></p>
<p>第一次点击图标，可能会看到这个安装成功的界面，点击 “Got it!” 可以关闭这个窗口。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134804.gif" alt="https://www.funtl.com/assets/install-mac-success.png"></p>
<p>以后每次点击鲸鱼图标会弹出操作菜单。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134807.gif" alt="https://www.funtl.com/assets/install-mac-menu.png"></p>
<p>启动终端后，通过命令可以检查安装后的 Docker 版本。</p>
<p>docker –version</p>
<p>docker-compose –version</p>
<p>docker-machine –version</p>
<p>如果 docker version、docker info 都正常的话，可以尝试运行一个 Nginx 服务器：</p>
<p>docker run -d -p 80:80 –name webserver nginx</p>
<p>服务运行后，可以访问 <a href="http://localhost，如果看到了" target="_blank" rel="noopener">http://localhost，如果看到了</a> “Welcome to nginx!”，就说明 Docker for Mac 安装成功了。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134811.gif" alt="https://www.funtl.com/assets/install-mac-example-nginx.png"></p>
<p>要停止 Nginx 服务器并删除执行下面的命令：</p>
<p>docker stop webserver</p>
<p>docker rm webserver</p>
<h3 id="3-3-4-镜像加速"><a href="#3-3-4-镜像加速" class="headerlink" title="3.3.4. 镜像加速"></a>3.3.4. 镜像加速</h3><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，强烈建议安装 Docker 之后配置 国内镜像加速。</p>
<h2 id="3-4-windos-安装-docker"><a href="#3-4-windos-安装-docker" class="headerlink" title="3.4.   windos 安装 docker"></a>3.4.   windos 安装 docker</h2><h3 id="3-4-1-系统要求"><a href="#3-4-1-系统要求" class="headerlink" title="3.4.1. 系统要求"></a>3.4.1. 系统要求</h3><p><a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">Docker for Windows</a> 支持 64 位版本的 Windows 10 Pro，且必须开启 Hyper-V。</p>
<h3 id="3-4-2-安装"><a href="#3-4-2-安装" class="headerlink" title="3.4.2. 安装"></a>3.4.2. 安装</h3><p>点击以下链接下载 Stable 或 Edge 版本的 Docker for Windows。</p>
<p>下载好之后双击 Docker for Windows Installer.exe 开始安装。</p>
<h3 id="3-4-3-运行"><a href="#3-4-3-运行" class="headerlink" title="3.4.3. 运行"></a>3.4.3. 运行</h3><p>在 Windows 搜索栏输入 Docker 点击 Docker for Windows 开始运行。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134815.gif" alt="https://www.funtl.com/assets/install-win-docker-app-search.png"></p>
<p>Docker CE 启动之后会在 Windows 任务栏出现鲸鱼图标。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134818.gif" alt="https://www.funtl.com/assets/install-win-taskbar-circle.png"></p>
<p>等待片刻，点击 Got it 开始使用 Docker CE。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134821.gif" alt="https://www.funtl.com/assets/install-win-success-popup-cloud.png"></p>
<h3 id="3-4-4-镜像加速"><a href="#3-4-4-镜像加速" class="headerlink" title="3.4.4. 镜像加速"></a>3.4.4. 镜像加速</h3><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，强烈建议安装 Docker 之后配置 国内镜像加速。</p>
<h2 id="3-5-镜像加速"><a href="#3-5-镜像加速" class="headerlink" title="3.5.   镜像加速"></a>3.5.   镜像加速</h2><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：</p>
<p>l Docker 官方提供的中国 registry mirror</p>
<p>l 阿里云加速器</p>
<p>l DaoCloud 加速器</p>
<p>我们以 Docker 官方加速器为例进行介绍。</p>
<h3 id="3-5-1-Ubuntu-14-04、Debian-7-Wheezy"><a href="#3-5-1-Ubuntu-14-04、Debian-7-Wheezy" class="headerlink" title="3.5.1. Ubuntu 14.04、Debian 7 Wheezy"></a>3.5.1. Ubuntu 14.04、Debian 7 Wheezy</h3><p>对于使用 upstart 的系统而言，编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS 中配置加速器地址：</p>
<p>DOCKER_OPTS=”–registry-mirror=<a href="https://registry.docker-cn.com&quot;" target="_blank" rel="noopener">https://registry.docker-cn.com&quot;</a></p>
<p>重新启动服务。</p>
<p>sudo service docker restart</p>
<h3 id="3-5-2-Ubuntu-16-04-、Debian-8-、CentOS-7"><a href="#3-5-2-Ubuntu-16-04-、Debian-8-、CentOS-7" class="headerlink" title="3.5.2. Ubuntu 16.04+、Debian 8+、CentOS 7"></a>3.5.2. Ubuntu 16.04+、Debian 8+、CentOS 7</h3><p>对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）</p>
<p>{</p>
<p> “registry-mirrors”: [</p>
<p>  “<a href="https://registry.docker-cn.com&quot;" target="_blank" rel="noopener">https://registry.docker-cn.com&quot;</a></p>
<p> ]</p>
<p>}</p>
<p>注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。</p>
<p>之后重新启动服务。</p>
<p>sudo systemctl daemon-reload</p>
<p>sudo systemctl restart docker</p>
<p>注意：如果您之前查看旧教程，修改了 docker.service 文件内容，请去掉您添加的内容（–registry-mirror=<a href="https://registry.docker-cn.com），这里不再赘述。" target="_blank" rel="noopener">https://registry.docker-cn.com），这里不再赘述。</a></p>
<h3 id="3-5-3-Windows-10"><a href="#3-5-3-Windows-10" class="headerlink" title="3.5.3. Windows 10"></a>3.5.3. Windows 10</h3><p>对于使用 Windows 10 的系统，在系统右下角托盘 Docker 图标内右键菜单选择 Settings，打开配置窗口后左侧导航菜单选择 Daemon。在 Registry mirrors 一栏中填写加速器地址 <a href="https://registry.docker-cn.com，之后点击" target="_blank" rel="noopener">https://registry.docker-cn.com，之后点击</a> Apply 保存后 Docker 就会重启并应用配置的镜像地址了。</p>
<h3 id="3-5-4-macOS"><a href="#3-5-4-macOS" class="headerlink" title="3.5.4. macOS"></a>3.5.4. macOS</h3><p>对于使用 macOS 的用户，在任务栏点击 Docker for mac 应用图标 -&gt; Perferences… -&gt; Daemon -&gt; Registry mirrors。在列表中填写加速器地址 <a href="https://registry.docker-cn.com。修改完成之后，点击" target="_blank" rel="noopener">https://registry.docker-cn.com。修改完成之后，点击</a> Apply &amp; Restart 按钮，Docker 就会重启并应用配置的镜像地址了。</p>
<h3 id="3-5-5-检查加速器是否生效"><a href="#3-5-5-检查加速器是否生效" class="headerlink" title="3.5.5. 检查加速器是否生效"></a>3.5.5. 检查加速器是否生效</h3><p>配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行 docker info，如果从结果中看到了如下内容，说明配置成功。</p>
<p>Registry Mirrors:</p>
<p> <a href="https://registry.docker-cn.com/" target="_blank" rel="noopener">https://registry.docker-cn.com/</a></p>
<h1 id="4-docker-镜像"><a href="#4-docker-镜像" class="headerlink" title="4. docker 镜像"></a>4. docker 镜像</h1><p>在之前的介绍中，我们知道镜像是 Docker 的三大组件之一。</p>
<p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p>
<p>本章将介绍更多关于镜像的内容，包括：</p>
<p>l 从仓库获取镜像；</p>
<p>l 管理本地主机上的镜像；</p>
<p>l 介绍镜像实现的基本原理。</p>
<h2 id="4-1-Docker-获取镜像"><a href="#4-1-Docker-获取镜像" class="headerlink" title="4.1.   Docker 获取镜像"></a>4.1.   Docker 获取镜像</h2><p>之前提到过，Docker Hub 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p>
<p>从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：</p>
<p>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</p>
<p>具体的选项可以通过 docker pull –help 命令看到，这里我们说一下镜像名称的格式。</p>
<p>l Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。</p>
<p>l 仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。</p>
<p>比如：</p>
<p>docker pull ubuntu:16.04</p>
<p>16.04: Pulling from library/ubuntu</p>
<p>bf5d46315322: Pull complete</p>
<p>9f13e0ac480c: Pull complete</p>
<p>e8988b5b3097: Pull complete</p>
<p>40af181810e7: Pull complete</p>
<p>e6f7c7e5c03e: Pull complete</p>
<p>Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe</p>
<p>Status: Downloaded newer image for ubuntu:16.04</p>
<p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 ubuntu:16.04，因此将会获取官方镜像 library/ubuntu 仓库中标签为 16.04 的镜像。</p>
<p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载一致性。</p>
<p>在使用上面命令的时候，你可能会发现，你所看到的层 ID 以及 sha256 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p>
<p>如果从 Docker Hub 下载镜像非常缓慢，可以参照 镜像加速器 一节配置加速器。</p>
<h3 id="4-1-1-运行"><a href="#4-1-1-运行" class="headerlink" title="4.1.1. 运行"></a>4.1.1. 运行</h3><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 ubuntu:16.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。</p>
<p>docker run -it –rm \</p>
<p>  ubuntu:16.04 \</p>
<p>  bash</p>
<p>root@e7009c6ce357:/# cat /etc/os-release</p>
<p>NAME=”Ubuntu”</p>
<p>VERSION=”16.04.4 LTS, Trusty Tahr”</p>
<p>ID=ubuntu</p>
<p>ID_LIKE=debian</p>
<p>PRETTY_NAME=”Ubuntu 16.04.4 LTS”</p>
<p>VERSION_ID=”16.04”</p>
<p>HOME_URL=”<a href="http://www.ubuntu.com/&quot;" target="_blank" rel="noopener">http://www.ubuntu.com/&quot;</a></p>
<p>SUPPORT_URL=”<a href="http://help.ubuntu.com/&quot;" target="_blank" rel="noopener">http://help.ubuntu.com/&quot;</a></p>
<p>BUG_REPORT_URL=”<a href="http://bugs.launchpad.net/ubuntu/&quot;" target="_blank" rel="noopener">http://bugs.launchpad.net/ubuntu/&quot;</a></p>
<p>docker run 就是运行容器的命令，我们这里简要的说明一下上面用到的参数。</p>
<p>l -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。</p>
<p>l –rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。</p>
<p>l ubuntu:16.04：这是指用 ubuntu:16.04 镜像为基础来启动容器。</p>
<p>l bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。</p>
<p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 16.04.4 LTS 系统。</p>
<p>最后我们通过 exit 退出了这个容器。</p>
<h2 id="4-2-docker-列出镜像"><a href="#4-2-docker-列出镜像" class="headerlink" title="4.2.   docker 列出镜像"></a>4.2.   docker 列出镜像</h2><p>Docker 列出镜像</p>
<p>要想列出已经下载下来的镜像，可以使用 docker image ls 命令。</p>
<p>docker image ls</p>
<p>REPOSITORY      TAG         IMAGE ID      CREATED       SIZE</p>
<p>redis        latest       5f515359c7f8    5 days ago     183 MB</p>
<p>nginx        latest       05a60462f8ba     5 days ago     181 MB</p>
<p>mongo        3.2         fe9198c04d62    5 days ago     342 MB</p>
<p><none>        <none>       00285df0df87    5 days ago     342 MB</p>
<p>ubuntu        16.04        f753707788c5    4 weeks ago     127 MB</p>
<p>ubuntu        latest       f753707788c5    4 weeks ago     127 MB</p>
<p>ubuntu        14.04        1e0c3dd64ccd    4 weeks ago     188 MB</p>
<p>列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。</p>
<p>其中仓库名、标签在之前的基础概念章节已经介绍过了。镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个标签。因此，在上面的例子中，我们可以看到 ubuntu:16.04 和 ubuntu:latest 拥有相同的 ID，因为它们对应的是同一个镜像。</p>
<h3 id="4-2-1-镜像体积"><a href="#4-2-1-镜像体积" class="headerlink" title="4.2.1. 镜像体积"></a>4.2.1. 镜像体积</h3><p>如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，ubuntu:16.04 镜像大小，在这里是 127 MB，但是在 Docker Hub 显示的却是 50 MB。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 docker image ls 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p>
<p>另外一个需要注意的问题是，docker image ls 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p>
<p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p>
<p>docker system df</p>
<p>TYPE        TOTAL        ACTIVE       SIZE        RECLAIMABLE</p>
<p>Images       24         0          1.992GB       1.992GB (100%)</p>
<p>Containers     1          0          62.82MB       62.82MB (100%)</p>
<p>Local Volumes    9          0          652.2MB       652.2MB (100%)</p>
<p>Build Cache                         0B         0B</p>
<h3 id="4-2-2-虚悬镜像"><a href="#4-2-2-虚悬镜像" class="headerlink" title="4.2.2. 虚悬镜像"></a>4.2.2. 虚悬镜像</h3><p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <none>。：</p>
<p><none>        <none>       00285df0df87    5 days ago      342 MB</p>
<p>这个镜像原本是有镜像名和标签的，原来为 mongo:3.2，随着官方镜像维护，发布了新版本后，重新 docker pull mongo:3.2 时，mongo:3.2 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <none>。除了 docker pull 可能导致这种情况，docker build 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <none> 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像：</p>
<p>docker image ls -f dangling=true</p>
<p>REPOSITORY     TAG         IMAGE ID      CREATED       SIZE</p>
<p><none>       <none>       00285df0df87    5 days ago     342 MB</p>
<p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p>
<p>docker image prune</p>
<h3 id="4-2-3-中间层镜像"><a href="#4-2-3-中间层镜像" class="headerlink" title="4.2.3. 中间层镜像"></a>4.2.3. 中间层镜像</h3><p>为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。</p>
<p>docker image ls -a</p>
<p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p>
<h3 id="4-2-4-列出部分镜像"><a href="#4-2-4-列出部分镜像" class="headerlink" title="4.2.4. 列出部分镜像"></a>4.2.4. 列出部分镜像</h3><p>不加任何参数的情况下，docker image ls 会列出所有顶级镜像，但是有时候我们只希望列出部分镜像。docker image ls 有好几个参数可以帮助做到这个事情。</p>
<p>根据仓库名列出镜像</p>
<p>docker image ls ubuntu</p>
<p>REPOSITORY     TAG         IMAGE ID      CREATED       SIZE</p>
<p>ubuntu       16.04        f753707788c5    4 weeks ago     127 MB</p>
<p>ubuntu       latest       f753707788c5    4 weeks ago     127 MB</p>
<p>ubuntu       14.04        1e0c3dd64ccd    4 weeks ago     188 MB</p>
<p>列出特定的某个镜像，也就是说指定仓库名和标签</p>
<p>docker image ls ubuntu:16.04</p>
<p>REPOSITORY     TAG         IMAGE ID      CREATED       SIZE</p>
<p>ubuntu       16.04        f753707788c5    4 weeks ago     127 MB</p>
<p>除此以外，docker image ls 还支持强大的过滤器参数 –filter，或者简写 -f。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 mongo:3.2 之后建立的镜像，可以用下面的命令：</p>
<p>docker image ls -f since=mongo:3.2</p>
<p>REPOSITORY     TAG         IMAGE ID      CREATED       SIZE</p>
<p>redis        latest       5f515359c7f8    5 days ago     183 MB</p>
<p>nginx        latest       05a60462f8ba    5 days ago     181 MB</p>
<p>想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。</p>
<p>此外，如果镜像构建时，定义了 LABEL，还可以通过 LABEL 来过滤。</p>
<p>docker image ls -f label=com.example.version=0.1</p>
<h3 id="4-2-5-以特定格式显示"><a href="#4-2-5-以特定格式显示" class="headerlink" title="4.2.5. 以特定格式显示"></a>4.2.5. 以特定格式显示</h3><p>默认情况下，docker image ls 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 docker image ls 把所有的虚悬镜像的 ID 列出来，然后才可以交给 docker image rm 命令作为参数来删除指定的这些镜像，这个时候就用到了 -q 参数。</p>
<p>docker image ls -q</p>
<p>5f515359c7f8</p>
<p>05a60462f8ba</p>
<p>fe9198c04d62</p>
<p>00285df0df87</p>
<p>f753707788c5</p>
<p>f753707788c5</p>
<p>1e0c3dd64ccd</p>
<p>–filter 配合 -q 产生出指定范围的 ID 列表，然后送给另一个 docker 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。</p>
<p>另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 Go 的模板语法。</p>
<p>比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</p>
<p>docker image ls –format “{.ID}: {.Repository}”</p>
<p>5f515359c7f8: redis</p>
<p>05a60462f8ba: nginx</p>
<p>fe9198c04d62: mongo</p>
<p>00285df0df87: <none></p>
<p>f753707788c5: ubuntu</p>
<p>f753707788c5: ubuntu</p>
<p>1e0c3dd64ccd: ubuntu</p>
<p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p>
<p>docker image ls –format “table {.ID}\t{.Repository}\t{.Tag}”</p>
<p>IMAGE ID      REPOSITORY     TAG</p>
<p>5f515359c7f8    redis        latest</p>
<p>05a60462f8ba    nginx        latest</p>
<p>fe9198c04d62    mongo        3.2</p>
<p>00285df0df87    <none>       <none></p>
<p>f753707788c5    ubuntu       16.04</p>
<p>f753707788c5    ubuntu       latest</p>
<p>1e0c3dd64ccd    ubuntu       14.04</p>
<h2 id="4-3-docker-删除本地镜像"><a href="#4-3-docker-删除本地镜像" class="headerlink" title="4.3.   docker 删除本地镜像"></a>4.3.   docker 删除本地镜像</h2><p>如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为：</p>
<p>docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; …]</p>
<h3 id="4-3-1-用-ID、镜像名、摘要删除镜像"><a href="#4-3-1-用-ID、镜像名、摘要删除镜像" class="headerlink" title="4.3.1. 用 ID、镜像名、摘要删除镜像"></a>4.3.1. 用 ID、镜像名、摘要删除镜像</h3><p>其中，&lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要。</p>
<p>比如我们有这么一些镜像：</p>
<p>docker image ls</p>
<p>REPOSITORY     TAG         IMAGE ID      CREATED       SIZE</p>
<p>centos        latest       0584b3d2cf6d    3 weeks ago     196.5 MB</p>
<p>redis         alpine       501ad78535f0    3 weeks ago     21.03 MB</p>
<p>docker        latest       cf693ec9b5c7    3 weeks ago     105.1 MB</p>
<p>nginx         latest       e43d811ce2f4    5 weeks ago     181.5 MB</p>
<p>我们可以用镜像的完整 ID，也称为 长 ID，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 短 ID 来删除镜像。docker image ls 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p>
<p>比如这里，如果我们要删除 redis:alpine 镜像，可以执行：</p>
<p>docker image rm 501</p>
<p>Untagged: redis:alpine</p>
<p>Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d</p>
<p>Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7</p>
<p>Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b</p>
<p>Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23</p>
<p>Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa</p>
<p>Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3</p>
<p>Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</p>
<p>我们也可以用镜像名，也就是 &lt;仓库名&gt;:&lt;标签&gt;，来删除镜像。</p>
<p>docker image rm centos</p>
<p>Untagged: centos:latest</p>
<p>Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c</p>
<p>Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a</p>
<p>Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</p>
<p>当然，更精确的是使用 镜像摘要 删除镜像。</p>
<p>docker image ls –digests</p>
<p>REPOSITORY         TAG         DIGEST                                   IMAGE ID      CREATED       SIZE</p>
<p>node            slim        sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228  6e0c4c8e3913    3 weeks ago     214 MB</p>
<p>docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</p>
<p>Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</p>
<h3 id="4-3-2-Untagged-和-Deleted"><a href="#4-3-2-Untagged-和-Deleted" class="headerlink" title="4.3.2. Untagged 和 Deleted"></a>4.3.2. Untagged 和 Deleted</h3><p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 Untagged，另一类是 Deleted。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p>
<p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 Untagged 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 Delete 行为就不会发生。所以并非所有的 docker image rm 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p>
<p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变动非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 docker pull 看到的层数不一样的源。</p>
<p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p>
<h3 id="4-3-3-用-docker-image-ls-命令来配合"><a href="#4-3-3-用-docker-image-ls-命令来配合" class="headerlink" title="4.3.3. 用 docker image ls 命令来配合"></a>4.3.3. 用 docker image ls 命令来配合</h3><p>像其它可以承接多个实体的命令一样，可以使用 docker image ls -q 来配合使用 docker image rm，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。</p>
<p>比如，我们需要删除所有仓库名为 redis 的镜像：</p>
<p>docker image rm $(docker image ls -q redis)</p>
<p>或者删除所有在 mongo:3.2 之前的镜像：</p>
<p>docker image rm $(docker image ls -q -f before=mongo:3.2)</p>
<p>充分利用你的想象力和 Linux 命令行的强大，你可以完成很多非常赞的功能。</p>
<h3 id="4-3-4-CentOS-RHEL-的用户需要注意的事项"><a href="#4-3-4-CentOS-RHEL-的用户需要注意的事项" class="headerlink" title="4.3.4. CentOS/RHEL 的用户需要注意的事项"></a>4.3.4. CentOS/RHEL 的用户需要注意的事项</h3><p>在 Ubuntu/Debian 上有 UnionFS 可以使用，如 aufs 或者 overlay2，而 CentOS 和 RHEL 的内核中没有相关驱动。因此对于这类系统，一般使用 devicemapper 驱动利用 LVM 的一些机制来模拟分层存储。这样的做法除了性能比较差外，稳定性一般也不好，而且配置相对复杂。Docker 安装在 CentOS/RHEL 上后，会默认选择 devicemapper，但是为了简化配置，其 devicemapper 是跑在一个稀疏文件模拟的块设备上，也被称为 loop-lvm。这样的选择是因为不需要额外配置就可以运行 Docker，这是自动配置唯一能做到的事情。但是 loop-lvm 的做法非常不好，其稳定性、性能更差，无论是日志还是 docker info 中都会看到警告信息。官方文档有明确的文章讲解了如何配置块设备给 devicemapper 驱动做存储层的做法，这类做法也被称为配置 direct-lvm。</p>
<p>除了前面说到的问题外，devicemapper + loop-lvm 还有一个缺陷，因为它是稀疏文件，所以它会不断增长。用户在使用过程中会注意到 /var/lib/docker/devicemapper/devicemapper/data 不断增长，而且无法控制。很多人会希望删除镜像或者可以解决这个问题，结果发现效果并不明显。原因就是这个稀疏文件的空间释放后基本不进行垃圾回收的问题。因此往往会出现即使删除了文件内容，空间却无法回收，随着使用这个稀疏文件一直在不断增长。</p>
<p>所以对于 CentOS/RHEL 的用户来说，在没有办法使用 UnionFS 的情况下，一定要配置 direct-lvm 给 devicemapper，无论是为了性能、稳定性还是空间利用率。</p>
<p>或许有人注意到了 CentOS 7 中存在被 backports 回来的 overlay 驱动，不过 CentOS 里的这个驱动达不到生产环境使用的稳定程度，所以不推荐使用。</p>
<h2 id="4-4-利用-commit-理解镜像构成"><a href="#4-4-利用-commit-理解镜像构成" class="headerlink" title="4.4.   利用 commit 理解镜像构成"></a>4.4.   利用 commit 理解镜像构成</h2><p>注意： docker commit 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 docker commit 定制镜像，定制镜像应该使用 Dockerfile 来完成。如果你想要定制镜像请查看下一小节。</p>
<p>镜像是容器的基础，每次执行 docker run 的时候都会指定哪个镜像作为容器运行的基础。在之前的例子中，我们所使用的都是来自于 Docker Hub 的镜像。直接使用这些镜像是可以满足一定的需求，而当这些镜像无法直接满足需求时，我们就需要定制这些镜像。接下来的几节就将讲解如何定制镜像。</p>
<p>回顾一下之前我们学到的知识，镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p>
<p>现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p>
<p>docker run –name webserver -d -p 80:80 nginx</p>
<p>这条命令会用 nginx 镜像启动一个容器，命名为 webserver，并且映射了 80 端口，这样我们可以用浏览器去访问这个 nginx 服务器。</p>
<p>如果是在 Linux 本机运行的 Docker，或者如果使用的是 Docker for Mac、Docker for Windows，那么可以直接访问：<a href="http://localhost；如果使用的是" target="_blank" rel="noopener">http://localhost；如果使用的是</a> Docker Toolbox，或者是在虚拟机、云服务器上安装的 Docker，则需要将 localhost 换为虚拟机地址或者实际云服务器地址。</p>
<p>直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134833.gif" alt="https://www.funtl.com/assets/images-mac-example-nginx.png"></p>
<p>现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 Docker 的文字，我们可以使用 docker exec 命令进入容器，修改其内容。</p>
<p>docker exec -it webserver bash</p>
<p>root@3729b97e8226:/# echo ‘<h1>Hello, Docker!</h1>‘ &gt; /usr/share/nginx/html/index.html</p>
<p>root@3729b97e8226:/# exit</p>
<p>exit</p>
<p>我们以交互式终端方式进入 webserver 容器，并执行了 bash 命令，也就是获得一个可操作的 Shell。</p>
<p>然后，我们用 <h1>Hello, Docker!</h1> 覆盖了 /usr/share/nginx/html/index.html 的内容。</p>
<p>现在我们再刷新浏览器的话，会发现内容被改变了。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134836.gif" alt="https://www.funtl.com/assets/images-create-nginx-docker.png"></p>
<p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 docker diff 命令看到具体的改动。</p>
<p>docker diff webserver</p>
<p>C /root</p>
<p>A /root/.bash_history</p>
<p>C /run</p>
<p>C /usr</p>
<p>C /usr/share</p>
<p>C /usr/share/nginx</p>
<p>C /usr/share/nginx/html</p>
<p>C /usr/share/nginx/html/index.html</p>
<p>C /var</p>
<p>C /var/cache</p>
<p>C /var/cache/nginx</p>
<p>A /var/cache/nginx/client_temp</p>
<p>A /var/cache/nginx/fastcgi_temp</p>
<p>A /var/cache/nginx/proxy_temp</p>
<p>A /var/cache/nginx/scgi_temp</p>
<p>A /var/cache/nginx/uwsgi_temp</p>
<p>现在我们定制好了变化，我们希望能将其保存下来形成镜像。</p>
<p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p>
<p>docker commit 的语法格式为：</p>
<p>docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</p>
<p>我们可以用下面的命令将容器保存为镜像：</p>
<p>docker commit \</p>
<p>  –author “Tao Wang <a href="mailto:&#116;&#x77;&#x61;&#x6e;&#x67;&#x32;&#50;&#49;&#x38;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;">&#116;&#x77;&#x61;&#x6e;&#x67;&#x32;&#50;&#49;&#x38;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#x6d;</a>“ \</p>
<p>  –message “修改了默认网页” \</p>
<p>  webserver \</p>
<p>  nginx:v2</p>
<p>其中 –author 是指定修改的作者，而 –message 则是记录本次修改的内容。这点和 git 版本控制相似，不过这里这些信息可以省略留空。</p>
<p>我们可以在 docker image ls 中看到这个新定制的镜像：</p>
<p>docker image ls nginx</p>
<p>REPOSITORY     TAG         IMAGE ID      CREATED       SIZE</p>
<p>nginx        v2          07e334659748    9 seconds ago    181.5 MB</p>
<p>nginx        1.11        05a60462f8ba    12 days ago     181.5 MB</p>
<p>nginx        latest       e43d811ce2f4    4 weeks ago     181.5 MB</p>
<p>我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p>
<p>docker history nginx:v2</p>
<p>IMAGE        CREATED       CREATED BY                   SIZE        COMMENT</p>
<p>07e334659748    54 seconds ago   nginx -g daemon off;              95 B        修改了默认网页</p>
<p>e43d811ce2f4    4 weeks ago     /bin/sh -c #(nop) CMD [“nginx” “-g” “daemon  0 B</p>
<p><missing>      4 weeks ago     /bin/sh -c #(nop) EXPOSE 443/tcp 80/tcp    0 B</p>
<p><missing>      4 weeks ago     /bin/sh -c ln -sf /dev/stdout /var/log/nginx/  22 B</p>
<p><missing>      4 weeks ago     /bin/sh -c apt-key adv –keyserver hkp://pgp.  58.46 MB</p>
<p><missing>      4 weeks ago     /bin/sh -c #(nop) ENV NGINX_VERSION=1.11.5-1  0 B</p>
<p><missing>      4 weeks ago     /bin/sh -c #(nop) MAINTAINER NGINX Docker Ma  0 B</p>
<p><missing>      4 weeks ago     /bin/sh -c #(nop) CMD [“/bin/bash”]      0 B</p>
<p><missing>      4 weeks ago     /bin/sh -c #(nop) ADD file:23aa4f893e3288698c  123 MB</p>
<p>新的镜像定制好后，我们可以来运行这个镜像。</p>
<p>docker run –name web2 -d -p 81:80 nginx:v2</p>
<p>这里我们命名为新的服务为 web2，并且映射到 81 端口。如果是 Docker for Mac/Windows 或 Linux 桌面的话，我们就可以直接访问 <a href="http://localhost:81" target="_blank" rel="noopener">http://localhost:81</a> 看到结果，其内容应该和之前修改后的 webserver 一样。</p>
<p>至此，我们第一次完成了定制镜像，使用的是 docker commit 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。</p>
<h3 id="4-4-1-慎用-docker-commit"><a href="#4-4-1-慎用-docker-commit" class="headerlink" title="4.4.1. 慎用 docker commit"></a>4.4.1. 慎用 docker commit</h3><p>使用 docker commit 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p>
<p>首先，如果仔细观察之前的 docker diff webserver 的结果，你会发现除了真正想要修改的 /usr/share/nginx/html/index.html 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像极为臃肿。</p>
<p>此外，使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 docker diff 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。</p>
<p>而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 docker commit 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p>
<h2 id="4-5-使用-Dockerfile-定制镜像"><a href="#4-5-使用-Dockerfile-定制镜像" class="headerlink" title="4.5.   使用 Dockerfile 定制镜像"></a>4.5.   使用 Dockerfile 定制镜像</h2><h3 id="4-5-1-Dockerfile-定制镜像"><a href="#4-5-1-Dockerfile-定制镜像" class="headerlink" title="4.5.1. Dockerfile 定制镜像"></a>4.5.1. Dockerfile 定制镜像</h3><p>从刚才的 docker commit 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>还以之前定制 nginx 镜像为例，这次我们使用 Dockerfile 来定制。</p>
<p>在一个空白目录中，建立一个文本文件，并命名为 Dockerfile：</p>
<p>mkdir mynginx</p>
<p>cd mynginx</p>
<p>touch Dockerfile</p>
<p>其内容为：</p>
<p>FROM nginx</p>
<p>RUN echo ‘<h1>Hello, Docker!</h1>‘ &gt; /usr/share/nginx/html/index.html</p>
<p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。</p>
<h3 id="4-5-2-FROM-指定基础镜像"><a href="#4-5-2-FROM-指定基础镜像" class="headerlink" title="4.5.2. FROM 指定基础镜像"></a>4.5.2. FROM 指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。</p>
<p>在 Docker Store 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p>
<p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<p>FROM scratch</p>
<p>…</p>
<p>如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 swarm、coreos/etcd。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p>
<h3 id="4-5-3-RUN-执行命令"><a href="#4-5-3-RUN-执行命令" class="headerlink" title="4.5.3. RUN 执行命令"></a>4.5.3. RUN 执行命令</h3><p>RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<p>shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。</p>
<p>RUN echo ‘<h1>Hello, Docker!</h1>‘ &gt; /usr/share/nginx/html/index.html</p>
<p>exec 格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。</p>
<p>既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p>
<p>FROM debian:jessie</p>
<p>RUN apt-get update</p>
<p>RUN apt-get install -y gcc libc6-dev make</p>
<p>RUN wget -O redis.tar.gz “<a href="http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;" target="_blank" rel="noopener">http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</a></p>
<p>RUN mkdir -p /usr/src/redis</p>
<p>RUN tar -xzf redis.tar.gz -C /usr/src/redis –strip-components=1</p>
<p>RUN make -C /usr/src/redis</p>
<p>RUN make -C /usr/src/redis install</p>
<p>之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。</p>
<p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p>
<p>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</p>
<p>上面的 Dockerfile 正确的写法应该是这样：</p>
<p>FROM debian:jessie</p>
<p>RUN buildDeps=’gcc libc6-dev make’ \</p>
<p>  &amp;&amp; apt-get update \</p>
<p>  &amp;&amp; apt-get install -y $buildDeps \</p>
<p>  &amp;&amp; wget -O redis.tar.gz “<a href="http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;" target="_blank" rel="noopener">http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</a> \</p>
<p>  &amp;&amp; mkdir -p /usr/src/redis \</p>
<p>  &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis –strip-components=1 \</p>
<p>  &amp;&amp; make -C /usr/src/redis \</p>
<p>  &amp;&amp; make -C /usr/src/redis install \</p>
<p>  &amp;&amp; rm -rf /var/lib/apt/lists/* \</p>
<p>  &amp;&amp; rm redis.tar.gz \</p>
<p>  &amp;&amp; rm -r /usr/src/redis \</p>
<p>  &amp;&amp; apt-get purge -y –auto-remove $buildDeps</p>
<p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p>
<p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p>
<h3 id="4-5-4-构建镜像"><a href="#4-5-4-构建镜像" class="headerlink" title="4.5.4. 构建镜像"></a>4.5.4. 构建镜像</h3><p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p>
<p>在 Dockerfile 文件所在目录执行：</p>
<p>docker build -t nginx:v3 .</p>
<p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 Step 2 中，如同我们之前所说的那样，RUN 指令启动了一个容器 9cdc27646c7b，执行了所要求的命令，并最后提交了这一层 44aa4490ce2c，随后删除了所用到的这个容器 9cdc27646c7b。</p>
<p>这里我们使用了 docker build 命令进行镜像构建。其格式为：</p>
<p>docker build [选项] &lt;上下文路径/URL/-&gt;</p>
<p>在这里我们指定了最终镜像的名称 -t nginx:v3，构建成功后，我们可以像之前运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。</p>
<h3 id="4-5-5-镜像构建上下文（Context）"><a href="#4-5-5-镜像构建上下文（Context）" class="headerlink" title="4.5.5. 镜像构建上下文（Context）"></a>4.5.5. 镜像构建上下文（Context）</h3><p>如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定上下文路径。那么什么是上下文呢？</p>
<p>首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p>
<p>当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>如果在 Dockerfile 中这么写：</p>
<p>COPY ./package.json /app/</p>
<p>这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。</p>
<p>因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p>
<p>现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p>
<p>如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程：</p>
<p>docker build -t nginx:v3 .</p>
<p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 COPY /opt/xxxx /app 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。</p>
<p>一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>
<p>那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。</p>
<p>这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。</p>
<p>当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</p>
<h3 id="4-5-6-其它-docker-build-的用法"><a href="#4-5-6-其它-docker-build-的用法" class="headerlink" title="4.5.6. 其它 docker build 的用法"></a>4.5.6. 其它 docker build 的用法</h3><h4 id="4-5-6-1-直接用-Git-repo-进行构建"><a href="#4-5-6-1-直接用-Git-repo-进行构建" class="headerlink" title="4.5.6.1.   直接用 Git repo 进行构建"></a>4.5.6.1.   直接用 Git repo 进行构建</h4><p>或许你已经注意到了，docker build 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p>
<p>docker build <a href="https://github.com/twang2218/gitlab-ce-zh.git#:8.14" target="_blank" rel="noopener">https://github.com/twang2218/gitlab-ce-zh.git#:8.14</a></p>
<p>这行命令指定了构建所需的 Git repo，并且指定默认的 master 分支，构建目录为 /8.14/，然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>
<h4 id="4-5-6-2-用给定的-tar-压缩包构建"><a href="#4-5-6-2-用给定的-tar-压缩包构建" class="headerlink" title="4.5.6.2.   用给定的 tar 压缩包构建"></a>4.5.6.2.   用给定的 tar 压缩包构建</h4><p>docker build <a href="http://server/context.tar.gz" target="_blank" rel="noopener">http://server/context.tar.gz</a></p>
<p>如果所给出的 URL 不是个 Git repo，而是个 tar 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p>
<h4 id="4-5-6-3-从标准输入中读取-Dockerfile-进行构建"><a href="#4-5-6-3-从标准输入中读取-Dockerfile-进行构建" class="headerlink" title="4.5.6.3.   从标准输入中读取 Dockerfile 进行构建"></a>4.5.6.3.   从标准输入中读取 Dockerfile 进行构建</h4><p>docker build - &lt; Dockerfile</p>
<p>或</p>
<p>cat Dockerfile | docker build -</p>
<p>如果标准输入传入的是文本文件，则将其视为 Dockerfile，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 COPY 进镜像之类的事情。</p>
<h4 id="4-5-6-4-从标准输入中读取上下文压缩包进行构建"><a href="#4-5-6-4-从标准输入中读取上下文压缩包进行构建" class="headerlink" title="4.5.6.4.   从标准输入中读取上下文压缩包进行构建"></a>4.5.6.4.   从标准输入中读取上下文压缩包进行构建</h4><p>docker build - &lt; context.tar.gz</p>
<p>如果发现标准输入的文件格式是 gzip、bzip2 以及 xz 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>
<h2 id="4-6-Dockerfile-指令详解"><a href="#4-6-Dockerfile-指令详解" class="headerlink" title="4.6.   Dockerfile 指令详解"></a>4.6.   Dockerfile 指令详解</h2><p>我们已经介绍了 FROM，RUN，还提及了 COPY, ADD，其实 Dockerfile 功能很强大，它提供了十多个指令。下面我们继续讲解其他的指令。</p>
<h3 id="4-6-1-COPY-复制文件"><a href="#4-6-1-COPY-复制文件" class="headerlink" title="4.6.1. COPY 复制文件"></a>4.6.1. COPY 复制文件</h3><p>格式：</p>
<p>l COPY &lt;源路径&gt;… &lt;目标路径&gt;</p>
<p>l COPY [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]</p>
<p>和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p>
<p>COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。比如：</p>
<p>COPY package.json /usr/src/app/</p>
<p>&lt;源路径&gt; 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：</p>
<p>COPY hom* /mydir/</p>
<p>COPY hom?.txt /mydir/</p>
<p>&lt;目标路径&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>
<h3 id="4-6-2-ADD-更高级的复制文件"><a href="#4-6-2-ADD-更高级的复制文件" class="headerlink" title="4.6.2. ADD 更高级的复制文件"></a>4.6.2. ADD 更高级的复制文件</h3><p>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。</p>
<p>比如 &lt;源路径&gt; 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p>
<p>如果 &lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去。</p>
<p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 ubuntu 中：</p>
<p>FROM scratch</p>
<p>ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</p>
<p>…</p>
<p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 ADD 命令了。</p>
<p>在 Docker 官方的 Dockerfile 最佳实践文档 中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。</p>
<p>另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。</p>
<h3 id="4-6-3-CMD-容器启动命令"><a href="#4-6-3-CMD-容器启动命令" class="headerlink" title="4.6.3. CMD 容器启动命令"></a>4.6.3. CMD 容器启动命令</h3><p>CMD 指令的格式和 RUN 相似，也是两种格式：</p>
<p>l shell 格式：CMD &lt;命令&gt;</p>
<p>l exec 格式：CMD [“可执行文件”, “参数1”, “参数2”…]</p>
<p>l 参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。</p>
<p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是 /bin/bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release。这就是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，输出了系统版本信息。</p>
<p>在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 “，而不要使用单引号。</p>
<p>如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如：</p>
<p>CMD echo $HOME</p>
<p>在实际执行中，会将其变更为：</p>
<p>CMD [ “sh”, “-c”, “echo $HOME” ]</p>
<p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p>
<p>提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。</p>
<p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。</p>
<p>一些初学者将 CMD 写为：</p>
<p>CMD service nginx start</p>
<p>然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 service nginx start 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服务。而刚才说了 CMD service nginx start 会被理解为 CMD [ “sh”, “-c”, “service nginx start”]，因此主进程实际上是 sh。那么当 service nginx start 命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：</p>
<p>CMD [“nginx”, “-g”, “daemon off;”]</p>
<h3 id="4-6-4-ENTRYPOINT-入口点"><a href="#4-6-4-ENTRYPOINT-入口点" class="headerlink" title="4.6.4. ENTRYPOINT 入口点"></a>4.6.4. ENTRYPOINT 入口点</h3><p>ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。</p>
<p>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 –entrypoint 来指定。</p>
<p>当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：</p>
<p><ENTRYPOINT> “<CMD>“</p>
<p>那么有了 CMD 后，为什么还要有 ENTRYPOINT 呢？这种 <ENTRYPOINT> “<CMD>“ 有什么好处么？让我们来看几个场景。</p>
<p><strong>场景一：让镜像变成像命令一样使用</strong></p>
<p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现：</p>
<p>FROM ubuntu:16.04</p>
<p>RUN apt-get update \</p>
<p>  &amp;&amp; apt-get install -y curl \</p>
<p>  &amp;&amp; rm -rf /var/lib/apt/lists/*</p>
<p>CMD [ “curl”, “-s”, “<a href="http://ip.cn&quot;" target="_blank" rel="noopener">http://ip.cn&quot;</a> ]</p>
<p>假如我们使用 docker build -t myip . 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p>
<p>docker run myip</p>
<p>当前 IP：61.148.226.66 来自：北京市 联通</p>
<p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 CMD 中可以看到实质的命令是 curl，那么如果我们希望显示 HTTP 头信息，就需要加上 -i 参数。那么我们可以直接加 -i 参数给 docker run myip 么？</p>
<p>docker run myip -i</p>
<p>docker: Error response from daemon: invalid header field value “oci runtime error: container_linux.go:247: starting container process caused &quot;exec: \&quot;-i\&quot;: executable file not found in $PATH&quot;\n”.</p>
<p>我们可以看到可执行文件找不到的报错，executable file not found。之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的 CMD，而不是添加在原来的 curl -s <a href="http://ip.cn" target="_blank" rel="noopener">http://ip.cn</a> 后面。而 -i 根本不是命令，所以自然找不到。</p>
<p>那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令：</p>
<p>docker run myip curl -s <a href="http://ip.cn" target="_blank" rel="noopener">http://ip.cn</a> -i</p>
<p>这显然不是很好的解决方案，而使用 ENTRYPOINT 就可以解决这个问题。现在我们重新用 ENTRYPOINT 来实现这个镜像：</p>
<p>FROM ubuntu:16.04</p>
<p>RUN apt-get update \</p>
<p>  &amp;&amp; apt-get install -y curl \</p>
<p>  &amp;&amp; rm -rf /var/lib/apt/lists/*</p>
<p>ENTRYPOINT [ “curl”, “-s”, “<a href="http://ip.cn&quot;" target="_blank" rel="noopener">http://ip.cn&quot;</a> ]</p>
<p>这次我们再来尝试直接使用 docker run myip -i：</p>
<p>docker run myip</p>
<p>当前 IP：61.148.226.66 来自：北京市 联通</p>
<p>docker run myip -i</p>
<p>HTTP/1.1 200 OK</p>
<p>Server: nginx/1.8.0</p>
<p>Date: Tue, 22 Nov 2016 05:12:40 GMT</p>
<p>Content-Type: text/html; charset=UTF-8</p>
<p>Vary: Accept-Encoding</p>
<p>X-Powered-By: PHP/5.6.24-1~dotdeb+7.1</p>
<p>X-Cache: MISS from cache-2</p>
<p>X-Cache-Lookup: MISS from cache-2:80</p>
<p>X-Cache: MISS from proxy-2_6</p>
<p>Transfer-Encoding: chunked</p>
<p>Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006</p>
<p>Connection: keep-alive</p>
<p>当前 IP：61.148.226.66 来自：北京市 联通</p>
<p>可以看到，这次成功了。这是因为当存在 ENTRYPOINT 后，CMD 的内容将会作为参数传给 ENTRYPOINT，而这里 -i 就是新的 CMD，因此会作为参数传给 curl，从而达到了我们预期的效果。</p>
<p><strong>场景二：应用运行前的准备工作</strong></p>
<p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p>
<p>比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p>
<p>此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。</p>
<p>这些准备工作是和容器 CMD 无关的，无论 CMD 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是 <CMD>）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的：</p>
<p>FROM alpine:3.4</p>
<p>…</p>
<p>RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis</p>
<p>…</p>
<p>ENTRYPOINT [“docker-entrypoint.sh”]</p>
<p>EXPOSE 6379</p>
<p>CMD [ “redis-server” ]</p>
<p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 ENTRYPOINT 为 docker-entrypoint.sh 脚本。</p>
<p>#!/bin/sh</p>
<p>…</p>
<p># allow the container to be started with <code>--user</code></p>
<p>if [ “$1” = ‘redis-server’ -a “$(id -u)” = ‘0’ ]; then</p>
<p>​    chown -R redis .</p>
<p>​    exec su-exec redis “$0” “$@”</p>
<p>fi</p>
<p>exec “$@”</p>
<p>该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行。比如：</p>
<p>docker run -it redis id</p>
<p>uid=0(root) gid=0(root) groups=0(root)</p>
<h3 id="4-6-5-ENV-设置环境变量"><a href="#4-6-5-ENV-设置环境变量" class="headerlink" title="4.6.5. ENV 设置环境变量"></a>4.6.5. ENV 设置环境变量</h3><p>格式有两种：</p>
<p>l ENV <key> <value></p>
<p>l ENV <key1>=<value1> <key2>=<value2>…</p>
<p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<p>ENV VERSION=1.0 DEBUG=on NAME=”Happy Feet”</p>
<p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p>
<p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 node 镜像 Dockerfile 中，就有类似这样的代码：</p>
<p>ENV NODE_VERSION 7.2.0</p>
<p>RUN curl -SLO “<a href="https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot;" target="_blank" rel="noopener">https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot;</a> \</p>
<p> &amp;&amp; curl -SLO “<a href="https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;" target="_blank" rel="noopener">https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;</a> \</p>
<p> &amp;&amp; gpg –batch –decrypt –output SHASUMS256.txt SHASUMS256.txt.asc \</p>
<p> &amp;&amp; grep “ node-v$NODE_VERSION-linux-x64.tar.xz$“ SHASUMS256.txt | sha256sum -c - \</p>
<p> &amp;&amp; tar -xJf “node-v$NODE_VERSION-linux-x64.tar.xz” -C /usr/local –strip-components=1 \</p>
<p> &amp;&amp; rm “node-v$NODE_VERSION-linux-x64.tar.xz” SHASUMS256.txt.asc SHASUMS256.txt \</p>
<p> &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs</p>
<p>在这里先定义了环境变量 NODE_VERSION，其后的 RUN 这层里，多次使用 $NODE_VERSION 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 7.2.0 即可，Dockerfile 构建维护变得更轻松了。</p>
<p>下列指令可以支持环境变量展开： ADD、COPY、ENV、EXPOSE、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD。</p>
<p>可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 Dockerfile 制作更多的镜像，只需使用不同的环境变量即可。</p>
<h3 id="4-6-6-ARG-构建参数"><a href="#4-6-6-ARG-构建参数" class="headerlink" title="4.6.6. ARG 构建参数"></a>4.6.6. ARG 构建参数</h3><p>格式：ARG &lt;参数名&gt;[=&lt;默认值&gt;]</p>
<p>构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。</p>
<p>Dockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 docker build 中用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。</p>
<p>在 1.13 之前的版本，要求 –build-arg 中的参数名，必须在 Dockerfile 中用 ARG 定义过了，换句话说，就是 –build-arg 指定的参数，必须在 Dockerfile 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 Dockerfile 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。</p>
<h3 id="4-6-7-VOLUME-定义匿名卷"><a href="#4-6-7-VOLUME-定义匿名卷" class="headerlink" title="4.6.7. VOLUME 定义匿名卷"></a>4.6.7. VOLUME 定义匿名卷</h3><p>格式为：</p>
<p>l VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]</p>
<p>l VOLUME &lt;路径&gt;</p>
<p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<p>VOLUME /data</p>
<p>这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p>
<p>docker run -d -v mydata:/data xxxx</p>
<p>在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。</p>
<h3 id="4-6-8-EXPOSE-暴露端口"><a href="#4-6-8-EXPOSE-暴露端口" class="headerlink" title="4.6.8. EXPOSE 暴露端口"></a>4.6.8. EXPOSE 暴露端口</h3><p>格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…]。</p>
<p>EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</p>
<p>此外，在早期 Docker 版本中还有一个特殊的用处。以前所有容器都运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个 Docker 引擎参数 –icc=false，当指定该参数后，容器间将默认无法互访，除非互相间使用了 –links 参数的容器才可以互通，并且只有镜像中 EXPOSE 所声明的端口才可以被访问。这个 –icc=false 的用法，在引入了 docker network 后已经基本不用了，通过自定义网络可以很轻松的实现容器间的互联与隔离。</p>
<p>要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h3 id="4-6-9-WORKDIR-指定工作目录"><a href="#4-6-9-WORKDIR-指定工作目录" class="headerlink" title="4.6.9. WORKDIR 指定工作目录"></a>4.6.9. WORKDIR 指定工作目录</h3><p>格式为 WORKDIR &lt;工作目录路径&gt;。</p>
<p>使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p>
<p>之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p>
<p>RUN cd /app</p>
<p>RUN echo “hello” &gt; world.txt</p>
<p>如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是 hello。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。</p>
<p>之前说过每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUN cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。</p>
<h3 id="4-6-10-USER-指定当前用户"><a href="#4-6-10-USER-指定当前用户" class="headerlink" title="4.6.10.    USER 指定当前用户"></a>4.6.10.    USER 指定当前用户</h3><p>格式：USER &lt;用户名&gt;</p>
<p>USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。</p>
<p>当然，和 WORKDIR 一样，USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<p>RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</p>
<p>USER redis</p>
<p>RUN [ “redis-server” ]</p>
<p>如果以 root 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 su 或者 sudo，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 gosu。</p>
<p># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</p>
<p>RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</p>
<p># 下载 gosu</p>
<p>RUN wget -O /usr/local/bin/gosu “<a href="https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot;" target="_blank" rel="noopener">https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot;</a> \</p>
<p>  &amp;&amp; chmod +x /usr/local/bin/gosu \</p>
<p>  &amp;&amp; gosu nobody true</p>
<p># 设置 CMD，并以另外的用户执行</p>
<p>CMD [ “exec”, “gosu”, “redis”, “redis-server” ]</p>
<h3 id="4-6-11-HEALTHCHECK-健康检查"><a href="#4-6-11-HEALTHCHECK-健康检查" class="headerlink" title="4.6.11.    HEALTHCHECK 健康检查"></a>4.6.11.    HEALTHCHECK 健康检查</h3><p>格式：</p>
<p>l HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</p>
<p>l HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</p>
<p>HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。</p>
<p>在没有 HEALTHCHECK 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p>
<p>而自 1.12 之后，Docker 提供了 HEALTHCHECK 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p>
<p>当在一个镜像指定了 HEALTHCHECK 指令后，用其启动容器，初始状态会为 starting，在 HEALTHCHECK 指令检查成功后变为 healthy，如果连续一定次数失败，则会变为 unhealthy。</p>
<p>HEALTHCHECK 支持下列选项：</p>
<p>l –interval=&lt;间隔&gt;：两次健康检查的间隔，默认为 30 秒；</p>
<p>l –timeout=&lt;时长&gt;：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</p>
<p>l –retries=&lt;次数&gt;：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。</p>
<p>和 CMD, ENTRYPOINT 一样，HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。</p>
<p>在 HEALTHCHECK [选项] CMD 后面的命令，格式和 ENTRYPOINT 一样，分为 shell 格式，和 exec 格式。命令的返回值决定了该次健康检查的成功与否：0：成功；1：失败；2：保留，不要使用这个值。</p>
<p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 curl 来帮助判断，其 Dockerfile 的 HEALTHCHECK 可以这么写：</p>
<p>FROM nginx</p>
<p>RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*</p>
<p>HEALTHCHECK –interval=5s –timeout=3s \</p>
<p> CMD curl -fs <a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> || exit 1</p>
<p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 curl -fs <a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> || exit 1 作为健康检查命令。</p>
<p>使用 docker build 来构建这个镜像：</p>
<p>docker build -t myweb:v1 .</p>
<p>构建好了后，我们启动一个容器：</p>
<p>docker run -d –name web -p 80:80 myweb:v1</p>
<p>当运行该镜像后，可以通过 docker container ls 看到最初的状态为 (health: starting)：</p>
<p>docker container ls</p>
<p>CONTAINER ID    IMAGE        COMMAND         CREATED       STATUS              PORTS        NAMES</p>
<p>03e28eb00bd0    myweb:v1      “nginx -g ‘daemon off”  3 seconds ago    Up 2 seconds (health: starting)  80/tcp, 443/tcp   web</p>
<p>在等待几秒钟后，再次 docker container ls，就会看到健康状态变化为了 (healthy)：</p>
<p>docker container ls</p>
<p>CONTAINER ID    IMAGE        COMMAND         CREATED       STATUS          PORTS        NAMES</p>
<p>03e28eb00bd0    myweb:v1      “nginx -g ‘daemon off”  18 seconds ago   Up 16 seconds (healthy)  80/tcp, 443/tcp   web</p>
<p>如果健康检查连续失败超过了重试次数，状态就会变为 (unhealthy)。</p>
<p>为了帮助排障，健康检查命令的输出（包括 stdout 以及 stderr）都会被存储于健康状态里，可以用 docker inspect 来查看。</p>
<p>docker inspect –format ‘{json .State.Health}’ web | python -m json.tool</p>
<p>{</p>
<p>  “FailingStreak”: 0,</p>
<p>  “Log”: [</p>
<p>​    {</p>
<p>​      “End”: “2016-11-25T14:35:37.940957051Z”,</p>
<p>​      “ExitCode”: 0,</p>
<p>​      “Output”: “<!DOCTYPE html>\n<html>…… </html>\n”,</p>
<p>​      “Start”: “2019-11-25T14:35:37.780192565Z”</p>
<p>​    }</p>
<p>  ],</p>
<p>  “Status”: “healthy”</p>
<p>}</p>
<h3 id="4-6-12-ONBUILD-为他人作嫁衣"><a href="#4-6-12-ONBUILD-为他人作嫁衣" class="headerlink" title="4.6.12.    ONBUILD 为他人作嫁衣"></a>4.6.12.    ONBUILD 为他人作嫁衣</h3><p>格式：ONBUILD &lt;其它指令&gt;。</p>
<p>ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
<p>Dockerfile 中的其它指令都是为了定制当前镜像而准备的，唯有 ONBUILD 是为了帮助别人定制自己而准备的。</p>
<p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 npm 进行包管理，所有依赖、配置、启动信息等会放到 package.json 文件里。在拿到程序代码后，需要先进行 npm install 才可以获得所有需要的依赖。然后就可以通过 npm start 来启动应用。因此，一般来说会这样写 Dockerfile：</p>
<p>FROM node:slim</p>
<p>RUN mkdir /app</p>
<p>WORKDIR /app</p>
<p>COPY ./package.json /app</p>
<p>RUN [ “npm”, “install” ]</p>
<p>COPY . /app/</p>
<p>CMD [ “npm”, “start” ]</p>
<p>把这个 Dockerfile 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 Dockerfile 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。</p>
<p>如果第一个 Node.js 项目在开发过程中，发现这个 Dockerfile 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 Dockerfile，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 Dockerfile 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 Dockerfile，而第二个项目的 Dockerfile 就会被自动修复。</p>
<p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 Dockerfile 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 Dockerfile 就会变为：</p>
<p>FROM node:slim</p>
<p>RUN mkdir /app</p>
<p>WORKDIR /app</p>
<p>CMD [ “npm”, “start” ]</p>
<p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 my-node 的话，各个项目内的自己的 Dockerfile 就变为：</p>
<p>FROM my-node</p>
<p>COPY ./package.json /app</p>
<p>RUN [ “npm”, “install” ]</p>
<p>COPY . /app/</p>
<p>基础镜像变化后，各个项目都用这个 Dockerfile 重新构建镜像，会继承基础镜像的更新。</p>
<p>那么，问题解决了么？没有。准确说，只解决了一半。如果这个 Dockerfile 里面有些东西需要调整呢？比如 npm install 都需要加一些参数，那怎么办？这一行 RUN 是不可能放入基础镜像的，因为涉及到了当前项目的 ./package.json，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 Dockerfile 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p>
<p>ONBUILD 可以解决这个问题。让我们用 ONBUILD 重新写一下基础镜像的 Dockerfile:</p>
<p>FROM node:slim</p>
<p>RUN mkdir /app</p>
<p>WORKDIR /app</p>
<p>ONBUILD COPY ./package.json /app</p>
<p>ONBUILD RUN [ “npm”, “install” ]</p>
<p>ONBUILD COPY . /app/</p>
<p>CMD [ “npm”, “start” ]</p>
<p>这次我们回到原始的 Dockerfile，但是这次将项目相关的指令加上 ONBUILD，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 Dockerfile 就变成了简单地：</p>
<p>FROM my-node</p>
<p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 Dockerfile 构建镜像时，之前基础镜像的那三行 ONBUILD 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 npm install，生成应用镜像。</p>
<h3 id="4-6-13-参考文档"><a href="#4-6-13-参考文档" class="headerlink" title="4.6.13.    参考文档"></a>4.6.13.    参考文档</h3><p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfie 官方文档</a></p>
<p><a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener">Dockerfile 最佳实践文档</a></p>
<p><a href="https://github.com/docker-library/docs" target="_blank" rel="noopener">Docker 官方镜像 Dockerfile</a></p>
<h2 id="4-7-Dockerfile-多阶段构建"><a href="#4-7-Dockerfile-多阶段构建" class="headerlink" title="4.7.   Dockerfile 多阶段构建"></a>4.7.   Dockerfile 多阶段构建</h2><h3 id="4-7-1-之前的做法"><a href="#4-7-1-之前的做法" class="headerlink" title="4.7.1. 之前的做法"></a>4.7.1. 之前的做法</h3><p>在 Docker 17.05 版本之前，我们构建 Docker 镜像时，通常会采用两种方式：</p>
<h4 id="4-7-1-1-全部放入一个-Dockerfile"><a href="#4-7-1-1-全部放入一个-Dockerfile" class="headerlink" title="4.7.1.1.   全部放入一个 Dockerfile"></a>4.7.1.1.   全部放入一个 Dockerfile</h4><p>一种方式是将所有的构建过程编包含在一个 Dockerfile 中，包括项目及其依赖库的编译、测试、打包等流程，这里可能会带来的一些问题：</p>
<p>Dockerfile 特别长，可维护性降低</p>
<p>镜像层次多，镜像体积较大，部署时间变长</p>
<p>源代码存在泄露的风险</p>
<p>例如</p>
<p>编写 app.go 文件，该程序输出 Hello World!</p>
<p>package main </p>
<p>import “fmt” </p>
<p>func main(){ </p>
<p>  fmt.Printf(“Hello World!”);</p>
<p>}</p>
<p>编写 Dockerfile.one 文件</p>
<p>FROM golang:1.9-alpine</p>
<p>RUN apk –no-cache add git ca-certificates</p>
<p>WORKDIR /go/src/github.com/go/helloworld/</p>
<p>COPY app.go .</p>
<p>RUN go get -d -v github.com/go-sql-driver/mysql \</p>
<p> &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . \</p>
<p> &amp;&amp; cp /go/src/github.com/go/helloworld/app /root</p>
<p>WORKDIR /root/</p>
<p>CMD [“./app”]</p>
<p>构建镜像</p>
<p>docker build -t go/helloworld:1 -f Dockerfile.one</p>
<h4 id="4-7-1-2-分散到多个-Dockerfile"><a href="#4-7-1-2-分散到多个-Dockerfile" class="headerlink" title="4.7.1.2.   分散到多个 Dockerfile"></a>4.7.1.2.   分散到多个 Dockerfile</h4><p>另一种方式，就是我们事先在一个 Dockerfile 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要我们编写两个 Dockerfile 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，但明显部署过程较复杂。</p>
<p>例如</p>
<p>编写 Dockerfile.build 文件</p>
<p>FROM golang:1.9-alpine</p>
<p>RUN apk –no-cache add git</p>
<p>WORKDIR /go/src/github.com/go/helloworld</p>
<p>COPY app.go .</p>
<p>RUN go get -d -v github.com/go-sql-driver/mysql \</p>
<p> &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . </p>
<p>编写 Dockerfile.copy 文件</p>
<p>FROM alpine:latest</p>
<p>RUN apk –no-cache add ca-certificates</p>
<p>WORKDIR /root/</p>
<p>COPY app .</p>
<p>CMD [“./app”] </p>
<p>新建 build.sh</p>
<p>#!/bin/sh</p>
<p>echo Building go/helloworld:build</p>
<p>docker build -t go/helloworld:build . -f Dockerfile.build</p>
<p>docker create –name extract go/helloworld:build</p>
<p>docker cp extract:/go/src/github.com/go/helloworld/app ./app</p>
<p>docker rm -f extract</p>
<p>echo Building go/helloworld:2</p>
<p>docker build –no-cache -t go/helloworld:2 . -f Dockerfile.copy</p>
<p>rm ./app </p>
<p>现在运行脚本即可构建镜像</p>
<p>chmod +x build.sh</p>
<p>./build.sh </p>
<p>对比两种方式生成的镜像大小</p>
<p>docker image ls </p>
<p>REPOSITORY   TAG  IMAGE ID    CREATED     SIZE</p>
<p>go/helloworld  2   f7cf3465432c  22 seconds ago 6.47MB</p>
<p>go/helloworld  1   f55d3e16affc  2 minutes ago  295MB</p>
<h3 id="4-7-2-使用多阶段构建"><a href="#4-7-2-使用多阶段构建" class="headerlink" title="4.7.2. 使用多阶段构建"></a>4.7.2. 使用多阶段构建</h3><p>为解决以上问题，Docker v17.05 开始支持多阶段构建 (multistage builds)。使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个 Dockerfile：</p>
<p>例如</p>
<p>编写 Dockerfile 文件</p>
<p>FROM golang:1.9-alpine as builder</p>
<p>RUN apk –no-cache add git</p>
<p>WORKDIR /go/src/github.com/go/helloworld/</p>
<p>RUN go get -d -v github.com/go-sql-driver/mysql</p>
<p>COPY app.go .</p>
<p>RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</p>
<p>FROM alpine:latest as prod</p>
<p>RUN apk –no-cache add ca-certificates</p>
<p>WORKDIR /root/</p>
<p>COPY –from=0 /go/src/github.com/go/helloworld/app .</p>
<p>CMD [“./app”]  </p>
<p>构建镜像</p>
<p>docker build -t go/helloworld:3 .  </p>
<p>对比三个镜像大小</p>
<p>docker image ls </p>
<p>REPOSITORY    TAG  IMAGE ID     CREATED      SIZE</p>
<p>go/helloworld   3   d6911ed9c846   7 seconds ago   6.47MB</p>
<p>go/helloworld   2   f7cf3465432c   22 seconds ago   6.47MB</p>
<p>go/helloworld   1   f55d3e16affc   2 minutes ago   295MB</p>
<p>很明显使用多阶段构建的镜像体积小，同时也完美解决了上边提到的问题。</p>
<p><strong>只构建某一阶段的镜像</strong></p>
<p>我们可以使用 as 来为某一阶段命名，例如</p>
<p>FROM golang:1.9-alpine as builder </p>
<p>例如当我们只想构建 builder 阶段的镜像时，我们可以在使用 docker build 命令时加上 –target 参数即可</p>
<p>docker build –target builder -t username/imagename:tag . </p>
<p><strong>构建时从其他镜像复制文件</strong></p>
<p>上面例子中我们使用 COPY –from=0 /go/src/github.com/go/helloworld/app . 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件。</p>
<p>COPY –from=nginx:latest /etc/nginx/nginx.conf /nginx.conf </p>
<h2 id="4-8-其他制作镜像方式"><a href="#4-8-其他制作镜像方式" class="headerlink" title="4.8.   其他制作镜像方式"></a>4.8.   其他制作镜像方式</h2><p>除了标准的使用 Dockerfile 生成镜像的方法外，由于各种特殊需求和历史原因，还提供了一些其它方法用以生成镜像。</p>
<h3 id="4-8-1-从-rootfs-压缩包导入"><a href="#4-8-1-从-rootfs-压缩包导入" class="headerlink" title="4.8.1. 从 rootfs 压缩包导入"></a>4.8.1. 从 rootfs 压缩包导入</h3><p>格式：docker import [选项] &lt;文件&gt;|<URL>|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</p>
<p>压缩包可以是本地文件、远程 Web 文件，甚至是从标准输入中得到。压缩包将会在镜像 / 目录展开，并直接作为镜像第一层提交。</p>
<p>比如我们想要创建一个 OpenVZ 的 Ubuntu 14.04 模板的镜像：</p>
<p>docker import \</p>
<p>  <a href="http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz" target="_blank" rel="noopener">http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz</a> \</p>
<p>  openvz/ubuntu:14.04</p>
<p>这条命令自动下载了 ubuntu-14.04-x86_64-minimal.tar.gz 文件，并且作为根文件系统展开导入，并保存为镜像 openvz/ubuntu:14.04。</p>
<p>导入成功后，我们可以用 docker image ls 看到这个导入的镜像：</p>
<p>docker image ls openvz/ubuntu</p>
<p>REPOSITORY     TAG         IMAGE ID      CREATED       SIZE</p>
<p>openvz/ubuntu    14.04        f477a6e18e98    55 seconds ago   214.9 MB</p>
<p>如果我们查看其历史的话，会看到描述中有导入的文件链接：</p>
<p>docker history openvz/ubuntu:14.04</p>
<p>IMAGE        CREATED       CREATED BY     SIZE        COMMENT</p>
<p>f477a6e18e98    About a minute ago            214.9 MB      Imported from <a href="http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz" target="_blank" rel="noopener">http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz</a></p>
<h3 id="4-8-2-docker-save-和-docker-load"><a href="#4-8-2-docker-save-和-docker-load" class="headerlink" title="4.8.2. docker save 和 docker load"></a>4.8.2. docker save 和 docker load</h3><p>Docker 还提供了 docker load 和 docker save 命令，用以将镜像保存为一个 tar 文件，然后传输到另一个位置上，再加载进来。这是在没有 Docker Registry 时的做法，现在已经不推荐，镜像迁移应该直接使用 Docker Registry，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。</p>
<p><strong>保存镜像</strong></p>
<p>使用 docker save 命令可以将镜像保存为归档文件。</p>
<p>比如我们希望保存这个 alpine 镜像。</p>
<p>docker image ls alpine</p>
<p>REPOSITORY     TAG         IMAGE ID      CREATED       SIZE</p>
<p>alpine       latest       baa5d63471ea    5 weeks ago     4.803 MB</p>
<p>保存镜像的命令为：</p>
<p>docker save alpine | gzip &gt; alpine-latest.tar.gz</p>
<p>然后我们将 alpine-latest.tar.gz 文件复制到了到了另一个机器上，可以用下面这个命令加载镜像：</p>
<p>docker load -i alpine-latest.tar.gz</p>
<p>Loaded image: alpine:latest</p>
<p>如果我们结合这两个命令以及 ssh 甚至 pv 的话，利用 Linux 强大的管道，我们可以写一个命令完成从一个机器将镜像迁移到另一个机器，并且带进度条的功能：</p>
<p>docker save &lt;镜像名&gt; | bzip2 | pv | ssh &lt;用户名&gt;@&lt;主机名&gt; ‘cat | docker load’</p>
<h2 id="4-9-镜像的实现原理"><a href="#4-9-镜像的实现原理" class="headerlink" title="4.9.   镜像的实现原理"></a>4.9.   镜像的实现原理</h2><p>Docker 镜像是怎么实现增量的修改和维护的？</p>
<p>每个镜像都由很多层次构成，Docker 使用 Union FS 将这些不同的层结合到一个镜像中去。</p>
<p>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。</p>
<p>Docker 在 AUFS 上构建的容器也是利用了类似的原理。</p>
<h1 id="5-docker-容器"><a href="#5-docker-容器" class="headerlink" title="5. docker 容器"></a>5. docker 容器</h1><p>容器是 Docker 又一核心概念。</p>
<p>简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>
<p>本章将具体介绍如何来管理一个容器，包括创建、启动和停止等。</p>
<h2 id="5-1-启动容器"><a href="#5-1-启动容器" class="headerlink" title="5.1.   启动容器"></a>5.1.   启动容器</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p>
<p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p>
<h3 id="5-1-1-新建并启动"><a href="#5-1-1-新建并启动" class="headerlink" title="5.1.1. 新建并启动"></a>5.1.1. 新建并启动</h3><p>所需要的命令主要为 docker run。</p>
<p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p>
<p>docker run ubuntu:14.04 /bin/echo ‘Hello world’</p>
<p>这跟在本地直接执行 /bin/echo ‘hello world’ 几乎感觉不出任何区别。</p>
<p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p>
<p>docker run -t -i ubuntu:14.04 /bin/bash</p>
<p>其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。</p>
<p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p>
<p>root@af8bae53bdd3:/# pwd</p>
<p>/</p>
<p>root@af8bae53bdd3:/# ls</p>
<p>bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</p>
<p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<p>l 检查本地是否存在指定的镜像，不存在就从公有仓库下载</p>
<p>l 利用镜像创建并启动一个容器</p>
<p>l 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</p>
<p>l 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</p>
<p>l 从地址池配置一个 ip 地址给容器</p>
<p>l 执行用户指定的应用程序</p>
<p>l 执行完毕后容器被终止</p>
<h3 id="5-1-2-启动已终止容器"><a href="#5-1-2-启动已终止容器" class="headerlink" title="5.1.2. 启动已终止容器"></a>5.1.2. 启动已终止容器</h3><p>可以利用 docker container start 命令，直接将一个已经终止的容器启动运行。</p>
<p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 ps 或 top 来查看进程信息。</p>
<p>root@ba267838cc1b:/# ps</p>
<p> PID TTY     TIME CMD</p>
<p>  1 ?    00:00:00 bash</p>
<p>  11 ?    00:00:00 ps</p>
<p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p>
<h2 id="5-2-守护状态运行"><a href="#5-2-守护状态运行" class="headerlink" title="5.2.   守护状态运行"></a>5.2.   守护状态运行</h2><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。</p>
<p>下面举两个例子来说明一下。</p>
<p>如果不使用 -d 参数运行容器。</p>
<p>docker run ubuntu:17.10 /bin/sh -c “while true; do echo hello world; sleep 1; done”</p>
<p>hello world</p>
<p>hello world</p>
<p>hello world</p>
<p>hello world</p>
<p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p>
<p>如果使用了 -d 参数运行容器。</p>
<p>docker run -d ubuntu:17.10 /bin/sh -c “while true; do echo hello world; sleep 1; done”</p>
<p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 docker logs 查看)。</p>
<p>注： 容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。</p>
<p>使用 -d 参数启动后会返回一个唯一的 id，也可以通过 docker container ls 命令来查看容器信息。</p>
<p>docker container ls</p>
<p>要获取容器的输出信息，可以通过 docker container logs 命令。</p>
<p>docker container logs [container ID or NAMES]</p>
<h2 id="5-3-终止容器"><a href="#5-3-终止容器" class="headerlink" title="5.3.   终止容器"></a>5.3.   终止容器</h2><p>可以使用 docker container stop 来终止一个运行中的容器。</p>
<p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p>
<p>例如对于上一章节中只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。</p>
<p>终止状态的容器可以用 docker container ls -a 命令看到。例如</p>
<p>docker container ls -a</p>
<p>处于终止状态的容器，可以通过 docker container start 命令来重新启动。</p>
<p>此外，docker container restart 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h2 id="5-4-进入容器"><a href="#5-4-进入容器" class="headerlink" title="5.4.   进入容器"></a>5.4.   进入容器</h2><p>在使用 -d 参数时，容器启动后会进入后台。</p>
<p>某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令，原因会在下面说明。</p>
<h3 id="5-4-1-attach-命令"><a href="#5-4-1-attach-命令" class="headerlink" title="5.4.1. attach 命令"></a>5.4.1. attach 命令</h3><p>docker attach 是 Docker 自带的命令。下面示例如何使用该命令。</p>
<p>docker run -dit ubuntu</p>
<p>docker run -dit Ubuntu</p>
<p>docker attach 243c</p>
<p>注意： 如果从这个 stdin 中 exit，会导致容器的停止。</p>
<h3 id="5-4-2-exec-命令"><a href="#5-4-2-exec-命令" class="headerlink" title="5.4.2. exec 命令"></a>5.4.2. exec 命令</h3><p><strong>-i -t</strong> <strong>参数</strong></p>
<p>docker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。</p>
<p>只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p>
<p>docker run -dit ubuntu</p>
<p>docker container ls</p>
<p>docker exec -it 69d1 bash</p>
<p>docker exec -i 69d1 bash</p>
<p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 docker exec 的原因。</p>
<p>更多参数说明请使用 docker exec –help 查看。</p>
<h2 id="5-5-导出和导入容器"><a href="#5-5-导出和导入容器" class="headerlink" title="5.5.   导出和导入容器"></a>5.5.   导出和导入容器</h2><h3 id="5-5-1-导出容器"><a href="#5-5-1-导出容器" class="headerlink" title="5.5.1. 导出容器"></a>5.5.1. 导出容器</h3><p>如果要导出本地某个容器，可以使用 docker export 命令。</p>
<p>docker container ls -a</p>
<p>CONTAINER ID    IMAGE        COMMAND       CREATED       STATUS          PORTS        NAMES</p>
<p>7691a814370e    ubuntu:14.04    “/bin/bash”     36 hours ago    Exited (0) 21 hours ago            test</p>
<p>docker export 7691a814370e &gt; ubuntu.tar</p>
<p>这样将导出容器快照到本地文件。</p>
<h3 id="5-5-2-导入容器快照"><a href="#5-5-2-导入容器快照" class="headerlink" title="5.5.2. 导入容器快照"></a>5.5.2. 导入容器快照</h3><p>可以使用 docker import 从容器快照文件中再导入为镜像，例如</p>
<p>cat ubuntu.tar | docker import - test/ubuntu:v1.0</p>
<p>docker image ls</p>
<p>REPOSITORY     TAG         IMAGE ID      CREATED       VIRTUAL SIZE</p>
<p>test/ubuntu     v1.0        9d37a6082e97    About a minute ago  171.3 MB</p>
<p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p>
<p>docker import <a href="http://example.com/exampleimage.tgz" target="_blank" rel="noopener">http://example.com/exampleimage.tgz</a> example/imagerepo</p>
<p>注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
<h2 id="5-6-删除容器"><a href="#5-6-删除容器" class="headerlink" title="5.6.   删除容器"></a>5.6.   删除容器</h2><p>可以使用 docker container rm 来删除一个处于终止状态的容器。例如</p>
<p>docker container rm trusting_newton</p>
<p>如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</p>
<p>#清理所有处于终止状态的容器</p>
<p>用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p>
<p>docker container prune</p>
<h1 id="6-docker-仓库"><a href="#6-docker-仓库" class="headerlink" title="6. docker 仓库"></a>6. docker 仓库</h1><p>仓库（Repository）是集中存放镜像的地方。</p>
<p>一个容易混淆的概念是注册服务器（Registry）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 dl.dockerpool.com/ubuntu 来说，dl.dockerpool.com 是注册服务器地址，ubuntu 是仓库名。</p>
<p>大部分时候，并不需要严格区分这两者的概念。</p>
<h2 id="6-1-docker-hub"><a href="#6-1-docker-hub" class="headerlink" title="6.1.   docker hub"></a>6.1.   docker hub</h2><h3 id="6-1-1-注册"><a href="#6-1-1-注册" class="headerlink" title="6.1.1. 注册"></a>6.1.1. 注册</h3><p>你可以在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a> 免费注册一个 Docker 账号。</p>
<h3 id="6-1-2-登录"><a href="#6-1-2-登录" class="headerlink" title="6.1.2. 登录"></a>6.1.2. 登录</h3><p>可以通过执行 docker login 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p>
<p>你可以通过 docker logout 退出登录。</p>
<h3 id="6-1-3-拉取镜像"><a href="#6-1-3-拉取镜像" class="headerlink" title="6.1.3. 拉取镜像"></a>6.1.3. 拉取镜像</h3><p>你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。</p>
<p>例如以 centos 为关键词进行搜索：</p>
<p>docker search centos</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135244.jpg" alt="img"></p>
<p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建、是否自动创建。</p>
<p>官方的镜像说明是官方项目组创建和维护的，automated 资源允许用户验证镜像的来源和内容。</p>
<p>根据是否是官方提供，可将镜像资源分为两类。</p>
<p>一种是类似 centos 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p>
<p>还有一种类型，比如 tianon/centos 镜像，它是由 Docker 的用户创建并维护的，往往带有用户名称前缀。可以通过前缀 username/ 来指定使用某个用户提供的镜像，比如 tianon 用户。</p>
<p>另外，在查找的时候通过 –filter=stars=N 参数可以指定仅显示收藏数量为 N 以上的镜像。</p>
<p>下载官方 centos 镜像到本地。</p>
<p>docker pull centos</p>
<p>Pulling repository centos</p>
<p>0b443ba03958: Download complete</p>
<p>539c0211cd76: Download complete</p>
<p>511136ea3c5a: Download complete</p>
<p>7064731afe90: Download complete</p>
<h3 id="6-1-4-推送镜像"><a href="#6-1-4-推送镜像" class="headerlink" title="6.1.4. 推送镜像"></a>6.1.4. 推送镜像</h3><p>用户也可以在登录后通过 docker push 命令来将自己的镜像推送到 Docker Hub。</p>
<p>以下命令中的 username 请替换为你的 Docker 账号用户名</p>
<p>docker tag ubuntu:17.10 username/ubuntu:17.10</p>
<p>docker image ls</p>
<p>docker push username/ubuntu:17.10</p>
<p>docker search username</p>
<h3 id="6-1-5-自动创建"><a href="#6-1-5-自动创建" class="headerlink" title="6.1.5. 自动创建"></a>6.1.5. 自动创建</h3><p>自动创建（Automated Builds）功能对于需要经常升级镜像内程序来说，十分方便。</p>
<p>有时候，用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。</p>
<p>而自动创建允许用户通过 Docker Hub 指定跟踪一个目标网站（目前支持 GitHub 或 BitBucket）上的项目，一旦项目发生新的提交或者创建新的标签（tag），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</p>
<p>要配置自动创建，包括如下的步骤：</p>
<p>创建并登录 Docker Hub，以及目标网站；</p>
<p>在目标网站中连接帐户到 Docker Hub；</p>
<p>在 Docker Hub 中 配置一个自动创建；</p>
<p>选取一个目标网站中的项目（需要含 Dockerfile）和分支；</p>
<p>指定 Dockerfile 的位置，并提交创建。</p>
<p>之后，可以在 Docker Hub 的 自动创建页面 中跟踪每次创建的状态。</p>
<h2 id="6-2-docker-私有仓库"><a href="#6-2-docker-私有仓库" class="headerlink" title="6.2.   docker 私有仓库"></a>6.2.   docker 私有仓库</h2><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p>
<p>本节介绍如何使用本地仓库。</p>
<p><a href="https://docs.docker.com/registry/spec/api/" target="_blank" rel="noopener">docker-registry</a> 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 <a href="https://github.com/docker/distribution" target="_blank" rel="noopener">docker-registry v2.x</a> 版本。</p>
<h3 id="6-2-1-安装运行-docker-registry"><a href="#6-2-1-安装运行-docker-registry" class="headerlink" title="6.2.1. 安装运行 docker-registry"></a>6.2.1. 安装运行 docker-registry</h3><p>你可以通过获取官方 registry 镜像来运行。</p>
<p>docker run -d -p 5000:5000 –restart=always –name registry registry</p>
<p>这将使用官方的 registry 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 /var/lib/registry 目录下。你可以通过 -v 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 /opt/data/registry 目录。</p>
<p>docker run -d \</p>
<p>  -p 5000:5000 \</p>
<p>  -v /opt/data/registry:/var/lib/registry \</p>
<p>  registry</p>
<h3 id="6-2-2-在私有仓库上传、搜索、下载镜像"><a href="#6-2-2-在私有仓库上传、搜索、下载镜像" class="headerlink" title="6.2.2. 在私有仓库上传、搜索、下载镜像"></a>6.2.2. 在私有仓库上传、搜索、下载镜像</h3><p>创建好私有仓库之后，就可以使用 docker tag 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 127.0.0.1:5000。</p>
<p>先在本机查看已有的镜像。</p>
<p>docker image ls</p>
<p>REPOSITORY      TAG    IMAGE ID      CREATED       VIRTUAL SIZE</p>
<p>ubuntu         latest   ba5877dc9bec    6 weeks ago     192.7 MB</p>
<p>使用 docker tag 将 ubuntu:latest 这个镜像标记为 127.0.0.1:5000/ubuntu:latest。</p>
<p>格式为 docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]。</p>
<p>docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest</p>
<p>docker image ls</p>
<p>REPOSITORY    TAG    IMAGE ID      CREATED       VIRTUAL SIZE</p>
<p>ubuntu      latest    ba5877dc9bec    6 weeks ago     192.7 MB</p>
<p>127.0.0.1:5000/ubuntu:latest  latest  ba5877dc9bec    6 weeks ago     192.7 MB</p>
<p>使用 docker push 上传标记的镜像。</p>
<p>docker push 127.0.0.1:5000/ubuntu:latest</p>
<p>用 curl 查看仓库中的镜像。</p>
<p>curl 127.0.0.1:5000/v2/_catalog</p>
<p>{“repositories”:[“ubuntu”]}</p>
<p>这里可以看到 {“repositories”:[“ubuntu”]}，表明镜像已经被成功上传了。</p>
<p>先删除已有镜像，再尝试从私有仓库中下载这个镜像。</p>
<p>docker image rm 127.0.0.1:5000/ubuntu:latest</p>
<p>docker pull 127.0.0.1:5000/ubuntu:latestdocker image ls</p>
<p>docker image ls</p>
<h3 id="6-2-3-注意事项"><a href="#6-2-3-注意事项" class="headerlink" title="6.2.3. 注意事项"></a>6.2.3. 注意事项</h3><p>如果你不想使用 127.0.0.1:5000 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 192.168.199.100:5000 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p>
<p>这是因为 Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 HTTPS 访问的私有仓库。</p>
<h4 id="6-2-3-1-Ubuntu-14-04-Debian-7-Wheezy"><a href="#6-2-3-1-Ubuntu-14-04-Debian-7-Wheezy" class="headerlink" title="6.2.3.1.   Ubuntu 14.04, Debian 7 Wheezy"></a>6.2.3.1.   Ubuntu 14.04, Debian 7 Wheezy</h4><p>对于使用 upstart 的系统而言，编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS 中增加如下内容：</p>
<p>DOCKER_OPTS=”–registry-mirror=<a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a> –insecure-registries=192.168.199.100:5000”</p>
<p>重新启动服务。</p>
<p>sudo service docker restart</p>
<h4 id="6-2-3-2-Ubuntu-16-04-Debian-8-centos-7"><a href="#6-2-3-2-Ubuntu-16-04-Debian-8-centos-7" class="headerlink" title="6.2.3.2.   Ubuntu 16.04+, Debian 8+, centos 7"></a>6.2.3.2.   Ubuntu 16.04+, Debian 8+, centos 7</h4><p>对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）</p>
<p>{</p>
<p> “registry-mirrors”: [</p>
<p>  “<a href="https://registry.docker-cn.com&quot;" target="_blank" rel="noopener">https://registry.docker-cn.com&quot;</a></p>
<p> ],</p>
<p> “insecure-registries”: [</p>
<p>  “192.168.199.100:5000”</p>
<p> ]</p>
<p>}</p>
<p>注意：该文件必须符合 json 规范，否则 Docker 将不能启动。</p>
<h3 id="6-2-4-其他"><a href="#6-2-4-其他" class="headerlink" title="6.2.4. 其他"></a>6.2.4. 其他</h3><p>对于 Docker for Windows 、 Docker for Mac 在设置中编辑 daemon.json 增加和上边一样的字符串即可。</p>
<h3 id="6-2-5-docker-registry-配置证书"><a href="#6-2-5-docker-registry-配置证书" class="headerlink" title="6.2.5. docker registry 配置证书"></a>6.2.5. docker registry 配置证书</h3><p>上一节我们搭建了一个具有基础功能的私有仓库，本小节我们来使用 Docker Compose 搭建一个拥有权限认证、TLS 的私有仓库。</p>
<p>新建一个文件夹，以下步骤均在该文件夹中进行。</p>
<h4 id="6-2-5-1-准备站点证书"><a href="#6-2-5-1-准备站点证书" class="headerlink" title="6.2.5.1.   准备站点证书"></a>6.2.5.1.   准备站点证书</h4><p>如果你拥有一个域名，国内各大云服务商均提供免费的站点证书。你也可以使用 openssl 自行签发证书。</p>
<p>这里假设我们将要搭建的私有仓库地址为 docker.domain.com，下面我们介绍使用 openssl 自行签发 docker.domain.com 的站点 SSL 证书。</p>
<p>第一步创建 CA 私钥。</p>
<p>openssl genrsa -out “root-ca.key” 4096</p>
<p>第二步利用私钥创建 CA 根证书请求文件。</p>
<p>openssl req \</p>
<p>​     -new -key “root-ca.key” \</p>
<p>​     -out “root-ca.csr” -sha256 \</p>
<p>​     -subj ‘/C=CN/ST=Shanxi/L=Datong/O=Your Company Name/CN=Your Company Name Docker Registry CA’</p>
<p>以上命令中 -subj 参数里的 /C 表示国家，如 CN；/ST 表示省；/L 表示城市或者地区；/O 表示组织名；/CN 通用名称。</p>
<p>第三步配置 CA 根证书，新建 root-ca.cnf。</p>
<p>[root_ca]</p>
<p>basicConstraints = critical,CA:TRUE,pathlen:1</p>
<p>keyUsage = critical, nonRepudiation, cRLSign, keyCertSign</p>
<p>subjectKeyIdentifier=hash</p>
<p>第四步签发根证书。</p>
<p>openssl x509 -req -days 3650 -in “root-ca.csr” \</p>
<p>​        -signkey “root-ca.key” -sha256 -out “root-ca.crt” \</p>
<p>​        -extfile “root-ca.cnf” -extensions \</p>
<p>​        root_ca</p>
<p>第五步生成站点 SSL 私钥。</p>
<p>openssl genrsa -out “docker.domain.com.key” 4096</p>
<p>第六步使用私钥生成证书请求文件。</p>
<p>openssl req -new -key “docker.domain.com.key” -out “site.csr” -sha256 \</p>
<p>​     -subj ‘/C=CN/ST=Shanxi/L=Datong/O=Your Company Name/CN=docker.domain.com’</p>
<p>第七步配置证书，新建 site.cnf 文件。</p>
<p>[server]</p>
<p>authorityKeyIdentifier=keyid,issuer</p>
<p>basicConstraints = critical,CA:FALSE</p>
<p>extendedKeyUsage=serverAuth</p>
<p>keyUsage = critical, digitalSignature, keyEncipherment</p>
<p>subjectAltName = DNS:docker.domain.com, IP:127.0.0.1</p>
<p>subjectKeyIdentifier=hash</p>
<p>第八步签署站点 SSL 证书。</p>
<p>openssl x509 -req -days 750 -in “site.csr” -sha256 \</p>
<p>  -CA “root-ca.crt” -CAkey “root-ca.key” -CAcreateserial \</p>
<p>  -out “docker.domain.com.crt” -extfile “site.cnf” -extensions server</p>
<p>这样已经拥有了 docker.domain.com 的网站 SSL 私钥 docker.domain.com.key 和 SSL 证书 docker.domain.com.crt。</p>
<p>新建 ssl 文件夹并将 docker.domain.com.key docker.domain.com.crt 这两个文件移入，删除其他文件。</p>
<h4 id="6-2-5-2-配置私有仓库"><a href="#6-2-5-2-配置私有仓库" class="headerlink" title="6.2.5.2.   配置私有仓库"></a>6.2.5.2.   配置私有仓库</h4><p>私有仓库默认的配置文件位于 /etc/docker/registry/config.yml，我们先在本地编辑 config.yml，之后挂载到容器中。</p>
<p>version: 0.1</p>
<p>log:</p>
<p> accesslog:</p>
<p>  disabled: true</p>
<p> level: debug</p>
<p> formatter: text</p>
<p> fields:</p>
<p>  service: registry</p>
<p>  environment: staging</p>
<p>storage:</p>
<p> delete:</p>
<p>  enabled: true</p>
<p> cache:</p>
<p>  blobdescriptor: inmemory</p>
<p> filesystem:</p>
<p>  rootdirectory: /var/lib/registry</p>
<p>auth:</p>
<p> htpasswd:</p>
<p>  realm: basic-realm</p>
<p>  path: /etc/docker/registry/auth/nginx.htpasswd</p>
<p>http:</p>
<p> addr: :443</p>
<p> host: <a href="https://docker.domain.com" target="_blank" rel="noopener">https://docker.domain.com</a></p>
<p> headers:</p>
<p>  X-Content-Type-Options: [nosniff]</p>
<p> http2:</p>
<p>  disabled: false</p>
<p> tls:</p>
<p>  certificate: /etc/docker/registry/ssl/docker.domain.com.crt</p>
<p>  key: /etc/docker/registry/ssl/docker.domain.com.key</p>
<p>health:</p>
<p> storagedriver:</p>
<p>  enabled: true</p>
<p>  interval: 10s</p>
<p>threshold: 3</p>
<h4 id="6-2-5-3-生成-http-认证文件"><a href="#6-2-5-3-生成-http-认证文件" class="headerlink" title="6.2.5.3.   生成 http 认证文件"></a>6.2.5.3.   生成 http 认证文件</h4><p>mkdir auth</p>
<p>docker run –rm \</p>
<p>  –entrypoint htpasswd \</p>
<p>  registry \</p>
<p>  -Bbn username password &gt; auth/nginx.htpasswd</p>
<p>将上面的 username password 替换为你自己的用户名和密码。</p>
<h4 id="6-2-5-4-编辑-docker-compose-yml"><a href="#6-2-5-4-编辑-docker-compose-yml" class="headerlink" title="6.2.5.4.   编辑 docker-compose.yml"></a>6.2.5.4.   编辑 docker-compose.yml</h4><p>version: ‘3’</p>
<p>services:</p>
<p> registry:</p>
<p>  image: registry</p>
<p>  ports:</p>
<p>   - “443:443”</p>
<p>  volumes:</p>
<p>   - ./:/etc/docker/registry</p>
<p>   - registry-data:/var/lib/registry</p>
<p>volumes:</p>
<p> registry-data:</p>
<h4 id="6-2-5-5-修改-hosts"><a href="#6-2-5-5-修改-hosts" class="headerlink" title="6.2.5.5.   修改 hosts"></a>6.2.5.5.   修改 hosts</h4><p>编辑 /etc/hosts</p>
<p>docker.domain.com 127.0.0.1</p>
<h4 id="6-2-5-6-启动"><a href="#6-2-5-6-启动" class="headerlink" title="6.2.5.6.   启动"></a>6.2.5.6.   启动</h4><p>docker-compose up -d</p>
<p>这样我们就搭建好了一个具有权限认证、TLS 的私有仓库，接下来我们测试其功能是否正常。</p>
<h4 id="6-2-5-7-测试私有仓库功能"><a href="#6-2-5-7-测试私有仓库功能" class="headerlink" title="6.2.5.7.   测试私有仓库功能"></a>6.2.5.7.   测试私有仓库功能</h4><p>登录到私有仓库。</p>
<p>docker login docker.domain.com</p>
<p>尝试推送、拉取镜像。</p>
<p>docker pull ubuntu:17.10</p>
<p>docker tag ubuntu:17.10 docker.domain.com/username/ubuntu:17.10</p>
<p>docker push docker.domain.com/username/ubuntu:17.10</p>
<p>docker image rm docker.domain.com/username/ubuntu:17.10</p>
<p>docker pull docker.domain.com/username/ubuntu:17.10</p>
<p>如果我们退出登录，尝试推送镜像。</p>
<p>docker logout docker.domain.com</p>
<p>docker push docker.domain.com/username/ubuntu:17.10</p>
<p>发现会提示没有登录，不能将镜像推送到私有仓库中。</p>
<h4 id="6-2-5-8-注意事项"><a href="#6-2-5-8-注意事项" class="headerlink" title="6.2.5.8.   注意事项"></a>6.2.5.8.   注意事项</h4><p>如果你本机占用了 443 端口，你可以配置 <a href="https://docs.docker.com/registry/recipes/nginx/" target="_blank" rel="noopener">Nginx 代理</a>，这里不再赘述。</p>
<h2 id="6-3-docker-企业级仓库-Harbor"><a href="#6-3-docker-企业级仓库-Harbor" class="headerlink" title="6.3.   docker 企业级仓库 Harbor"></a>6.3.   docker 企业级仓库 Harbor</h2><p>在学完 compose 后再来安装部署。</p>
<h1 id="7-docker-数据管理"><a href="#7-docker-数据管理" class="headerlink" title="7. docker 数据管理"></a>7. docker 数据管理</h1><p>这一章介绍如何在 Docker 内部以及容器之间管理数据，在容器中管理数据主要有两种方式：</p>
<p>l 数据卷（Volumes）</p>
<p>l 挂载主机目录 (Bind mounts)</p>
<h2 id="7-1-docker-数据卷"><a href="#7-1-docker-数据卷" class="headerlink" title="7.1.   docker 数据卷"></a>7.1.   docker 数据卷</h2><p>数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<p>l 数据卷 可以在容器之间共享和重用</p>
<p>l 对 数据卷 的修改会立马生效</p>
<p>l 对 数据卷 的更新，不会影响镜像</p>
<p>l 数据卷 默认会一直存在，即使容器被删除</p>
<p>注意：数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 数据卷。</p>
<h3 id="7-1-1-选择-v-还是-–mount-参数"><a href="#7-1-1-选择-v-还是-–mount-参数" class="headerlink" title="7.1.1. 选择 -v 还是 -–mount 参数"></a>7.1.1. 选择 -v 还是 -–mount 参数</h3><p>Docker 新用户应该选择 –mount 参数，经验丰富的 Docker 使用者对 -v 或者 –volume 已经很熟悉了，但是推荐使用 –mount 参数。</p>
<h3 id="7-1-2-创建一个数据卷"><a href="#7-1-2-创建一个数据卷" class="headerlink" title="7.1.2. 创建一个数据卷"></a>7.1.2. 创建一个数据卷</h3><p>docker volume create my-vol</p>
<p>查看所有的 数据卷</p>
<p>docker volume ls</p>
<p>在主机里使用以下命令可以查看指定 数据卷 的信息</p>
<p>docker volume inspect my-vol</p>
<p> [</p>
<p>  {</p>
<p>​    “Driver”: “local”,</p>
<p>​    “Labels”: {},</p>
<p>​    “Mountpoint”: “/var/lib/docker/volumes/my-vol/_data”,</p>
<p>​    “Name”: “my-vol”,</p>
<p>​    “Options”: {},</p>
<p>​    “Scope”: “local”</p>
<p>  }</p>
<p>]</p>
<h3 id="7-1-3-启动一个挂载数据卷的容器"><a href="#7-1-3-启动一个挂载数据卷的容器" class="headerlink" title="7.1.3. 启动一个挂载数据卷的容器"></a>7.1.3. 启动一个挂载数据卷的容器</h3><p>在用 docker run 命令的时候，使用 –mount 标记来将 数据卷 挂载到容器里。在一次 docker run 中可以挂载多个 数据卷。</p>
<p>下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。</p>
<p>docker run -d -P \</p>
<p>  –name web \</p>
<p>  # -v my-vol:/wepapp \</p>
<p>  –mount source=my-vol,target=/webapp \</p>
<p>  training/webapp \</p>
<p>  python app.py</p>
<h3 id="7-1-4-查看数据卷的具体信息"><a href="#7-1-4-查看数据卷的具体信息" class="headerlink" title="7.1.4. 查看数据卷的具体信息"></a>7.1.4. 查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 web 容器的信息</p>
<p>docker inspect web</p>
<p>数据卷 信息在 “Mounts” Key 下面</p>
<p>“Mounts”: [</p>
<p>  {</p>
<p>​    “Type”: “volume”,</p>
<p>​    “Name”: “my-vol”,</p>
<p>​    “Source”: “/var/lib/docker/volumes/my-vol/_data”,</p>
<p>​    “Destination”: “/app”,</p>
<p>​    “Driver”: “local”,</p>
<p>​    “Mode”: “”,</p>
<p>​    “RW”: true,</p>
<p>​    “Propagation”: “”</p>
<p>  }</p>
<p>],</p>
<h3 id="7-1-5-删除数据卷"><a href="#7-1-5-删除数据卷" class="headerlink" title="7.1.5. 删除数据卷"></a>7.1.5. 删除数据卷</h3><p>docker volume rm my-vol</p>
<p>数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。</p>
<p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p>
<p>docker volume prune</p>
<h2 id="7-2-监听主机目录"><a href="#7-2-监听主机目录" class="headerlink" title="7.2.   监听主机目录"></a>7.2.   监听主机目录</h2><h3 id="7-2-1-v-还是-–mount-参数"><a href="#7-2-1-v-还是-–mount-参数" class="headerlink" title="7.2.1. -v 还是 -–mount 参数"></a>7.2.1. -v 还是 -–mount 参数</h3><p>Docker 新用户应该选择 –mount 参数，经验丰富的 Docker 使用者对 -v 或者 –volume 已经很熟悉了，但是推荐使用 –mount 参数。</p>
<h3 id="7-2-2-挂载一个主机目录作为数据卷"><a href="#7-2-2-挂载一个主机目录作为数据卷" class="headerlink" title="7.2.2. 挂载一个主机目录作为数据卷"></a>7.2.2. 挂载一个主机目录作为数据卷</h3><p>使用 –mount 标记可以指定挂载一个本地主机的目录到容器中去。</p>
<p>docker run -d -P \</p>
<p>  –name web \</p>
<p>  # -v /src/webapp:/opt/webapp \</p>
<p>  –mount type=bind,source=/src/webapp,target=/opt/webapp \</p>
<p>  training/webapp \</p>
<p>  python app.py</p>
<p>上面的命令加载主机的 /src/webapp 目录到容器的 /opt/webapp目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 –mount 参数时如果本地目录不存在，Docker 会报错。</p>
<p>Docker 挂载主机目录的默认权限是 读写，用户也可以通过增加 readonly 指定为 只读。</p>
<p>docker run -d -P \</p>
<p>  –name web \</p>
<p>  # -v /src/webapp:/opt/webapp:ro \</p>
<p>  –mount type=bind,source=/src/webapp,target=/opt/webapp,readonly \</p>
<p>  training/webapp \</p>
<p>  python app.py</p>
<p>加了 readonly 之后，就挂载为 只读 了。如果你在容器内 /opt/webapp 目录新建文件，会显示如下错误</p>
<p>/opt/webapp # touch new.txt</p>
<p>touch: new.txt: Read-only file system</p>
<h3 id="7-2-3-查看数据卷的具体信息"><a href="#7-2-3-查看数据卷的具体信息" class="headerlink" title="7.2.3. 查看数据卷的具体信息"></a>7.2.3. 查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 web 容器的信息</p>
<p>docker inspect web</p>
<p>挂载主机目录 的配置信息在 “Mounts” Key 下面</p>
<p>“Mounts”: [</p>
<p>  {</p>
<p>​    “Type”: “bind”,</p>
<p>​    “Source”: “/src/webapp”,</p>
<p>​    “Destination”: “/opt/webapp”,</p>
<p>​    “Mode”: “”,</p>
<p>​    “RW”: true,</p>
<p>​    “Propagation”: “rprivate”</p>
<p>  }</p>
<p>],</p>
<h3 id="7-2-4-挂载一个本地主机文件作为数据卷"><a href="#7-2-4-挂载一个本地主机文件作为数据卷" class="headerlink" title="7.2.4. 挂载一个本地主机文件作为数据卷"></a>7.2.4. 挂载一个本地主机文件作为数据卷</h3><p>–mount 标记也可以从主机挂载单个文件到容器中</p>
<p>docker run –rm -it \</p>
<p>  # -v $HOME/.bash_history:/root/.bash_history \</p>
<p>  –mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \</p>
<p>  ubuntu:17.10 \</p>
<p>  bash</p>
<p>root@2affd44b4667:/# history</p>
<p>1 ls</p>
<p>2 diskutil list </p>
<p>这样就可以记录在容器输入过的命令了。</p>
<h1 id="8-docker-网络配置"><a href="#8-docker-网络配置" class="headerlink" title="8. docker 网络配置"></a>8. docker 网络配置</h1><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务</p>
<h2 id="8-1-Docker-外部访问容器"><a href="#8-1-Docker-外部访问容器" class="headerlink" title="8.1.   Docker 外部访问容器"></a>8.1.   Docker 外部访问容器</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。</p>
<p>当使用 -P 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。</p>
<p>使用 docker container ls 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。</p>
<p>docker run -d -P training/webapp python app.py</p>
<p>docker container ls -l</p>
<p>同样的，可以通过 docker logs 命令来查看应用的信息。</p>
<p>docker logs -f nostalgic_morse</p>
<p>* Running on <a href="http://0.0.0.0:5000/" target="_blank" rel="noopener">http://0.0.0.0:5000/</a></p>
<p>10.0.2.2 - - [23/May/2014 20:16:31] “GET / HTTP/1.1” 200 -</p>
<p>10.0.2.2 - - [23/May/2014 20:16:31] “GET /favicon.ico HTTP/1.1” 404 -</p>
<p>-p 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort。</p>
<h3 id="8-1-1-映射所有接口地址"><a href="#8-1-1-映射所有接口地址" class="headerlink" title="8.1.1. 映射所有接口地址"></a>8.1.1. 映射所有接口地址</h3><p>使用 hostPort:containerPort 格式本地的 5000 端口映射到容器的 5000 端口，可以执行</p>
<p>docker run -d -p 5000:5000 training/webapp python app.py</p>
<p>此时默认会绑定本地所有接口上的所有地址。</p>
<h3 id="8-1-2-映射到指定地址的指定端口"><a href="#8-1-2-映射到指定地址的指定端口" class="headerlink" title="8.1.2. 映射到指定地址的指定端口"></a>8.1.2. 映射到指定地址的指定端口</h3><p>可以使用 ip:hostPort:containerPort 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p>
<p>docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</p>
<h3 id="8-1-3-映射到指定地址的任意端口"><a href="#8-1-3-映射到指定地址的任意端口" class="headerlink" title="8.1.3. 映射到指定地址的任意端口"></a>8.1.3. 映射到指定地址的任意端口</h3><p>使用 ip::containerPort 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p>
<p>docker run -d -p 127.0.0.1::5000 training/webapp python app.py</p>
<p>还可以使用 udp 标记来指定 udp 端口</p>
<p>docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</p>
<h3 id="8-1-4-查看映射端口配置"><a href="#8-1-4-查看映射端口配置" class="headerlink" title="8.1.4. 查看映射端口配置"></a>8.1.4. 查看映射端口配置</h3><p>使用 docker port 来查看当前映射的端口配置，也可以查看到绑定的地址</p>
<p>docker port nostalgic_morse 5000</p>
<p>注意：</p>
<p>l 容器有自己的内部网络和 ip 地址（使用 docker inspect 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</p>
<p>l -p 标记可以多次使用来绑定多个端口</p>
<p>例如</p>
<p>docker run -d \</p>
<p>  -p 5000:5000 \</p>
<p>  -p 3000:80 \</p>
<p>  training/webapp \</p>
<p>  python app.py</p>
<h2 id="8-2-Docker-容器互连"><a href="#8-2-Docker-容器互连" class="headerlink" title="8.2.   Docker 容器互连"></a>8.2.   Docker 容器互连</h2><p>如果你之前有 Docker 使用经验，你可能已经习惯了使用 –link 参数来使容器互联。</p>
<p>随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 –link 参数。</p>
<h3 id="8-2-1-新建网络"><a href="#8-2-1-新建网络" class="headerlink" title="8.2.1. 新建网络"></a>8.2.1. 新建网络</h3><p>下面先创建一个新的 Docker 网络。</p>
<p>docker network create -d bridge my-net</p>
<p>-d 参数指定 Docker 网络类型，有 bridge overlay。其中 overlay 网络类型用于 Swarm mode，在本小节中你可以忽略它。</p>
<h3 id="8-2-2-连接容器"><a href="#8-2-2-连接容器" class="headerlink" title="8.2.2. 连接容器"></a>8.2.2. 连接容器</h3><p>运行一个容器并连接到新建的 my-net 网络</p>
<p>docker run -it –rm –name busybox1 –network my-net busybox sh</p>
<p>打开新的终端，再运行一个容器并加入到 my-net 网络</p>
<p>docker run -it –rm –name busybox2 –network my-net busybox sh</p>
<p>再打开一个新的终端查看容器信息</p>
<p>docker container ls</p>
<p>CONTAINER ID  IMAGE  COMMAND  CREATED   STATUS   PORTS        NAMES</p>
<p>b47060aca56b busybox  “sh”    11 minutes ago   Up 11 minutes  busybox2           </p>
<p>8720575823ec  busybox  “sh”    16 minutes ago   Up 16 minutes   busybox1           </p>
<p>下面通过 ping 来证明 busybox1 容器和 busybox2 容器建立了互联关系。</p>
<p>在 busybox1 容器输入以下命令</p>
<p>/ # ping busybox2</p>
<p>PING busybox2 (172.19.0.3): 56 data bytes</p>
<p>64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms</p>
<p>64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms</p>
<p>用 ping 来测试连接 busybox2 容器，它会解析成 172.19.0.3。</p>
<p>同理在 busybox2 容器执行 ping busybox1，也会成功连接到。</p>
<p>/ # ping busybox1</p>
<p>PING busybox1 (172.19.0.2): 56 data bytes</p>
<p>64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms</p>
<p>64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms</p>
<p>这样，busybox1 容器和 busybox2 容器建立了互联关系。</p>
<h3 id="8-2-3-Docker-Compose"><a href="#8-2-3-Docker-Compose" class="headerlink" title="8.2.3. Docker Compose"></a>8.2.3. Docker Compose</h3><p>如果你有多个容器之间需要互相连接，推荐使用 Docker Compose。</p>
<h2 id="8-3-Docker-配置-DNS"><a href="#8-3-Docker-配置-DNS" class="headerlink" title="8.3.   Docker 配置 DNS"></a>8.3.   Docker 配置 DNS</h2><p>如何自定义配置容器的主机名和 DNS 呢？秘诀就是 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。</p>
<p>在容器中使用 mount 命令可以看到挂载信息：</p>
<p>mount</p>
<p>/dev/disk/by-uuid/1fec…ebdf on /etc/hostname type ext4 …</p>
<p>/dev/disk/by-uuid/1fec…ebdf on /etc/hosts type ext4 …</p>
<p>tmpfs on /etc/resolv.conf type tmpfs …</p>
<p>这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 /etc/resolv.conf 文件立刻得到更新。</p>
<p>配置全部容器的 DNS ，也可以在 /etc/docker/daemon.json 文件中增加以下内容来设置。</p>
<p>{</p>
<p> “dns” : [</p>
<p>  “114.114.114.114”,</p>
<p>  “8.8.8.8”</p>
<p> ]</p>
<p>}</p>
<p>这样每次启动的容器 DNS 自动配置为 114.114.114.114 和 8.8.8.8。使用以下命令来证明其已经生效。</p>
<p>docker run -it –rm ubuntu:17.10 cat etc/resolv.conf</p>
<p>nameserver 114.114.114.114</p>
<p>nameserver 8.8.8.8</p>
<p>如果用户想要手动指定容器的配置，可以在使用 docker run 命令启动容器时加入如下参数：</p>
<p>-h HOSTNAME 或者 –hostname=HOSTNAME 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。但它在容器外部看不到，既不会在 docker container ls 中显示，也不会在其他的容器的 /etc/hosts 看到。</p>
<p>–dns=IP_ADDRESS 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</p>
<p>–dns-search=DOMAIN 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。</p>
<p>注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 /etc/resolv.conf 来配置容器。</p>
<h1 id="9-docker-高级网络配置"><a href="#9-docker-高级网络配置" class="headerlink" title="9. docker 高级网络配置"></a>9. docker 高级网络配置</h1><p>注意：本章属于 Docker 高级配置，如果您是初学者，您可以暂时跳过本章节，直接学习 Docker Compose 一节。</p>
<p>本章将介绍 Docker 的一些高级网络配置和选项。</p>
<p>当 Docker 启动时，会自动在主机上创建一个 docker0 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>
<p>同时，Docker 随机分配一个本地未占用的私有网段（在 RFC1918 中定义）中的一个地址给 docker0 接口。比如典型的 172.17.42.1，掩码为 255.255.0.0。此后启动的容器内的网口也会自动分配一个同一网段（172.17.0.0/16）的地址。</p>
<p>当创建一个 Docker 容器的时候，同时会创建了一对 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 eth0；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头（例如 vethAQI2QT）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p>
<p>Docker 网络</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134944.gif" alt="Docker 网络"></p>
<p>接下来的部分将介绍在一些场景中，Docker 所有的网络定制配置。以及通过 Linux 命令来调整、补充、甚至替换 Docker 默认的网络配置。</p>
<h2 id="9-1-快速配置指南"><a href="#9-1-快速配置指南" class="headerlink" title="9.1.   快速配置指南"></a>9.1.   快速配置指南</h2><p>下面是一个跟 Docker 网络相关的命令列表。</p>
<p>其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效。</p>
<p>l -b BRIDGE 或 –bridge=BRIDGE 指定容器挂载的网桥</p>
<p>l –bip=CIDR 定制 docker0 的掩码</p>
<p>l -H SOCKET… 或 –host=SOCKET… Docker 服务端接收命令的通道</p>
<p>l –icc=true|false 是否支持容器之间进行通信</p>
<p>l –ip-forward=true|false 请看下文容器之间的通信</p>
<p>l –iptables=true|false 是否允许 Docker 添加 iptables 规则</p>
<p>l –mtu=BYTES 容器网络中的 MTU</p>
<p>下面2个命令选项既可以在启动服务时指定，也可以在启动容器时指定。在 Docker 服务启动的时候指定则会成为默认值，后面执行 docker run 时可以覆盖设置的默认值。</p>
<p>l –dns=IP_ADDRESS… 使用指定的DNS服务器</p>
<p>l –dns-search=DOMAIN… 指定DNS搜索域</p>
<p>最后这些选项只有在 docker run 执行时使用，因为它是针对容器的特性内容。</p>
<p>l -h HOSTNAME 或 –hostname=HOSTNAME 配置容器主机名</p>
<p>l –link=CONTAINER_NAME:ALIAS 添加到另一个容器的连接</p>
<p>l –net=bridge|none|container:NAME_or_ID|host 配置容器的桥接模式</p>
<p>l -p SPEC 或 –publish=SPEC 映射容器端口到宿主主机</p>
<p>l -P or –publish-all=true|false 映射容器所有端口到宿主主机</p>
<h2 id="9-2-容器访问控制"><a href="#9-2-容器访问控制" class="headerlink" title="9.2.   容器访问控制"></a>9.2.   容器访问控制</h2><p>容器的访问控制，主要通过 Linux 上的 iptables 防火墙来进行管理和实现。iptables 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。</p>
<h3 id="9-2-1-容器访问外部网络"><a href="#9-2-1-容器访问外部网络" class="headerlink" title="9.2.1. 容器访问外部网络"></a>9.2.1. 容器访问外部网络</h3><p>容器要想访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。</p>
<p>sysctl net.ipv4.ip_forward</p>
<p>net.ipv4.ip_forward = 1</p>
<p>如果为 0，说明没有开启转发，则需要手动打开。</p>
<p>sysctl -w net.ipv4.ip_forward=1</p>
<p>如果在启动 Docker 服务的时候设定 –ip-forward=true, Docker 就会自动设定系统的 ip_forward 参数为 1。</p>
<h3 id="9-2-2-容器之间访问"><a href="#9-2-2-容器之间访问" class="headerlink" title="9.2.2. 容器之间访问"></a>9.2.2. 容器之间访问</h3><p>容器之间相互访问，需要两方面的支持。</p>
<p>l 容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 docker0 网桥上。</p>
<p>l 本地系统的防火墙软件 – iptables 是否允许通过。</p>
<p><strong>访问所有端口</strong></p>
<p>当启动 Docker 服务时候，默认会添加一条转发策略到 iptables 的 FORWARD 链上。策略为通过（ACCEPT）还是禁止（DROP）取决于配置–icc=true（缺省值）还是 –icc=false。当然，如果手动指定 –iptables=false 则不会添加 iptables 规则。</p>
<p>可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 /etc/default/docker 文件中配置 DOCKER_OPTS=–icc=false 来禁止它。</p>
<p><strong>访问指定端口</strong></p>
<p>在通过 -icc=false 关闭网络访问后，还可以通过 –link=CONTAINER_NAME:ALIAS 选项来访问容器的开放端口。</p>
<p>例如，在启动 Docker 服务时，可以同时使用 icc=false –iptables=true 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 iptables 规则。</p>
<p>此时，系统中的 iptables 规则可能是类似</p>
<p>sudo iptables -nL</p>
<p>…</p>
<p>Chain FORWARD (policy ACCEPT)</p>
<p>target   prot opt source        destination</p>
<p>DROP    all – 0.0.0.0/0      0.0.0.0/0</p>
<p>…</p>
<p>之后，启动容器（docker run）时使用 –link=CONTAINER_NAME:ALIAS 选项。Docker 会在 iptable 中为 两个容器分别添加一条 ACCEPT 规则，允许相互访问开放的端口（取决于 Dockerfile 中的 EXPOSE 指令）。</p>
<p>当添加了 –link=CONTAINER_NAME:ALIAS 选项后，添加了 iptables 规则。</p>
<p>sudo iptables -nL</p>
<p>Chain FORWARD (policy ACCEPT)</p>
<p>target   prot opt source        destination</p>
<p>ACCEPT   tcp – 172.17.0.2      172.17.0.3      tcp spt:80</p>
<p>ACCEPT   tcp – 172.17.0.3      172.17.0.2      tcp dpt:80</p>
<p>DROP    all – 0.0.0.0/0      0.0.0.0/0</p>
<p>注意：–link=CONTAINER_NAME:ALIAS 中的 CONTAINER_NAME 目前必须是 Docker 分配的名字，或使用 –name 参数指定的名字。主机名则不会被识别。</p>
<h2 id="9-3-端口映射实现"><a href="#9-3-端口映射实现" class="headerlink" title="9.3.   端口映射实现"></a>9.3.   端口映射实现</h2><p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。</p>
<h3 id="9-3-1-容器访问外部实现"><a href="#9-3-1-容器访问外部实现" class="headerlink" title="9.3.1. 容器访问外部实现"></a>9.3.1. 容器访问外部实现</h3><p>容器所有到外部网络的连接，源地址都会被 NAT 成本地系统的 IP 地址。这是使用 iptables 的源地址伪装操作实现的。</p>
<p>查看主机的 NAT 规则。</p>
<p>sudo iptables -t nat -nL</p>
<p>Chain POSTROUTING (policy ACCEPT)</p>
<p>target   prot opt source        destination</p>
<p>MASQUERADE all – 172.17.0.0/16    !172.17.0.0/16</p>
<p>…</p>
<p>其中，上述规则将所有源地址在 172.17.0.0/16 网段，目标地址为其他网段（外部网络）的流量动态伪装为从系统网卡发出。MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。</p>
<h3 id="9-3-2-外部访问容器实现"><a href="#9-3-2-外部访问容器实现" class="headerlink" title="9.3.2. 外部访问容器实现"></a>9.3.2. 外部访问容器实现</h3><p>容器允许外部访问，可以在 docker run 时候通过 -p 或 -P 参数来启用。</p>
<p>不管用那种办法，其实也是在本地的 iptable 的 nat 表中添加相应的规则。</p>
<p>使用 -P 时：</p>
<p>iptables -t nat -nL</p>
<p>Chain DOCKER (2 references)</p>
<p>target   prot opt source        destination</p>
<p>DNAT    tcp – 0.0.0.0/0      0.0.0.0/0      tcp dpt:49153 to:172.17.0.2:80</p>
<p>使用 -p 80:80 时：</p>
<p>iptables -t nat -nL</p>
<p>Chain DOCKER (2 references)</p>
<p>target   prot opt source        destination</p>
<p>DNAT    tcp – 0.0.0.0/0      0.0.0.0/0      tcp dpt:80 to:172.17.0.2:80</p>
<p>注意：</p>
<p>l 这里的规则映射了 0.0.0.0，意味着将接受主机来自所有接口的流量。用户可以通过 -p IP:host_port:container_port 或 -p IP::port 来指定允许访问容器的主机上的 IP、接口等，以制定更严格的规则。</p>
<p>l 如果希望永久绑定到某个固定的 IP 地址，可以在 Docker 配置文件 /etc/docker/daemon.json 中添加如下内容。</p>
<p>{</p>
<p> “ip”: “0.0.0.0”</p>
<p>}</p>
<h2 id="9-4-配置-docker0-网桥"><a href="#9-4-配置-docker0-网桥" class="headerlink" title="9.4.   配置 docker0 网桥"></a>9.4.   配置 docker0 网桥</h2><p>Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p>
<p>Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信，它还给出了 MTU（接口允许接收的最大传输单元），通常是 1500 Bytes，或宿主主机网络路由上支持的默认值。这些值都可以在服务启动的时候进行配置。</p>
<p>l –bip=CIDR IP 地址加掩码格式，例如 192.168.1.5/24</p>
<p>l –mtu=BYTES 覆盖默认的 Docker mtu 配置</p>
<p>也可以在配置文件中配置 DOCKER_OPTS，然后重启服务。</p>
<p>由于目前 Docker 网桥是 Linux 网桥，用户可以使用 brctl show 来查看网桥和端口连接信息。</p>
<p>sudo brctl show</p>
<p>bridge name  bridge id  STP enabled     interfaces</p>
<p>docker0   8000.3a1d7362b4ee no veth65f9  vethdda6</p>
<p>*注：brctl 命令在 Debian、Ubuntu 中可以使用 sudo apt-get install bridge-utils 来安装。</p>
<p>每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 docker0 接口的 IP 作为所有容器的默认网关。</p>
<p>sudo docker run -i -t –rm base /bin/bash</p>
<p>ip addr show eth0</p>
<p>24: eth0: &lt;BROADCAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</p>
<p>  link/ether 32:6f:e0:35:57:91 brd ff:ff:ff:ff:ff:ff</p>
<p>  inet 172.17.0.3/16 scope global eth0</p>
<p>​    valid_lft forever preferred_lft forever</p>
<p>  inet6 fe80::306f:e0ff:fe35:5791/64 scope link</p>
<p>​    valid_lft forever preferred_lft forever</p>
<p>ip route</p>
<p>default via 172.17.42.1 dev eth0</p>
<p>172.17.0.0/16 dev eth0 proto kernel scope link src 172.17.0.3</p>
<h2 id="9-5-自定义网桥"><a href="#9-5-自定义网桥" class="headerlink" title="9.5.   自定义网桥"></a>9.5.   自定义网桥</h2><p>除了默认的 docker0 网桥，用户也可以指定网桥来连接各个容器。</p>
<p>在启动 Docker 服务的时候，使用 -b BRIDGE或–bridge=BRIDGE 来指定使用的网桥。</p>
<p>如果服务已经运行，那需要先停止服务，并删除旧的网桥。</p>
<p>sudo systemctl stop docker</p>
<p>sudo ip link set dev docker0 down</p>
<p>sudo brctl delbr docker0</p>
<p>然后创建一个网桥 bridge0。</p>
<p>sudo brctl addbr bridge0</p>
<p>sudo ip addr add 192.168.5.1/24 dev bridge0</p>
<p>sudo ip link set dev bridge0 up</p>
<p>查看确认网桥创建并启动。</p>
<p>ip addr show bridge0</p>
<p>4: bridge0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state UP group default</p>
<p>  link/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff</p>
<p>  inet 192.168.5.1/24 scope global bridge0</p>
<p>​    valid_lft forever preferred_lft forever</p>
<p>在 Docker 配置文件 /etc/docker/daemon.json 中添加如下内容，即可将 Docker 默认桥接到创建的网桥上。</p>
<p>{</p>
<p> “bridge”: “bridge0”</p>
<p>}</p>
<p>启动 Docker 服务。</p>
<p>新建一个容器，可以看到它已经桥接到了 bridge0 上。</p>
<p>可以继续用 brctl show 命令查看桥接的信息。另外，在容器中可以使用 ip addr 和 ip route 命令来查看 IP 地址配置和路由信息。</p>
<h2 id="9-6-工具和示例"><a href="#9-6-工具和示例" class="headerlink" title="9.6.   工具和示例"></a>9.6.   工具和示例</h2><p>在介绍自定义网络拓扑之前，你可能会对一些外部工具和例子感兴趣：</p>
<h3 id="9-6-1-pipework"><a href="#9-6-1-pipework" class="headerlink" title="9.6.1. pipework"></a>9.6.1. pipework</h3><p>Jérôme Petazzoni 编写了一个叫 <a href="https://github.com/jpetazzo/pipework" target="_blank" rel="noopener">pipework</a> 的 shell 脚本，可以帮助用户在比较复杂的场景中完成容器的连接。</p>
<h3 id="9-6-2-playground"><a href="#9-6-2-playground" class="headerlink" title="9.6.2. playground"></a>9.6.2. playground</h3><p>Brandon Rhodes 创建了一个提供完整的 Docker 容器网络拓扑管理的 <a href="https://github.com/brandon-rhodes/fopnp/tree/m/playground" target="_blank" rel="noopener">Python库</a>，包括路由、NAT 防火墙；以及一些提供 HTTP, SMTP, POP, IMAP, Telnet, SSH, FTP 的服务器。</p>
<h2 id="9-7-编辑网络配置文件"><a href="#9-7-编辑网络配置文件" class="headerlink" title="9.7.   编辑网络配置文件"></a>9.7.   编辑网络配置文件</h2><p>Docker 1.2.0 开始支持在运行中的容器里编辑 /etc/hosts, /etc/hostname 和 /etc/resolv.conf 文件。</p>
<p>但是这些修改是临时的，只在运行的容器中保留，容器终止或重启后并不会被保存下来。也不会被 docker commit 提交。</p>
<h2 id="9-8-实例：创建一个点到点连接"><a href="#9-8-实例：创建一个点到点连接" class="headerlink" title="9.8.   实例：创建一个点到点连接"></a>9.8.   实例：创建一个点到点连接</h2><p>默认情况下，Docker 会将所有容器连接到由 docker0 提供的虚拟子网中。</p>
<p>用户有时候需要两个容器之间可以直连通信，而不用通过主机网桥进行桥接。</p>
<p>解决办法很简单：创建一对 peer 接口，分别放到两个容器中，配置成点到点链路类型即可。</p>
<p>首先启动 2 个容器：</p>
<p>docker run -i -t –rm –net=none base /bin/bash</p>
<p>docker run -i -t –rm –net=none base /bin/bash</p>
<p>找到进程号，然后创建网络命名空间的跟踪文件。</p>
<p>docker inspect -f ‘{.State.Pid}’ 1f1f4c1f931a</p>
<p>2989</p>
<p>docker inspect -f ‘{.State.Pid}’ 12e343489d2f</p>
<p>3004</p>
<p>sudo mkdir -p /var/run/netns</p>
<p>sudo ln -s /proc/2989/ns/net /var/run/netns/2989</p>
<p>sudo ln -s /proc/3004/ns/net /var/run/netns/3004</p>
<p>创建一对 peer 接口，然后配置路由</p>
<p>sudo ip link add A type veth peer name B</p>
<p>sudo ip link set A netns 2989</p>
<p>sudo ip netns exec 2989 ip addr add 10.1.1.1/32 dev A</p>
<p>sudo ip netns exec 2989 ip link set A up</p>
<p>sudo ip netns exec 2989 ip route add 10.1.1.2/32 dev A</p>
<p>sudo ip link set B netns 3004</p>
<p>sudo ip netns exec 3004 ip addr add 10.1.1.2/32 dev B</p>
<p>sudo ip netns exec 3004 ip link set B up</p>
<p>sudo ip netns exec 3004 ip route add 10.1.1.1/32 dev B</p>
<p>现在这 2 个容器就可以相互 ping 通，并成功建立连接。点到点链路不需要子网和子网掩码。</p>
<p>此外，也可以不指定 –net=none 来创建点到点链路。这样容器还可以通过原先的网络来通信。</p>
<p>利用类似的办法，可以创建一个只跟主机通信的容器。但是一般情况下，更推荐使用 –icc=false 来关闭容器之间的通信。</p>
<h1 id="10-docker-三剑客-compose"><a href="#10-docker-三剑客-compose" class="headerlink" title="10.  docker 三剑客 compose"></a>10.  docker 三剑客 compose</h1><p>Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速的部署分布式应用。</p>
<h2 id="10-1-docker-compose-简介"><a href="#10-1-docker-compose-简介" class="headerlink" title="10.1. docker compose 简介"></a>10.1. docker compose 简介</h2><p>Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 OpenStack 中的 Heat 十分类似。</p>
<p>其代码目前在 <a href="https://github.com/docker/compose" target="_blank" rel="noopener">https://github.com/docker/compose</a> 上开源。</p>
<p>Compose 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>
<p>通过第一部分中的介绍，我们知道使用一个 Dockerfile 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>
<p>Compose 恰好满足了这样的需求。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p>Compose 中有两个重要的概念：</p>
<p>l 服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</p>
<p>l 项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</p>
<p>Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>
<p>Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。</p>
<h2 id="10-2-docker-compose-安装和卸载"><a href="#10-2-docker-compose-安装和卸载" class="headerlink" title="10.2. docker compose 安装和卸载"></a>10.2. docker compose 安装和卸载</h2><p>Compose 支持 Linux、macOS、Windows 10 三大平台。</p>
<p>Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。</p>
<p>前两种方式是传统方式，适合本地环境下安装使用；最后一种方式则不破坏系统环境，更适合云计算场景。</p>
<p>Docker for Mac 、Docker for Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用。</p>
<p>docker-compose –version</p>
<p>Linux 系统请使用以下介绍的方法安装。</p>
<h3 id="10-2-1-二进制包"><a href="#10-2-1-二进制包" class="headerlink" title="10.2.1.    二进制包"></a>10.2.1.    二进制包</h3><p>在 Linux 上的也安装十分简单，从 官方 <a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">GitHub Release</a> 处直接下载编译好的二进制文件即可。</p>
<p>例如，在 Linux 64 位系统上直接下载对应的二进制包。</p>
<p>sudo curl -L <a href="https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname" target="_blank" rel="noopener">https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname</a> -s<code>-</code>uname -m` &gt; /usr/local/bin/docker-compose</p>
<p>sudo chmod +x /usr/local/bin/docker-compose</p>
<h3 id="10-2-2-PIP-安装"><a href="#10-2-2-PIP-安装" class="headerlink" title="10.2.2.    PIP 安装"></a>10.2.2.    PIP 安装</h3><p>注： x86_64 架构的 Linux 建议按照上边的方法下载二进制包进行安装，如果您计算机的架构是 ARM (例如，树莓派)，再使用 pip 安装。</p>
<p>这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。</p>
<p>执行安装命令：</p>
<p>sudo pip install -U docker-compose</p>
<p>可以看到类似如下输出，说明安装成功。</p>
<p>Collecting docker-compose</p>
<p> Downloading docker-compose-1.17.1.tar.gz (149kB): 149kB downloaded</p>
<p>…</p>
<p>Successfully installed docker-compose cached-property requests texttable websocket-client docker-py dockerpty six enum34 backports.ssl-match-hostname ipaddress</p>
<h3 id="10-2-3-bash-补全命令"><a href="#10-2-3-bash-补全命令" class="headerlink" title="10.2.3.    bash 补全命令"></a>10.2.3.    bash 补全命令</h3><p>curl -L <a href="https://raw.githubusercontent.com/docker/compose/1.8.0/contrib/completion/bash/docker-compose" target="_blank" rel="noopener">https://raw.githubusercontent.com/docker/compose/1.8.0/contrib/completion/bash/docker-compose</a> &gt; /etc/bash_completion.d/docker-compose</p>
<h3 id="10-2-4-容器中执行"><a href="#10-2-4-容器中执行" class="headerlink" title="10.2.4.    容器中执行"></a>10.2.4.    容器中执行</h3><p>Compose 既然是一个 Python 应用，自然也可以直接用容器来执行它。</p>
<p>curl -L <a href="https://github.com/docker/compose/releases/download/1.8.0/run.sh" target="_blank" rel="noopener">https://github.com/docker/compose/releases/download/1.8.0/run.sh</a> &gt; /usr/local/bin/docker-compose</p>
<p>chmod +x /usr/local/bin/docker-compose</p>
<p>实际上，查看下载的 run.sh 脚本内容，如下</p>
<p>set -e</p>
<p>VERSION=”1.8.0”</p>
<p>IMAGE=”docker/compose:$VERSION”</p>
<p># Setup options for connecting to docker host</p>
<p>if [ -z “$DOCKER_HOST” ]; then</p>
<p>  DOCKER_HOST=”/var/run/docker.sock”</p>
<p>fi</p>
<p>if [ -S “$DOCKER_HOST” ]; then</p>
<p>  DOCKER_ADDR=”-v $DOCKER_HOST:$DOCKER_HOST -e DOCKER_HOST”</p>
<p>else</p>
<p>  DOCKER_ADDR=”-e DOCKER_HOST -e DOCKER_TLS_VERIFY -e DOCKER_CERT_PATH”</p>
<p>fi</p>
<p># Setup volume mounts for compose config and context</p>
<p>if [ “$(pwd)” != ‘/‘ ]; then</p>
<p>  VOLUMES=”-v $(pwd):$(pwd)”</p>
<p>fi</p>
<p>if [ -n “$COMPOSE_FILE” ]; then</p>
<p>  compose_dir=$(dirname $COMPOSE_FILE)</p>
<p>fi</p>
<p># TODO: also check –file argument</p>
<p>if [ -n “$compose_dir” ]; then</p>
<p>  VOLUMES=”$VOLUMES -v $compose_dir:$compose_dir”</p>
<p>fi</p>
<p>if [ -n “$HOME” ]; then</p>
<p>  VOLUMES=”$VOLUMES -v $HOME:$HOME -v $HOME:/root” # mount $HOME in /root to share docker.config</p>
<p>fi</p>
<p># Only allocate tty if we detect one</p>
<p>if [ -t 1 ]; then</p>
<p>  DOCKER_RUN_OPTIONS=”-t”</p>
<p>fi</p>
<p>if [ -t 0 ]; then</p>
<p>  DOCKER_RUN_OPTIONS=”$DOCKER_RUN_OPTIONS -i”</p>
<p>fi</p>
<p>exec docker run –rm $DOCKER_RUN_OPTIONS $DOCKER_ADDR $COMPOSE_OPTIONS $VOLUMES -w “$(pwd)” $IMAGE “$@”</p>
<p>可以看到，它其实是下载了 docker/compose 镜像并运行。</p>
<h3 id="10-2-5-卸载"><a href="#10-2-5-卸载" class="headerlink" title="10.2.5.    卸载"></a>10.2.5.    卸载</h3><p>如果是二进制包方式安装的，删除二进制文件即可。</p>
<p>sudo rm /usr/local/bin/docker-compose</p>
<p>如果是通过 pip 安装的，则执行如下命令即可删除。</p>
<p>sudo pip uninstall docker-compose</p>
<h2 id="10-3-docker-compose-使用"><a href="#10-3-docker-compose-使用" class="headerlink" title="10.3. docker compose 使用"></a>10.3. docker compose 使用</h2><h3 id="10-3-1-术语"><a href="#10-3-1-术语" class="headerlink" title="10.3.1.    术语"></a>10.3.1.    术语</h3><p>首先介绍几个术语。</p>
<p>l 服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。</p>
<p>l 项目 (project)：由一组关联的应用容器组成的一个完整业务单元。</p>
<p>可见，一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理。</p>
<h3 id="10-3-2-场景"><a href="#10-3-2-场景" class="headerlink" title="10.3.2.    场景"></a>10.3.2.    场景</h3><p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>
<p>下面我们用 Python 来建立一个能够记录页面访问次数的 web 网站。</p>
<p><strong>web</strong> <strong>应用</strong></p>
<p>新建文件夹，在该目录中编写 app.py 文件</p>
<p>from flask import Flask</p>
<p>from redis import Redis</p>
<p>app = Flask(<strong>name</strong>)</p>
<p>redis = Redis(host=’redis’, port=6379)</p>
<p>@app.route(‘/‘)</p>
<p>def hello():</p>
<p>  count = redis.incr(‘hits’)</p>
<p>  return ‘Hello World! 该页面已被访问 {} 次。\n’.format(count)</p>
<p>if <strong>name</strong> == “<strong>main</strong>“:</p>
<p>  app.run(host=”0.0.0.0”, debug=True)</p>
<p><strong>Dockerfile</strong></p>
<p>编写 Dockerfile 文件，内容为</p>
<p>FROM python:3.6-alpine</p>
<p>ADD . /code</p>
<p>WORKDIR /code</p>
<p>RUN pip install redis flask</p>
<p>CMD [“python”, “app.py”]</p>
<p><strong>docker-compose.yml</strong></p>
<p>编写 docker-compose.yml 文件，这个是 Compose 使用的主模板文件。</p>
<p>version: ‘3’</p>
<p>services:</p>
<p> web:</p>
<p>  build: .</p>
<p>  ports:</p>
<p>   - “5000:5000”</p>
<p> redis:</p>
<p>  image: “redis:alpine”</p>
<p><strong>运行 compose 项目</strong></p>
<p>docker-compose up</p>
<p>此时访问本地 5000 端口，每次刷新页面，计数就会加 1。</p>
<h2 id="10-4-docker-compose-命令说明"><a href="#10-4-docker-compose-命令说明" class="headerlink" title="10.4. docker compose 命令说明"></a>10.4. docker compose 命令说明</h2><h3 id="10-4-1-命令对象与格式"><a href="#10-4-1-命令对象与格式" class="headerlink" title="10.4.1.    命令对象与格式"></a>10.4.1.    命令对象与格式</h3><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>
<p>执行 docker-compose [COMMAND] –help 或者 docker-compose help [COMMAND] 可以查看具体某个命令的使用格式。</p>
<p>docker-compose 命令的基本的使用格式是</p>
<p>docker-compose [-f=<arg>…] [options] [COMMAND] [ARGS…]</p>
<h3 id="10-4-2-命令选项"><a href="#10-4-2-命令选项" class="headerlink" title="10.4.2.    命令选项"></a>10.4.2.    命令选项</h3><p>l -f, –file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。</p>
<p>l -p, –project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。</p>
<p>l –x-networking 使用 Docker 的可拔插网络后端特性</p>
<p>l –x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge</p>
<p>l –verbose 输出更多调试信息。</p>
<p>l -v, –version 打印版本并退出。</p>
<h3 id="10-4-3-命令使用说明"><a href="#10-4-3-命令使用说明" class="headerlink" title="10.4.3.    命令使用说明"></a>10.4.3.    命令使用说明</h3><h4 id="10-4-3-1-build"><a href="#10-4-3-1-build" class="headerlink" title="10.4.3.1. build"></a>10.4.3.1. build</h4><p>格式为 docker-compose build [options] [SERVICE…]。</p>
<p>构建（重新构建）项目中的服务容器。</p>
<p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。</p>
<p>可以随时在项目目录下运行 docker-compose build 来重新构建服务。</p>
<p>选项包括：</p>
<p>l –force-rm 删除构建过程中的临时容器。</p>
<p>l –no-cache 构建镜像过程中不使用 cache（这将加长构建过程）。</p>
<p>l –pull 始终尝试通过 pull 来获取更新版本的镜像。</p>
<h4 id="10-4-3-2-config"><a href="#10-4-3-2-config" class="headerlink" title="10.4.3.2. config"></a>10.4.3.2. config</h4><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p>
<h4 id="10-4-3-3-down"><a href="#10-4-3-3-down" class="headerlink" title="10.4.3.3. down"></a>10.4.3.3. down</h4><p>此命令将会停止 up 命令所启动的容器，并移除网络</p>
<h4 id="10-4-3-4-exec"><a href="#10-4-3-4-exec" class="headerlink" title="10.4.3.4. exec"></a>10.4.3.4. exec</h4><p>进入指定的容器。</p>
<h4 id="10-4-3-5-help"><a href="#10-4-3-5-help" class="headerlink" title="10.4.3.5. help"></a>10.4.3.5. help</h4><p>获得一个命令的帮助。</p>
<h4 id="10-4-3-6-images"><a href="#10-4-3-6-images" class="headerlink" title="10.4.3.6. images"></a>10.4.3.6. images</h4><p>列出 Compose 文件中包含的镜像。</p>
<h4 id="10-4-3-7-kill"><a href="#10-4-3-7-kill" class="headerlink" title="10.4.3.7. kill"></a>10.4.3.7. kill</h4><p>格式为 docker-compose kill [options] [SERVICE…]。</p>
<p>通过发送 SIGKILL 信号来强制停止服务容器。</p>
<p>支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。</p>
<p>docker-compose kill -s SIGINT</p>
<h4 id="10-4-3-8-logs"><a href="#10-4-3-8-logs" class="headerlink" title="10.4.3.8. logs"></a>10.4.3.8. logs</h4><p>格式为 docker-compose logs [options] [SERVICE…]。</p>
<p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 –no-color 来关闭颜色。</p>
<p>该命令在调试问题的时候十分有用。</p>
<h4 id="10-4-3-9-pause"><a href="#10-4-3-9-pause" class="headerlink" title="10.4.3.9. pause"></a>10.4.3.9. pause</h4><p>格式为 docker-compose pause [SERVICE…]。</p>
<p>暂停一个服务容器。</p>
<h4 id="10-4-3-10-port"><a href="#10-4-3-10-port" class="headerlink" title="10.4.3.10.    port"></a>10.4.3.10.    port</h4><p>格式为 docker-compose port [options] SERVICE PRIVATE_PORT。</p>
<p>打印某个容器端口所映射的公共端口。</p>
<p>选项：</p>
<p>l –protocol=proto 指定端口协议，tcp（默认值）或者 udp。</p>
<p>l –index=index 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</p>
<h4 id="10-4-3-11-ps"><a href="#10-4-3-11-ps" class="headerlink" title="10.4.3.11.    ps"></a>10.4.3.11.    ps</h4><p>格式为 docker-compose ps [options] [SERVICE…]。</p>
<p>列出项目中目前的所有容器。</p>
<p>选项：</p>
<p>l -q 只打印容器的 ID 信息。</p>
<h4 id="10-4-3-12-pull"><a href="#10-4-3-12-pull" class="headerlink" title="10.4.3.12.    pull"></a>10.4.3.12.    pull</h4><p>格式为 docker-compose pull [options] [SERVICE…]。</p>
<p>拉取服务依赖的镜像。</p>
<p>选项：</p>
<p>l –ignore-pull-failures 忽略拉取镜像过程中的错误。</p>
<h4 id="10-4-3-13-push"><a href="#10-4-3-13-push" class="headerlink" title="10.4.3.13.    push"></a>10.4.3.13.    push</h4><p>推送服务依赖的镜像到 Docker 镜像仓库。</p>
<h4 id="10-4-3-14-restart"><a href="#10-4-3-14-restart" class="headerlink" title="10.4.3.14.    restart"></a>10.4.3.14.    restart</h4><p>格式为 docker-compose restart [options] [SERVICE…]。</p>
<p>重启项目中的服务。</p>
<p>选项：</p>
<p>l -t, –timeout TIMEOUT 指定重启前停止容器的超时（默认为 10 秒）。</p>
<h4 id="10-4-3-15-rm"><a href="#10-4-3-15-rm" class="headerlink" title="10.4.3.15.    rm"></a>10.4.3.15.    rm</h4><p>格式为 docker-compose rm [options] [SERVICE…]。</p>
<p>删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。</p>
<p>选项：</p>
<p>l -f, –force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</p>
<p>l -v 删除容器所挂载的数据卷。</p>
<h4 id="10-4-3-16-run"><a href="#10-4-3-16-run" class="headerlink" title="10.4.3.16.    run"></a>10.4.3.16.    run</h4><p>格式为 docker-compose run [options] [-p PORT…] [-e KEY=VAL…] SERVICE [COMMAND] [ARGS…]。</p>
<p>在指定服务上执行一个命令。</p>
<p>例如：</p>
<p>docker-compose run ubuntu ping docker.com</p>
<p>将会启动一个 ubuntu 服务容器，并执行 ping docker.com 命令。</p>
<p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p>
<p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p>
<p>两个不同点：</p>
<p>l 给定命令将会覆盖原有的自动运行命令；</p>
<p>l 不会自动创建端口，以避免冲突。</p>
<p>如果不希望自动启动关联的容器，可以使用 –no-deps 选项，例如</p>
<p>docker-compose run –no-deps web python manage.py shell</p>
<p>将不会启动 web 容器所关联的其它容器。</p>
<p>选项：</p>
<p>l -d 后台运行容器。</p>
<p>l –name NAME 为容器指定一个名字。</p>
<p>l –entrypoint CMD 覆盖默认的容器启动指令。</p>
<p>l -e KEY=VAL 设置环境变量值，可多次使用选项来设置多个环境变量。</p>
<p>l -u, –user=”” 指定运行容器的用户名或者 uid。</p>
<p>l –no-deps 不自动启动关联的服务容器。</p>
<p>l –rm 运行命令后自动删除容器，d 模式下将忽略。</p>
<p>l -p, –publish=[] 映射容器端口到本地主机。</p>
<p>l –service-ports 配置服务端口并映射到本地主机。</p>
<p>l -T 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</p>
<h4 id="10-4-3-17-scale"><a href="#10-4-3-17-scale" class="headerlink" title="10.4.3.17.    scale"></a>10.4.3.17.    scale</h4><p>格式为 docker-compose scale [options] [SERVICE=NUM…]。</p>
<p>设置指定服务运行的容器个数。</p>
<p>通过 service=num 的参数来设置数量。例如：</p>
<p>docker-compose scale web=3 db=2</p>
<p>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</p>
<p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</p>
<p>选项：</p>
<p>l -t, –timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。</p>
<h4 id="10-4-3-18-start"><a href="#10-4-3-18-start" class="headerlink" title="10.4.3.18.    start"></a>10.4.3.18.    start</h4><p>格式为 docker-compose start [SERVICE…]。</p>
<p>启动已经存在的服务容器。</p>
<h4 id="10-4-3-19-stop"><a href="#10-4-3-19-stop" class="headerlink" title="10.4.3.19.    stop"></a>10.4.3.19.    stop</h4><p>格式为 docker-compose stop [options] [SERVICE…]。</p>
<p>停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。</p>
<p>选项：</p>
<p>l -t, –timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。</p>
<h4 id="10-4-3-20-top"><a href="#10-4-3-20-top" class="headerlink" title="10.4.3.20.    top"></a>10.4.3.20.    top</h4><p>查看各个服务容器内运行的进程。</p>
<h4 id="10-4-3-21-unpause"><a href="#10-4-3-21-unpause" class="headerlink" title="10.4.3.21.    unpause"></a>10.4.3.21.    unpause</h4><p>格式为 docker-compose unpause [SERVICE…]。</p>
<p>恢复处于暂停状态中的服务。</p>
<h4 id="10-4-3-22-up"><a href="#10-4-3-22-up" class="headerlink" title="10.4.3.22.    up"></a>10.4.3.22.    up</h4><p>格式为 docker-compose up [options] [SERVICE…]。</p>
<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>
<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>
<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>
<p>默认情况，docker-compose up 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>
<p>当通过 Ctrl-C 停止命令时，所有容器将会停止。</p>
<p>如果使用 docker-compose up -d，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>
<p>默认情况，如果服务容器已经存在，docker-compose up 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 docker-compose up –no-recreate。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 docker-compose up –no-deps -d <SERVICE_NAME> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p>
<p>选项：</p>
<p>l -d 在后台运行服务容器。</p>
<p>l –no-color 不使用颜色来区分不同的服务的控制台输出。</p>
<p>l –no-deps 不启动服务所链接的容器。</p>
<p>l –force-recreate 强制重新创建容器，不能与 –no-recreate 同时使用。</p>
<p>l –no-recreate 如果容器已经存在了，则不重新创建，不能与 –force-recreate 同时使用。</p>
<p>l –no-build 不自动构建缺失的服务镜像。</p>
<p>l -t, –timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。</p>
<h4 id="10-4-3-23-version"><a href="#10-4-3-23-version" class="headerlink" title="10.4.3.23.    version"></a>10.4.3.23.    version</h4><p>格式为 docker-compose version。</p>
<p>打印版本信息。</p>
<h2 id="10-5-docker-compose-模板文件"><a href="#10-5-docker-compose-模板文件" class="headerlink" title="10.5. docker compose 模板文件"></a>10.5. docker compose 模板文件</h2><p>模板文件是使用 Compose 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 docker run 相关参数的含义都是类似的。</p>
<p>默认的模板文件名称为 docker-compose.yml，格式为 YAML 格式。</p>
<p>version: “3”</p>
<p>services:</p>
<p> webapp:</p>
<p>  image: examples/web</p>
<p>  ports:</p>
<p>   - “80:80”</p>
<p>  volumes:</p>
<p>   - “/data”</p>
<p>注意每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）等来自动构建生成镜像。</p>
<p>如果使用 build 指令，在 Dockerfile 中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在 docker-compose.yml 中再次设置。</p>
<p>下面分别介绍各个指令的用法。</p>
<h3 id="10-5-1-build"><a href="#10-5-1-build" class="headerlink" title="10.5.1.    build"></a>10.5.1.    build</h3><p>指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。</p>
<p>version: ‘3’</p>
<p>services:</p>
<p> webapp:</p>
<p>  build: ./dir</p>
<p>你也可以使用 context 指令指定 Dockerfile 所在文件夹的路径。</p>
<p>使用 dockerfile 指令指定 Dockerfile 文件名。</p>
<p>使用 arg 指令指定构建镜像时的变量。</p>
<p>version: ‘3’</p>
<p>services:</p>
<p> webapp:</p>
<p>  build:</p>
<p>   context: ./dir</p>
<p>   dockerfile: Dockerfile-alternate</p>
<p>   args:</p>
<p>​    buildno: 1</p>
<p>使用 cache_from 指定构建镜像的缓存</p>
<p>build:</p>
<p> context: .</p>
<p> cache_from:</p>
<p>  - alpine:latest</p>
<p>  - corp/web_app:3.14</p>
<h3 id="10-5-2-cap-add-cap-drop"><a href="#10-5-2-cap-add-cap-drop" class="headerlink" title="10.5.2.    cap_add, cap_drop"></a>10.5.2.    cap_add, cap_drop</h3><p>指定容器的内核能力（capacity）分配。</p>
<p>例如，让容器拥有所有能力可以指定为：</p>
<p>cap_add:</p>
<p> - ALL</p>
<p>去掉 NET_ADMIN 能力可以指定为：</p>
<p>cap_drop:</p>
<p> - NET_ADMIN</p>
<h3 id="10-5-3-command"><a href="#10-5-3-command" class="headerlink" title="10.5.3.    command"></a>10.5.3.    command</h3><p>覆盖容器启动后默认执行的命令。</p>
<p>command: echo “hello world”</p>
<h3 id="10-5-4-configs"><a href="#10-5-4-configs" class="headerlink" title="10.5.4.    configs"></a>10.5.4.    configs</h3><p>仅用于 Swarm mode</p>
<h3 id="10-5-5-cgroup-parent"><a href="#10-5-5-cgroup-parent" class="headerlink" title="10.5.5.    cgroup_parent"></a>10.5.5.    cgroup_parent</h3><p>指定父 cgroup 组，意味着将继承该组的资源限制。</p>
<p>例如，创建了一个 cgroup 组名称为 cgroups_1。</p>
<p>cgroup_parent: cgroups_1</p>
<h3 id="10-5-6-container-name"><a href="#10-5-6-container-name" class="headerlink" title="10.5.6.    container_name"></a>10.5.6.    container_name</h3><p>指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式。</p>
<p>container_name: docker-web-container</p>
<p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p>
<h3 id="10-5-7-deploy"><a href="#10-5-7-deploy" class="headerlink" title="10.5.7.    deploy"></a>10.5.7.    deploy</h3><p>仅用于 Swarm mode</p>
<h3 id="10-5-8-devices"><a href="#10-5-8-devices" class="headerlink" title="10.5.8.    devices"></a>10.5.8.    devices</h3><p>指定设备映射关系。</p>
<p>devices:</p>
<p> - “/dev/ttyUSB1:/dev/ttyUSB0”</p>
<h3 id="10-5-9-depends-on"><a href="#10-5-9-depends-on" class="headerlink" title="10.5.9.    depends_on"></a>10.5.9.    depends_on</h3><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web</p>
<p>version: ‘3’</p>
<p>services:</p>
<p> web:</p>
<p>  build: .</p>
<p>  depends_on:</p>
<p>   - db</p>
<p>   - redis</p>
<p> redis:</p>
<p>  image: redis</p>
<p> db:</p>
<p>  image: postgres</p>
<p>注意：web 服务不会等待 redis db 「完全启动」之后才启动。</p>
<h3 id="10-5-10-dns"><a href="#10-5-10-dns" class="headerlink" title="10.5.10.  dns"></a>10.5.10.  dns</h3><p>自定义 DNS 服务器。可以是一个值，也可以是一个列表。</p>
<p>dns: 8.8.8.8</p>
<p>dns:</p>
<p> - 8.8.8.8</p>
<p> - 114.114.114.114</p>
<h3 id="10-5-11-dns-search"><a href="#10-5-11-dns-search" class="headerlink" title="10.5.11.  dns_search"></a>10.5.11.  dns_search</h3><p>配置 DNS 搜索域。可以是一个值，也可以是一个列表。</p>
<p>dns_search: example.com</p>
<p>dns_search:</p>
<p> - domain1.example.com</p>
<p> - domain2.example.com</p>
<h3 id="10-5-12-tmpfs"><a href="#10-5-12-tmpfs" class="headerlink" title="10.5.12.  tmpfs"></a>10.5.12.  tmpfs</h3><p>挂载一个 tmpfs 文件系统到容器。</p>
<p>tmpfs: /run</p>
<p>tmpfs:</p>
<p> - /run</p>
<p> - /tmp</p>
<h3 id="10-5-13-env-file"><a href="#10-5-13-env-file" class="headerlink" title="10.5.13.  env_file"></a>10.5.13.  env_file</h3><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>
<p>如果通过 docker-compose -f FILE 方式来指定 Compose 模板文件，则 env_file 中变量的路径会基于模板文件路径。</p>
<p>如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准。</p>
<p>env_file: .env</p>
<p>env_file:</p>
<p> - ./common.env</p>
<p> - ./apps/web.env</p>
<p> - /opt/secrets.env</p>
<p>环境变量文件中每一行必须符合格式，支持 # 开头的注释行。</p>
<p># common.env: Set development environment</p>
<p>PROG_ENV=development</p>
<h3 id="10-5-14-environment"><a href="#10-5-14-environment" class="headerlink" title="10.5.14.  environment"></a>10.5.14.  environment</h3><p>设置环境变量。你可以使用数组或字典两种格式。</p>
<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>
<p>environment:</p>
<p> RACK_ENV: development</p>
<p> SESSION_SECRET:</p>
<p>environment:</p>
<p> - RACK_ENV=development</p>
<p> - SESSION_SECRET</p>
<p>如果变量名称或者值中用到 true|false，yes|no 等表达 布尔 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>
<p>y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</p>
<h3 id="10-5-15-expose"><a href="#10-5-15-expose" class="headerlink" title="10.5.15.  expose"></a>10.5.15.  expose</h3><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p>
<p>仅可以指定内部端口为参数</p>
<p>expose:</p>
<p> - “3000”</p>
<p> - “8000”</p>
<h3 id="10-5-16-external-links"><a href="#10-5-16-external-links" class="headerlink" title="10.5.16.  external_links"></a>10.5.16.  external_links</h3><p>注意：不建议使用该指令。</p>
<p>链接到 docker-compose.yml 外部的容器，甚至并非 Compose 管理的外部容器。</p>
<p>external_links:</p>
<p> - redis_1</p>
<p> - project_db_1:mysql</p>
<p> - project_db_1:postgresql</p>
<h3 id="10-5-17-extra-hosts"><a href="#10-5-17-extra-hosts" class="headerlink" title="10.5.17.  extra_hosts"></a>10.5.17.  extra_hosts</h3><p>类似 Docker 中的 –add-host 参数，指定额外的 host 名称映射信息。</p>
<p>extra_hosts:</p>
<p> - “googledns:8.8.8.8”</p>
<p> - “dockerhub:52.1.157.61”</p>
<p>会在启动后的服务容器中 /etc/hosts 文件中添加如下两条条目。</p>
<p>8.8.8.8 googledns</p>
<p>52.1.157.61 dockerhub:</p>
<h3 id="10-5-18-healthcheck"><a href="#10-5-18-healthcheck" class="headerlink" title="10.5.18.  healthcheck"></a>10.5.18.  healthcheck</h3><p>通过命令检查容器是否健康运行。</p>
<p>healthcheck:</p>
<p> test: [“CMD”, “curl”, “-f”, “<a href="http://localhost&quot;]">http://localhost&quot;]</a></p>
<p> interval: 1m30s</p>
<p> timeout: 10s</p>
<p> retries: 3</p>
<h3 id="10-5-19-image"><a href="#10-5-19-image" class="headerlink" title="10.5.19.  image"></a>10.5.19.  image</h3><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。</p>
<p>image: ubuntu</p>
<p>image: orchardup/postgresql</p>
<p>image: a4bc65fd</p>
<h3 id="10-5-20-labels"><a href="#10-5-20-labels" class="headerlink" title="10.5.20.  labels"></a>10.5.20.  labels</h3><p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p>
<p>labels:</p>
<p> com.startupteam.description: “webapp for a startup team”</p>
<p> com.startupteam.department: “devops department”</p>
<p> com.startupteam.release: “rc3 for v1.0”</p>
<h3 id="10-5-21-links"><a href="#10-5-21-links" class="headerlink" title="10.5.21.  links"></a>10.5.21.  links</h3><p>注意：不推荐使用该指令。</p>
<h3 id="10-5-22-logging"><a href="#10-5-22-logging" class="headerlink" title="10.5.22.  logging"></a>10.5.22.  logging</h3><p>配置日志选项。</p>
<p>logging:</p>
<p> driver: syslog</p>
<p> options:</p>
<p>  syslog-address: “tcp://192.168.0.42:123”</p>
<p>目前支持三种日志驱动类型。</p>
<p>driver: “json-file”</p>
<p>driver: “syslog”</p>
<p>driver: “none”</p>
<p>options 配置日志驱动的相关参数。</p>
<p>options:</p>
<p> max-size: “200k”</p>
<p> max-file: “10”</p>
<h3 id="10-5-23-network-mode"><a href="#10-5-23-network-mode" class="headerlink" title="10.5.23.  network_mode"></a>10.5.23.  network_mode</h3><p>设置网络模式。使用和 docker run 的 –network 参数一样的值。</p>
<p>network_mode: “bridge”</p>
<p>network_mode: “host”</p>
<p>network_mode: “none”</p>
<p>network_mode: “service:[service name]”</p>
<p>network_mode: “container:[container name/id]”</p>
<h3 id="10-5-24-networks"><a href="#10-5-24-networks" class="headerlink" title="10.5.24.  networks"></a>10.5.24.  networks</h3><p>配置容器连接的网络。</p>
<p>version: “3”</p>
<p>services:</p>
<p> some-service:</p>
<p>  networks:</p>
<p>   - some-network</p>
<p>   - other-network</p>
<p>networks:</p>
<p> some-network:</p>
<p> other-network:</p>
<h3 id="10-5-25-pid"><a href="#10-5-25-pid" class="headerlink" title="10.5.25.  pid"></a>10.5.25.  pid</h3><p>跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</p>
<p>pid: “host”</p>
<h3 id="10-5-26-ports"><a href="#10-5-26-ports" class="headerlink" title="10.5.26.  ports"></a>10.5.26.  ports</h3><p>暴露端口信息。</p>
<p>使用宿主端口：容器端口 (HOST:CONTAINER) 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>
<p>ports:</p>
<p> - “3000”</p>
<p> - “8000:8000”</p>
<p> - “49100:22”</p>
<p> - “127.0.0.1:8001:8001”</p>
<p>注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</p>
<h3 id="10-5-27-secrets"><a href="#10-5-27-secrets" class="headerlink" title="10.5.27.  secrets"></a>10.5.27.  secrets</h3><p>存储敏感数据，例如 mysql 服务密码。</p>
<p>version: “3.1”</p>
<p>services:</p>
<p>mysql:</p>
<p> image: mysql</p>
<p> environment:</p>
<p>  MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password</p>
<p> secrets:</p>
<p>  - db_root_password</p>
<p>  - my_other_secret</p>
<p>secrets:</p>
<p> my_secret:</p>
<p>  file: ./my_secret.txt</p>
<p> my_other_secret:</p>
<p>  external: true</p>
<h3 id="10-5-28-security-opt"><a href="#10-5-28-security-opt" class="headerlink" title="10.5.28.  security_opt"></a>10.5.28.  security_opt</h3><p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。</p>
<p>security_opt:</p>
<p>  - label:user:USER</p>
<p>  - label:role:ROLE</p>
<h3 id="10-5-29-stop-signal"><a href="#10-5-29-stop-signal" class="headerlink" title="10.5.29.  stop_signal"></a>10.5.29.  stop_signal</h3><p>设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。</p>
<p>stop_signal: SIGUSR1</p>
<h3 id="10-5-30-sysctls"><a href="#10-5-30-sysctls" class="headerlink" title="10.5.30.  sysctls"></a>10.5.30.  sysctls</h3><p>配置容器内核参数。</p>
<p>sysctls:</p>
<p> net.core.somaxconn: 1024</p>
<p> net.ipv4.tcp_syncookies: 0</p>
<p>sysctls:</p>
<p> - net.core.somaxconn=1024</p>
<p> - net.ipv4.tcp_syncookies=0</p>
<h3 id="10-5-31-ulimits"><a href="#10-5-31-ulimits" class="headerlink" title="10.5.31.  ulimits"></a>10.5.31.  ulimits</h3><p>指定容器的 ulimits 限制值。</p>
<p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>
<p> ulimits:</p>
<p>  nproc: 65535</p>
<p>  nofile:</p>
<p>   soft: 20000</p>
<p>   hard: 40000</p>
<h3 id="10-5-32-volumes"><a href="#10-5-32-volumes" class="headerlink" title="10.5.32.  volumes"></a>10.5.32.  volumes</h3><p>数据卷所挂载路径设置。可以设置宿主机路径 （HOST:CONTAINER） 或加上访问模式 （HOST:CONTAINER:ro）。</p>
<p>该指令中路径支持相对路径。</p>
<p>volumes:</p>
<p> - /var/lib/mysql</p>
<p> - cache/:/tmp/cache</p>
<p> - ~/configs:/etc/configs/:ro</p>
<h3 id="10-5-33-其它指令"><a href="#10-5-33-其它指令" class="headerlink" title="10.5.33.  其它指令"></a>10.5.33.  其它指令</h3><p>此外，还有包括 domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir 等指令，基本跟 docker run 中对应参数的功能一致。</p>
<p>指定服务容器启动后执行的入口文件。</p>
<p>entrypoint: /code/entrypoint.sh</p>
<p>指定容器中运行应用的用户名。</p>
<p>user: nginx</p>
<p>指定容器中工作目录。</p>
<p>working_dir: /code</p>
<p>指定容器中搜索域名、主机名、mac 地址等。</p>
<p>domainname: your_website.com</p>
<p>hostname: test</p>
<p>mac_address: 08-00-27-00-0C-0A</p>
<p>允许容器中运行一些特权命令。</p>
<p>privileged: true</p>
<p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 always 或者 unless-stopped。</p>
<p>restart: always</p>
<p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p>
<p>read_only: true</p>
<p>打开标准输入，可以接受外部输入。</p>
<p>stdin_open: true</p>
<p>模拟一个伪终端。</p>
<p>tty: true</p>
<h3 id="10-5-34-读取变量"><a href="#10-5-34-读取变量" class="headerlink" title="10.5.34.  读取变量"></a>10.5.34.  读取变量</h3><p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 .env 文件中的变量。</p>
<p>例如，下面的 Compose 文件将从运行它的环境中读取变量 ${MONGO_VERSION} 的值，并写入执行的指令中。</p>
<p>version: “3”</p>
<p>services:</p>
<p>db:</p>
<p> image: “mongo:${MONGO_VERSION}”</p>
<p>如果执行 MONGO_VERSION=3.2 docker-compose up 则会启动一个 mongo:3.2 镜像的容器；如果执行 MONGO_VERSION=2.8 docker-compose up 则会启动一个 mongo:2.8 镜像的容器。</p>
<p>若当前目录存在 .env 文件，执行 docker-compose 命令时将从该文件中读取变量。</p>
<p>在当前目录新建 .env 文件并写入以下内容。</p>
<p># 支持 # 号注释</p>
<p>MONGO_VERSION=3.6</p>
<p>执行 docker-compose up 则会启动一个 mongo:3.6 镜像的容器。</p>
<h2 id="10-6-docker-compose-实战-dubbo-admin"><a href="#10-6-docker-compose-实战-dubbo-admin" class="headerlink" title="10.6. docker compose 实战 dubbo-admin"></a>10.6. docker compose 实战 dubbo-admin</h2><p>compose 可以很便捷的让 dubbo-admin 运行在一个独立的环境中。</p>
<h3 id="10-6-1-创建空文件夹"><a href="#10-6-1-创建空文件夹" class="headerlink" title="10.6.1.    创建空文件夹"></a>10.6.1.    创建空文件夹</h3><p>假设新建一个名为 dubbo-admin 的文件夹，然后进入这个文件夹。</p>
<h3 id="10-6-2-创建-docker-compose-yml-文件"><a href="#10-6-2-创建-docker-compose-yml-文件" class="headerlink" title="10.6.2.    创建 docker-compose.yml 文件"></a>10.6.2.    创建 docker-compose.yml 文件</h3><p>docker-compose.yml 文件将开启一个 dubbo-admin 服务和一个独立的 zookeeper 实例：</p>
<p>version: ‘3.4’</p>
<p>services:</p>
<p> zk_server:</p>
<p>  image: zookeeper:3.4</p>
<p>  ports:</p>
<p>   - 2181:2181</p>
<p> dubbo-admin:</p>
<p>  image: xiaochunping/dubbo-admin:1.0</p>
<p>  links:</p>
<p>   - zk_server:zookeeper</p>
<p>  depends_on:</p>
<p>   - zk_server</p>
<p>  ports:</p>
<p>   - 7001:7001</p>
<h3 id="10-6-3-构建并运行项目"><a href="#10-6-3-构建并运行项目" class="headerlink" title="10.6.3.    构建并运行项目"></a>10.6.3.    构建并运行项目</h3><p>运行 docker-compose up -d 就会拉取镜像再创建我们所需要的镜像，然后启动 dubbo-admin 和数据库容器。 接着浏览器访问 127.0.0.1:7001 端口就能看到 dubbo-admin 安装界面了。</p>
<h1 id="11-docker-三剑客-machine"><a href="#11-docker-三剑客-machine" class="headerlink" title="11.  docker 三剑客 machine"></a>11.  docker 三剑客 machine</h1><h2 id="11-1-Docker-Machine-简介"><a href="#11-1-Docker-Machine-简介" class="headerlink" title="11.1. Docker Machine 简介"></a>11.1. Docker Machine 简介</h2><p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135253.gif" alt="IMG_256"></p>
<p>Docker Machine 是 Docker 官方编排（Orchestration）项目之一，负责在多种平台上快速安装 Docker 环境。</p>
<p>Docker Machine 项目基于 Go 语言实现，目前在 <a href="https://github.com/docker/machine" target="_blank" rel="noopener">Github </a>上进行维护。</p>
<p>本章将介绍 Docker Machine 的安装及使用。</p>
<h2 id="11-2-Docker-Machine-安装"><a href="#11-2-Docker-Machine-安装" class="headerlink" title="11.2. Docker Machine 安装"></a>11.2. Docker Machine 安装</h2><p>Docker Machine 可以在多种操作系统平台上安装，包括 Linux、macOS，以及 Windows。</p>
<h3 id="11-2-1-macOS、Windows"><a href="#11-2-1-macOS、Windows" class="headerlink" title="11.2.1.    macOS、Windows"></a>11.2.1.    macOS、Windows</h3><p>Docker for Mac、Docker for Windows 自带 docker-machine 二进制包，安装之后即可使用。</p>
<p>查看版本信息。</p>
<p>docker-machine -v</p>
<h3 id="11-2-2-Linux"><a href="#11-2-2-Linux" class="headerlink" title="11.2.2.    Linux"></a>11.2.2.    Linux</h3><p>在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。</p>
<p>例如，在 Linux 64 位系统上直接下载对应的二进制包。</p>
<p>sudo curl -L <a href="https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname" target="_blank" rel="noopener">https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname</a> -s<code>-</code>uname -m` &gt; /usr/local/bin/docker-machine</p>
<p>sudo chmod +x /usr/local/bin/docker-machine</p>
<p>完成后，查看版本信息。</p>
<p>docker-machine -v</p>
<h2 id="11-3-Docker-Machine-使用"><a href="#11-3-Docker-Machine-使用" class="headerlink" title="11.3. Docker Machine 使用"></a>11.3. Docker Machine 使用</h2><p>Docker Machine 支持多种后端驱动，包括虚拟机、本地主机和云平台等。</p>
<h3 id="11-3-1-创建本地主机实例"><a href="#11-3-1-创建本地主机实例" class="headerlink" title="11.3.1.    创建本地主机实例"></a>11.3.1.    创建本地主机实例</h3><p><strong>Virtualbox</strong> <strong>驱动</strong></p>
<p>使用 virtualbox 类型的驱动，创建一台 Docker 主机，命名为 test。</p>
<p>docker-machine create -d virtualbox test</p>
<p>你也可以在创建时加上如下参数，来配置主机或者主机上的 Docker。</p>
<p>–engine-opt dns=114.114.114.114 配置 Docker 的默认 DNS</p>
<p>–engine-registry-mirror <a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a> 配置 Docker 的仓库镜像</p>
<p>–virtualbox-memory 2048 配置主机内存</p>
<p>–virtualbox-cpu-count 2 配置主机 CPU</p>
<p>更多参数请使用 docker-machine create –driver virtualbox –help 命令查看。</p>
<p><strong>macOS xhyve</strong> <strong>驱动</strong></p>
<p>xhyve 驱动 GitHub: <a href="https://github.com/zchee/docker-machine-driver-xhyve" target="_blank" rel="noopener">https://github.com/zchee/docker-machine-driver-xhyve</a></p>
<p>xhyve 是 macOS 上轻量化的虚拟引擎，使用其创建的 Docker Machine 较 VirtualBox 驱动创建的运行效率要高。</p>
<p>brew install docker-machine-driver-xhyve</p>
<p>docker-machine create \</p>
<p>   -d xhyve \</p>
<p>   # –xhyve-boot2docker-url ~/.docker/machine/cache/boot2docker.iso \</p>
<p>   –engine-opt dns=114.114.114.114 \</p>
<p>   –engine-registry-mirror <a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a> \</p>
<p>   –xhyve-memory-size 2048 \</p>
<p>   –xhyve-rawdisk \</p>
<p>   –xhyve-cpu-count 2 \</p>
<p>   xhyve</p>
<p>注意：非首次创建时建议加上 –xhyve-boot2docker-url ~/.docker/machine/cache/boot2docker.iso 参数，避免每次创建时都从 GitHub 下载 ISO 镜像。</p>
<p>更多参数请使用 docker-machine create –driver xhyve –help 命令查看。</p>
<p><strong>Windows 10</strong></p>
<p>Windows 10 安装 Docker for Windows 之后不能再安装 VirtualBox，也就不能使用 virtualbox 驱动来创建 Docker Machine，我们可以选择使用 hyperv 驱动。</p>
<p>docker-machine create –driver hyperv vm</p>
<p>更多参数请使用 docker-machine create –driver hyperv –help 命令查看。</p>
<h3 id="11-3-2-使用介绍"><a href="#11-3-2-使用介绍" class="headerlink" title="11.3.2.    使用介绍"></a>11.3.2.    使用介绍</h3><p>创建好主机之后，查看主机</p>
<p>docker-machine ls</p>
<p>NAME   ACTIVE  DRIVER    STATE   URL    SWARM  DOCKER    ERRORS</p>
<p>test   -    virtualbox  Running  tcp://192.168.99.187:2376      v17.10.0-ce</p>
<p>创建主机成功后，可以通过 env 命令来让后续操作对象都是目标主机。</p>
<p>docker-machine env test</p>
<p>后续根据提示在命令行输入命令之后就可以操作 test 主机。</p>
<p>也可以通过 SSH 登录到主机。</p>
<p>docker-machine ssh test</p>
<p>docker@test:~$ docker –version</p>
<p>Docker version 17.10.0-ce, build f4ffd25</p>
<p>连接到主机之后你就可以在其上使用 Docker 了。</p>
<h3 id="11-3-3-官方支持驱动"><a href="#11-3-3-官方支持驱动" class="headerlink" title="11.3.3.    官方支持驱动"></a>11.3.3.    官方支持驱动</h3><p>通过 -d 选项可以选择支持的驱动类型。</p>
<p>l amazonec2</p>
<p>l azure</p>
<p>l digitalocean</p>
<p>l exoscale</p>
<p>l generic</p>
<p>l google</p>
<p>l hyperv</p>
<p>l none</p>
<p>l openstack</p>
<p>l rackspace</p>
<p>l softlayer</p>
<p>l virtualbox</p>
<p>l vmwarevcloudair</p>
<p>l vmwarefusion</p>
<p>l vmwarevsphere</p>
<h3 id="11-3-4-第三方驱动"><a href="#11-3-4-第三方驱动" class="headerlink" title="11.3.4.    第三方驱动"></a>11.3.4.    第三方驱动</h3><p>请到 <a href="https://github.com/docker/docker.github.io/blob/master/machine/AVAILABLE_DRIVER_PLUGINS.md" target="_blank" rel="noopener">第三方驱动列表</a> 查看</p>
<h3 id="11-3-5-操作命令"><a href="#11-3-5-操作命令" class="headerlink" title="11.3.5.    操作命令"></a>11.3.5.    操作命令</h3><p>l active 查看活跃的 Docker 主机</p>
<p>l config 输出连接的配置信息</p>
<p>l create 创建一个 Docker 主机</p>
<p>l env 显示连接到某个主机需要的环境变量</p>
<p>l inspect 输出主机更多信息</p>
<p>l ip 获取主机地址</p>
<p>l kill 停止某个主机</p>
<p>l ls 列出所有管理的主机</p>
<p>l provision 重新设置一个已存在的主机</p>
<p>l regenerate-certs 为某个主机重新生成 TLS 认证信息</p>
<p>l restart 重启主机</p>
<p>l rm 删除某台主机</p>
<p>l ssh SSH 到主机上执行命令</p>
<p>l scp 在主机之间复制文件</p>
<p>l mount 挂载主机目录到本地</p>
<p>l start 启动一个主机</p>
<p>l status 查看主机状态</p>
<p>l stop 停止一个主机</p>
<p>l upgrade 更新主机 Docker 版本为最新</p>
<p>l url 获取主机的 URL</p>
<p>l version 输出 docker-machine 版本信息</p>
<p>l help 输出帮助信息</p>
<p>每个命令，又带有不同的参数，可以通过</p>
<p>docker-machine COMMAND –help</p>
<p>来查看具体的用法。</p>
<h1 id="12-docker-三剑客-swarm"><a href="#12-docker-三剑客-swarm" class="headerlink" title="12.  docker 三剑客 swarm"></a>12.  docker 三剑客 swarm</h1><h2 id="12-1-Docker-Swarm-简介"><a href="#12-1-Docker-Swarm-简介" class="headerlink" title="12.1. Docker Swarm 简介"></a>12.1. Docker Swarm 简介</h2><p>Docker Swarm 是 Docker 官方三剑客项目之一，提供 Docker 容器集群服务，是 Docker 官方对容器云生态进行支持的核心方案。</p>
<p>使用它，用户可以将多个 Docker 主机封装为单个大型的虚拟 Docker 主机，快速打造一套容器云平台。</p>
<p>注意：Docker 1.12.0+ Swarm mode 已经内嵌入 Docker 引擎，成为了 docker 子命令 docker swarm，绝大多数用户已经开始使用 Swarm mode，Docker 引擎 API 已经删除 Docker Swarm。为避免大家混淆旧的 Docker Swarm 与新的 Swarm mode，旧的 Docker Swarm 内容已经删除，请查看 Swarm mode 一节。</p>
<h2 id="12-2-Docker-Swarm-mode"><a href="#12-2-Docker-Swarm-mode" class="headerlink" title="12.2. Docker Swarm mode"></a>12.2. Docker Swarm mode</h2><p>Docker 1.12 Swarm mode 已经内嵌入 Docker 引擎，成为了 docker 子命令 docker swarm。请注意与旧的 Docker Swarm 区分开来。</p>
<p>Swarm mode 内置 kv 存储功能，提供了众多的新特性，比如：具有容错能力的去中心化设计、内置服务发现、负载均衡、路由网格、动态伸缩、滚动更新、安全传输等。使得 Docker 原生的 Swarm 集群具备与 Mesos、Kubernetes 竞争的实力。</p>
<h2 id="12-3-Swarm-mode-基本概念"><a href="#12-3-Swarm-mode-基本概念" class="headerlink" title="12.3. Swarm mode 基本概念"></a>12.3. Swarm mode 基本概念</h2><p>Swarm 是使用 <a href="https://github.com/docker/swarmkit/" target="_blank" rel="noopener">SwarmKit</a> 构建的 Docker 引擎内置（原生）的集群管理和编排工具。</p>
<p>使用 Swarm 集群之前需要了解以下几个概念。</p>
<h3 id="12-3-1-节点"><a href="#12-3-1-节点" class="headerlink" title="12.3.1.    节点"></a>12.3.1.    节点</h3><p>运行 Docker 的主机可以主动初始化一个 Swarm 集群或者加入一个已存在的 Swarm 集群，这样这个运行 Docker 的主机就成为一个 Swarm 集群的节点 (node) 。</p>
<p>节点分为管理 (manager) 节点和工作 (worker) 节点。</p>
<p>管理节点用于 Swarm 集群的管理，docker swarm 命令基本只能在管理节点执行（节点退出集群命令 docker swarm leave 可以在工作节点执行）。一个 Swarm 集群可以有多个管理节点，但只有一个管理节点可以成为 leader，leader 通过 raft 协议实现。</p>
<p>工作节点是任务执行节点，管理节点将服务 (service) 下发至工作节点执行。管理节点默认也作为工作节点。你也可以通过配置让服务只运行在管理节点。</p>
<p>来自 Docker 官网的这张图片形象的展示了集群中管理节点与工作节点的关系。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135124.jpg" alt="IMG_256"></p>
<h3 id="12-3-2-服务和任务"><a href="#12-3-2-服务和任务" class="headerlink" title="12.3.2.    服务和任务"></a>12.3.2.    服务和任务</h3><p>任务 （Task）是 Swarm 中的最小的调度单位，目前来说就是一个单一的容器。</p>
<p>服务 （Services） 是指一组任务的集合，服务定义了任务的属性。服务有两种模式：</p>
<p>replicated services 按照一定规则在各个工作节点上运行指定个数的任务。</p>
<p>global services 每个工作节点上运行一个任务</p>
<p>两种模式通过 docker service create 的 –mode 参数指定。</p>
<p>来自 Docker 官网的这张图片形象的展示了容器、任务、服务的关系。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135127.jpg" alt="IMG_256"></p>
<h2 id="12-4-创建-Swarm-集群"><a href="#12-4-创建-Swarm-集群" class="headerlink" title="12.4. 创建 Swarm 集群"></a>12.4. 创建 Swarm 集群</h2><p>阅读 基本概念 一节我们知道 Swarm 集群由 管理节点 和 工作节点 组成。本节我们来创建一个包含一个管理节点和两个工作节点的最小 Swarm 集群。</p>
<h3 id="12-4-1-初始化集群"><a href="#12-4-1-初始化集群" class="headerlink" title="12.4.1.    初始化集群"></a>12.4.1.    初始化集群</h3><p>在 Docker Machine 一节中我们了解到 Docker Machine 可以在数秒内创建一个虚拟的 Docker 主机，下面我们使用它来创建三个 Docker 主机，并加入到集群中。</p>
<p>我们首先创建一个 Docker 主机作为管理节点。</p>
<p>docker-machine create -d virtualbox manager</p>
<p>我们使用 docker swarm init 在管理节点初始化一个 Swarm 集群。</p>
<p>docker-machine ssh manager</p>
<p>docker@manager:~$ docker swarm init –advertise-addr 192.168.99.100</p>
<p>Swarm initialized: current node (dxn1zf6l61qsb1josjja83ngz) is now a manager.</p>
<p>To add a worker to this swarm, run the following command:</p>
<p>  docker swarm join \</p>
<p>  –token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</p>
<p>  192.168.99.100:2377</p>
<p>To add a manager to this swarm, run ‘docker swarm join-token manager’ and follow the instructions.</p>
<p>如果你的 Docker 主机有多个网卡，拥有多个 IP，必须使用 –advertise-addr 指定 IP。</p>
<p>执行 docker swarm init 命令的节点自动成为管理节点。</p>
<h3 id="12-4-2-增加工作节点"><a href="#12-4-2-增加工作节点" class="headerlink" title="12.4.2.    增加工作节点"></a>12.4.2.    增加工作节点</h3><p>上一步我们初始化了一个 Swarm 集群，拥有了一个管理节点，下面我们继续创建两个 Docker 主机作为工作节点，并加入到集群中。</p>
<p>$ docker-machine create -d virtualbox worker1</p>
<p>$ docker-machine ssh worker1</p>
<p>docker@worker1:~$ docker swarm join \</p>
<p>  –token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</p>
<p>  192.168.99.100:2377</p>
<p>This node joined a swarm as a worker.   </p>
<p>$ docker-machine create -d virtualbox worker2</p>
<p>$ docker-machine ssh worker2</p>
<p>docker@worker1:~$ docker swarm join \</p>
<p>  –token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</p>
<p>  192.168.99.100:2377</p>
<p>This node joined a swarm as a worker.  </p>
<p>注意：一些细心的读者可能通过 docker-machine create –help 查看到 –swarm* 等一系列参数。该参数是用于旧的 Docker Swarm,与本章所讲的 Swarm mode 没有关系。</p>
<h3 id="12-4-3-查看集群"><a href="#12-4-3-查看集群" class="headerlink" title="12.4.3.    查看集群"></a>12.4.3.    查看集群</h3><p>经过上边的两步，我们已经拥有了一个最小的 Swarm 集群，包含一个管理节点和两个工作节点。</p>
<p>在管理节点使用 docker node ls 查看集群。</p>
<p>docker node ls</p>
<p>ID              HOSTNAME STATUS AVAILABILITY MANAGER STATUS</p>
<p>03g1y59jwfg7cf99w4lt0f662  worker2  Ready  Active</p>
<p>9j68exjopxe7wfl6yuxml7a7j  worker1  Ready  Active</p>
<p>dxn1zf6l61qsb1josjja83ngz * manager  Ready  Active    Leader</p>
<h2 id="12-5-Swarm-mode-部署服务"><a href="#12-5-Swarm-mode-部署服务" class="headerlink" title="12.5. Swarm mode 部署服务"></a>12.5. Swarm mode 部署服务</h2><p>我们使用 docker service 命令来管理 Swarm 集群中的服务，该命令只能在管理节点运行。</p>
<h3 id="12-5-1-新建服务"><a href="#12-5-1-新建服务" class="headerlink" title="12.5.1.    新建服务"></a>12.5.1.    新建服务</h3><p>现在我们在上一节创建的 Swarm 集群中运行一个名为 nginx 服务。</p>
<p>docker service create –replicas 3 -p 80:80 –name nginx nginx:1.13.7-alpine</p>
<p>现在我们使用浏览器，输入任意节点 IP ,即可看到 nginx 默认页面。</p>
<h3 id="12-5-2-查看服务"><a href="#12-5-2-查看服务" class="headerlink" title="12.5.2.    查看服务"></a>12.5.2.    查看服务</h3><p>使用 docker service ls 来查看当前 Swarm 集群运行的服务。</p>
<p>docker service ls</p>
<p>ID    NAME   MODE    REPLICAS   IMAGE    PORTS</p>
<p>kc57xffvhul5 nginx  replicated  3/3   nginx:1.13.7-alpine  *:80-&gt;80/tcp</p>
<p>使用 docker service ps 来查看某个服务的详情。</p>
<p>docker service ps nginx</p>
<p>ID  NAME  IMAGE  NODE  DESIRED STATE CURRENT STATE   ERROR   PORTS</p>
<p>pjfzd39buzlt   nginx.1  nginx:1.13.7-alpine  swarm2  Running  Running about a minute ago</p>
<p>hy9eeivdxlaa  nginx.2  nginx:1.13.7-alpine  swarm1   Running Running about a minute ago</p>
<p>36wmpiv7gmfo nginx.3  nginx:1.13.7-alpine  swarm3  Running  Running about a minute ago</p>
<p>使用 docker service logs 来查看某个服务的日志。</p>
<p>docker service logs nginx</p>
<p>nginx.3.36wmpiv7gmfo@swarm3  | 10.255.0.4 - - [25/Nov/2017:02:10:30 +0000] “GET / HTTP/1.1” 200 612 “-“ “Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0” “-“</p>
<p>nginx.3.36wmpiv7gmfo@swarm3  | 10.255.0.4 - - [25/Nov/2017:02:10:30 +0000] “GET /favicon.ico HTTP/1.1” 404 169 “-“ “Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0” “-“</p>
<p>nginx.3.36wmpiv7gmfo@swarm3  | 2017/11/25 02:10:30 [error] 5#5: *1 open() “/usr/share/nginx/html/favicon.ico” failed (2: No such file or directory), client: 10.255.0.4, server: localhost, request: “GET /favicon.ico HTTP/1.1”, host: “192.168.99.102”</p>
<p>nginx.1.pjfzd39buzlt@swarm2  | 10.255.0.2 - - [25/Nov/2017:02:10:26 +0000] “GET / HTTP/1.1” 200 612 “-“ “Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0” “-“</p>
<p>nginx.1.pjfzd39buzlt@swarm2  | 10.255.0.2 - - [25/Nov/2017:02:10:27 +0000] “GET /favicon.ico HTTP/1.1” 404 169 “-“ “Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0” “-“</p>
<p>nginx.1.pjfzd39buzlt@swarm2  | 2017/11/25 02:10:27 [error] 5#5: *1 open() “/usr/share/nginx/html/favicon.ico” failed (2: No such file or directory), client: 10.255.0.2, server: localhost, request: “GET /favicon.ico HTTP/1.1”, host: “192.168.99.101”</p>
<h3 id="12-5-3-删除服务"><a href="#12-5-3-删除服务" class="headerlink" title="12.5.3.    删除服务"></a>12.5.3.    删除服务</h3><p>使用 docker service rm 来从 Swarm 集群移除某个服务。</p>
<p>docker service rm nginx</p>
<h2 id="12-6-使用-compose-文件"><a href="#12-6-使用-compose-文件" class="headerlink" title="12.6. 使用 compose 文件"></a>12.6. 使用 compose 文件</h2><p>正如之前使用 docker-compose.yml 来一次配置、启动多个容器，在 Swarm 集群中也可以使用 compose 文件 （docker-compose.yml） 来配置、启动多个服务。</p>
<p>上一节中，我们使用 docker service create 一次只能部署一个服务，使用 docker-compose.yml 我们可以一次启动多个关联的服务。</p>
<p>我们以在 Swarm 集群中部署 WordPress 为例进行说明。</p>
<p>version: “3”</p>
<p>services:</p>
<p> wordpress:</p>
<p>  image: wordpress</p>
<p>  ports:</p>
<p>   - 80:80</p>
<p>  networks:</p>
<p>   - overlay</p>
<p>  environment:</p>
<p>   WORDPRESS_DB_HOST: db:3306</p>
<p>   WORDPRESS_DB_USER: wordpress</p>
<p>   WORDPRESS_DB_PASSWORD: wordpress</p>
<p>  deploy:</p>
<p>   mode: replicated</p>
<p>   replicas: 3</p>
<p> db:</p>
<p>  image: mysql</p>
<p>  networks:</p>
<p>​    - overlay</p>
<p>  volumes:</p>
<p>   - db-data:/var/lib/mysql</p>
<p>  environment:</p>
<p>   MYSQL_ROOT_PASSWORD: somewordpress</p>
<p>   MYSQL_DATABASE: wordpress</p>
<p>   MYSQL_USER: wordpress</p>
<p>   MYSQL_PASSWORD: wordpress</p>
<p>  deploy:</p>
<p>   placement:</p>
<p>​    constraints: [node.role == manager]</p>
<p> visualizer:</p>
<p>  image: dockersamples/visualizer:stable</p>
<p>  ports:</p>
<p>   - “8080:8080”</p>
<p>  stop_grace_period: 1m30s</p>
<p>  volumes:</p>
<p>   - “/var/run/docker.sock:/var/run/docker.sock”</p>
<p>  deploy:</p>
<p>   placement:</p>
<p>​    constraints: [node.role == manager]</p>
<p>volumes:</p>
<p> db-data:</p>
<p>networks:</p>
<p> overlay:</p>
<p>在 Swarm 集群管理节点新建该文件，其中的 visualizer 服务提供一个可视化页面，我们可以从浏览器中很直观的查看集群中各个服务的运行节点。</p>
<p>在 Swarm 集群中使用 docker-compose.yml 我们用 docker stack 命令，下面我们对该命令进行详细讲解。</p>
<h3 id="12-6-1-部署服务"><a href="#12-6-1-部署服务" class="headerlink" title="12.6.1.    部署服务"></a>12.6.1.    部署服务</h3><p>部署服务使用 docker stack deploy，其中 -c 参数指定 compose 文件名。</p>
<p>docker stack deploy -c docker-compose.yml wordpress</p>
<p>现在我们打开浏览器输入 任一节点IP:8080 即可看到各节点运行状态。如下图所示：</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135135.gif" alt="IMG_256"></p>
<p>在浏览器新的标签页输入 任一节点IP 即可看到 WordPress 安装界面，安装完成之后，输入 任一节点IP 即可看到 WordPress 页面。</p>
<h3 id="12-6-2-查看服务"><a href="#12-6-2-查看服务" class="headerlink" title="12.6.2.    查看服务"></a>12.6.2.    查看服务</h3><p>docker stack ls</p>
<p>NAME        SERVICES</p>
<p>wordpress      3</p>
<h3 id="12-6-3-移除服务"><a href="#12-6-3-移除服务" class="headerlink" title="12.6.3.    移除服务"></a>12.6.3.    移除服务</h3><p>要移除服务，使用 docker stack down</p>
<p>docker stack down wordpress</p>
<p>Removing service wordpress_db</p>
<p>Removing service wordpress_visualizer</p>
<p>Removing service wordpress_wordpress</p>
<p>Removing network wordpress_overlay</p>
<p>Removing network wordpress_default</p>
<p>该命令不会移除服务所使用的 数据卷，如果你想移除数据卷请使用 docker volume rm</p>
<h2 id="12-7-Swarm-mode-管理敏感数据"><a href="#12-7-Swarm-mode-管理敏感数据" class="headerlink" title="12.7. Swarm mode 管理敏感数据"></a>12.7. Swarm mode 管理敏感数据</h2><p>在动态的、大规模的分布式集群上，管理和分发 密码、证书 等敏感信息是极其重要的工作。传统的密钥分发方式（如密钥放入镜像中，设置环境变量，volume 动态挂载等）都存在着潜在的巨大的安全风险。</p>
<p>Docker 目前已经提供了 secrets 管理功能，用户可以在 Swarm 集群中安全地管理密码、密钥证书等敏感数据，并允许在多个 Docker 容器实例之间共享访问指定的敏感数据。</p>
<p>注意： secret 也可以在 Docker Compose 中使用。</p>
<p>我们可以用 docker secret 命令来管理敏感信息。接下来我们在上面章节中创建好的 Swarm 集群中介绍该命令的使用。</p>
<p>这里我们以在 Swarm 集群中部署 mysql 和 wordpress 服务为例。</p>
<h3 id="12-7-1-创建-secret"><a href="#12-7-1-创建-secret" class="headerlink" title="12.7.1.    创建 secret"></a>12.7.1.    创建 secret</h3><p>我们使用 docker secret create 命令以管道符的形式创建 secret</p>
<p>openssl rand -base64 20 | docker secret create mysql_password -</p>
<p>openssl rand -base64 20 | docker secret create mysql_root_password -</p>
<h3 id="12-7-2-查看-secret"><a href="#12-7-2-查看-secret" class="headerlink" title="12.7.2.    查看 secret"></a>12.7.2.    查看 secret</h3><p>使用 docker secret ls 命令来查看 secret</p>
<p>docker secret ls-</p>
<p>ID             NAME         CREATED       UPDATED</p>
<p>l1vinzevzhj4goakjap5ya409  mysql_password    41 seconds ago   41 seconds ago</p>
<p>yvsczlx9votfw3l0nz5rlidig  mysql_root_password  12 seconds ago   12 seconds ago</p>
<h3 id="12-7-3-创建-MySQL-服务"><a href="#12-7-3-创建-MySQL-服务" class="headerlink" title="12.7.3.    创建 MySQL 服务"></a>12.7.3.    创建 MySQL 服务</h3><p>创建服务相关命令已经在前边章节进行了介绍，这里直接列出命令。</p>
<p>docker network create -d overlay mysql_private</p>
<p>docker service create \</p>
<p>   –name mysql \</p>
<p>   –replicas 1 \</p>
<p>   –network mysql_private \</p>
<p>   –mount type=volume,source=mydata,destination=/var/lib/mysql \</p>
<p>   –secret source=mysql_root_password,target=mysql_root_password \</p>
<p>   –secret source=mysql_password,target=mysql_password \</p>
<p>   -e MYSQL_ROOT_PASSWORD_FILE=”/run/secrets/mysql_root_password” \</p>
<p>   -e MYSQL_PASSWORD_FILE=”/run/secrets/mysql_password” \</p>
<p>   -e MYSQL_USER=”wordpress” \</p>
<p>   -e MYSQL_DATABASE=”wordpress” \</p>
<p>   mysql:latest</p>
<p>如果你没有在 target 中显式的指定路径时，secret 默认通过 tmpfs 文件系统挂载到容器的 /run/secrets 目录中。</p>
<p>docker service create \</p>
<p>   –name wordpress \</p>
<p>   –replicas 1 \</p>
<p>   –network mysql_private \</p>
<p>   –publish target=30000,port=80 \</p>
<p>   –mount type=volume,source=wpdata,destination=/var/www/html \</p>
<p>   –secret source=mysql_password,target=wp_db_password,mode=0400 \</p>
<p>   -e WORDPRESS_DB_USER=”wordpress” \</p>
<p>   -e WORDPRESS_DB_PASSWORD_FILE=”/run/secrets/wp_db_password” \</p>
<p>   -e WORDPRESS_DB_HOST=”mysql:3306” \</p>
<p>   -e WORDPRESS_DB_NAME=”wordpress” \</p>
<p>   wordpress:latest</p>
<p>查看服务</p>
<p>docker service ls</p>
<p>ID      NAME  MODE    REPLICAS IMAGE</p>
<p>wvnh0siktqr3 mysql   replicated 1/1    mysql:latest</p>
<p>nzt5xzae4n62 wordpress replicated 1/1    wordpress:latest</p>
<p>现在浏览器访问 IP:30000，即可开始 WordPress 的安装与使用。</p>
<p>通过以上方法，我们没有像以前通过设置环境变量来设置 MySQL 密码， 而是采用 docker secret 来设置密码，防范了密码泄露的风险。</p>
<h2 id="12-8-Swarm-mode-管理配置信息"><a href="#12-8-Swarm-mode-管理配置信息" class="headerlink" title="12.8. Swarm mode 管理配置信息"></a>12.8. Swarm mode 管理配置信息</h2><p>在动态的、大规模的分布式集群上，管理和分发配置文件也是很重要的工作。传统的配置文件分发方式（如配置文件放入镜像中，设置环境变量，volume 动态挂载等）都降低了镜像的通用性。</p>
<p>在 Docker 17.06 以上版本中，Docker 新增了 docker config 子命令来管理集群中的配置信息，以后你无需将配置文件放入镜像或挂载到容器中就可实现对服务的配置。</p>
<p>注意：config 仅能在 Swarm 集群中使用。</p>
<p>这里我们以在 Swarm 集群中部署 redis 服务为例。</p>
<h3 id="12-8-1-创建-config"><a href="#12-8-1-创建-config" class="headerlink" title="12.8.1.    创建 config"></a>12.8.1.    创建 config</h3><p>新建 redis.conf 文件</p>
<p>port 6380</p>
<p>此项配置 Redis 监听 6380 端口</p>
<p>我们使用 docker config create 命令创建 config</p>
<p>docker config create redis.conf redis.conf</p>
<h3 id="12-8-2-查看-config"><a href="#12-8-2-查看-config" class="headerlink" title="12.8.2.    查看 config"></a>12.8.2.    查看 config</h3><p>使用 docker config ls 命令来查看 config</p>
<p>docker config ls</p>
<p>ID             NAME        CREATED       UPDATED</p>
<p>yod8fx8iiqtoo84jgwadp86yk  redis.conf     4 seconds ago    4 seconds ago</p>
<h3 id="12-8-3-创建-redis-服务"><a href="#12-8-3-创建-redis-服务" class="headerlink" title="12.8.3.    创建 redis 服务"></a>12.8.3.    创建 redis 服务</h3><p>docker service create \</p>
<p>   –name redis \</p>
<p>   # –config source=redis.conf,target=/etc/redis.conf \</p>
<p>   –config redis.conf \</p>
<p>   -p 6379:6380 \</p>
<p>   redis:latest \</p>
<p>   redis-server /redis.conf</p>
<p>如果你没有在 target 中显式的指定路径时，默认的 redis.conf 以 tmpfs 文件系统挂载到容器的 /config.conf。</p>
<p>经过测试，redis 可以正常使用。</p>
<p>以前我们通过监听主机目录来配置 Redis，就需要在集群的每个节点放置该文件，如果采用 docker config 来管理服务的配置信息，我们只需在集群中的管理节点创建 config，当部署服务时，集群会自动的将配置文件分发到运行服务的各个节点中，大大降低了配置信息的管理和分发难度。</p>
<h1 id="13-docker-安全"><a href="#13-docker-安全" class="headerlink" title="13.  docker 安全"></a>13.  docker 安全</h1><p>评估 Docker 的安全性时，主要考虑三个方面:</p>
<p>l 由内核的命名空间和控制组机制提供的容器内在安全</p>
<p>l Docker 程序（特别是服务端）本身的抗攻击性</p>
<p>l 内核安全性的加强机制对容器安全性的影响</p>
<h2 id="13-1-内核命名空间"><a href="#13-1-内核命名空间" class="headerlink" title="13.1. 内核命名空间"></a>13.1. 内核命名空间</h2><p>Docker 容器和 LXC 容器很相似，所提供的安全特性也差不多。当用 docker run 启动一个容器时，在后台 Docker 为容器创建了一个独立的命名空间和控制组集合。</p>
<p>命名空间提供了最基础也是最直接的隔离，在容器中运行的进程不会被运行在主机上的进程和其它容器发现和作用。</p>
<p>每个容器都有自己独有的网络栈，意味着它们不能访问其他容器的 sockets 或接口。不过，如果主机系统上做了相应的设置，容器可以像跟主机交互一样的和其他容器交互。当指定公共端口或使用 links 来连接 2 个容器时，容器就可以相互通信了（可以根据配置来限制通信的策略）。</p>
<p>从网络架构的角度来看，所有的容器通过本地主机的网桥接口相互通信，就像物理机器通过物理交换机通信一样。</p>
<p>那么，内核中实现命名空间和私有网络的代码是否足够成熟？</p>
<p>内核命名空间从 2.6.15 版本（2008 年 7 月发布）之后被引入，数年间，这些机制的可靠性在诸多大型生产系统中被实践验证。</p>
<p>实际上，命名空间的想法和设计提出的时间要更早，最初是为了在内核中引入一种机制来实现 OpenVZ 的特性。 而 OpenVZ 项目早在 2005 年就发布了，其设计和实现都已经十分成熟。</p>
<h2 id="13-2-控制组"><a href="#13-2-控制组" class="headerlink" title="13.2. 控制组"></a>13.2. 控制组</h2><p>控制组是 Linux 容器机制的另外一个关键组件，负责实现资源的审计和限制。</p>
<p>它提供了很多有用的特性；以及确保各个容器可以公平地分享主机的内存、CPU、磁盘 IO 等资源；当然，更重要的是，控制组确保了当容器内的资源使用产生压力时不会连累主机系统。</p>
<p>尽管控制组不负责隔离容器之间相互访问、处理数据和进程，它在防止拒绝服务（DDOS）攻击方面是必不可少的。尤其是在多用户的平台（比如公有或私有的 PaaS）上，控制组十分重要。例如，当某些应用程序表现异常的时候，可以保证一致地正常运行和性能。</p>
<p>控制组机制始于 2006 年，内核从 2.6.24 版本开始被引入。</p>
<h2 id="13-3-服务端防护"><a href="#13-3-服务端防护" class="headerlink" title="13.3. 服务端防护"></a>13.3. 服务端防护</h2><p>运行一个容器或应用程序的核心是通过 Docker 服务端。Docker 服务的运行目前需要 root 权限，因此其安全性十分关键。</p>
<p>首先，确保只有可信的用户才可以访问 Docker 服务。Docker 允许用户在主机和容器间共享文件夹，同时不需要限制容器的访问权限，这就容易让容器突破资源限制。例如，恶意用户启动容器的时候将主机的根目录/映射到容器的 /host 目录中，那么容器理论上就可以对主机的文件系统进行任意修改了。这听起来很疯狂？但是事实上几乎所有虚拟化系统都允许类似的资源共享，而没法禁止用户共享主机根文件系统到虚拟机系统。</p>
<p>这将会造成很严重的安全后果。因此，当提供容器创建服务时（例如通过一个 web 服务器），要更加注意进行参数的安全检查，防止恶意的用户用特定参数来创建一些破坏性的容器。</p>
<p>为了加强对服务端的保护，Docker 的 REST API（客户端用来跟服务端通信）在 0.5.2 之后使用本地的 Unix 套接字机制替代了原先绑定在 127.0.0.1 上的 TCP 套接字，因为后者容易遭受跨站脚本攻击。现在用户使用 Unix 权限检查来加强套接字的访问安全。</p>
<p>用户仍可以利用 HTTP 提供 REST API 访问。建议使用安全机制，确保只有可信的网络或 VPN，或证书保护机制（例如受保护的 stunnel 和 ssl 认证）下的访问可以进行。此外，还可以使用 HTTPS 和证书来加强保护。</p>
<p>最近改进的 Linux 命名空间机制将可以实现使用非 root 用户来运行全功能的容器。这将从根本上解决了容器和主机之间共享文件系统而引起的安全问题。</p>
<p>终极目标是改进 2 个重要的安全特性：</p>
<p>l 将容器的 root 用户映射到本地主机上的非 root 用户，减轻容器和主机之间因权限提升而引起的安全问题；</p>
<p>l 允许 Docker 服务端在非 root 权限下运行，利用安全可靠的子进程来代理执行需要特权权限的操作。这些子进程将只允许在限定范围内进行操作，例如仅仅负责虚拟网络设定或文件系统管理、配置操作等。</p>
<p>最后，建议采用专用的服务器来运行 Docker 和相关的管理服务（例如管理服务比如 ssh 监控和进程监控、管理工具 nrpe、collectd 等）。其它的业务服务都放到容器中去运行。</p>
<h2 id="13-4-内核能力机制"><a href="#13-4-内核能力机制" class="headerlink" title="13.4. 内核能力机制"></a>13.4. 内核能力机制</h2><p>能力机制（Capability）是 Linux 内核一个强大的特性，可以提供细粒度的权限访问控制。 Linux 内核自 2.2 版本起就支持能力机制，它将权限划分为更加细粒度的操作能力，既可以作用在进程上，也可以作用在文件上。</p>
<p>例如，一个 Web 服务进程只需要绑定一个低于 1024 的端口的权限，并不需要 root 权限。那么它只需要被授权 net_bind_service 能力即可。此外，还有很多其他的类似能力来避免进程获取 root 权限。</p>
<p>默认情况下，Docker 启动的容器被严格限制只允许使用内核的一部分能力。</p>
<p>使用能力机制对加强 Docker 容器的安全有很多好处。通常，在服务器上会运行一堆需要特权权限的进程，包括有 ssh、cron、syslogd、硬件管理工具模块（例如负载模块）、网络配置工具等等。容器跟这些进程是不同的，因为几乎所有的特权进程都由容器以外的支持系统来进行管理。</p>
<p>l ssh 访问被主机上ssh服务来管理；</p>
<p>l cron 通常应该作为用户进程执行，权限交给使用它服务的应用来处理；</p>
<p>l 日志系统可由 Docker 或第三方服务管理；</p>
<p>l 硬件管理无关紧要，容器中也就无需执行 udevd 以及类似服务；</p>
<p>l 网络管理也都在主机上设置，除非特殊需求，容器不需要对网络进行配置。</p>
<p>从上面的例子可以看出，大部分情况下，容器并不需要“真正的” root 权限，容器只需要少数的能力即可。为了加强安全，容器可以禁用一些没必要的权限。</p>
<p>l 完全禁止任何 mount 操作；</p>
<p>l 禁止直接访问本地主机的套接字；</p>
<p>l 禁止访问一些文件系统的操作，比如创建新的设备、修改文件属性等；</p>
<p>l 禁止模块加载。</p>
<p>这样，就算攻击者在容器中取得了 root 权限，也不能获得本地主机的较高权限，能进行的破坏也有限。</p>
<p>默认情况下，Docker采用白名单机制，禁用必需功能之外的其它权限。 当然，用户也可以根据自身需求来为 Docker 容器启用额外的权限。</p>
<h2 id="13-5-其它安全特性"><a href="#13-5-其它安全特性" class="headerlink" title="13.5. 其它安全特性"></a>13.5. 其它安全特性</h2><p>除了能力机制之外，还可以利用一些现有的安全机制来增强使用 Docker 的安全性，例如 TOMOYO, AppArmor, SELinux, GRSEC 等。</p>
<p>Docker 当前默认只启用了能力机制。用户可以采用多种方案来加强 Docker 主机的安全，例如：</p>
<p>l 在内核中启用 GRSEC 和 PAX，这将增加很多编译和运行时的安全检查；通过地址随机化避免恶意探测等。并且，启用该特性不需要 Docker 进行任何配置。</p>
<p>l 使用一些有增强安全特性的容器模板，比如带 AppArmor 的模板和 Redhat 带 SELinux 策略的模板。这些模板提供了额外的安全特性。</p>
<p>l 用户可以自定义访问控制机制来定制安全策略。</p>
<p>跟其它添加到 Docker 容器的第三方工具一样（比如网络拓扑和文件系统共享），有很多类似的机制，在不改变 Docker 内核情况下就可以加固现有的容器。</p>
<h2 id="13-6-安全总结"><a href="#13-6-安全总结" class="headerlink" title="13.6. 安全总结"></a>13.6. 安全总结</h2><p>总体来看，Docker 容器还是十分安全的，特别是在容器内不使用 root 权限来运行进程的话。</p>
<p>另外，用户可以使用现有工具，比如 Apparmor, SELinux, GRSEC 来增强安全性；甚至自己在内核中实现更复杂的安全机制。</p>
<h1 id="14-docker-底层实现"><a href="#14-docker-底层实现" class="headerlink" title="14.  docker 底层实现"></a>14.  docker 底层实现</h1><p>Docker 底层的核心技术包括 Linux 上的命名空间（Namespaces）、控制组（Control groups）、Union 文件系统（Union file systems）和容器格式（Container format）。</p>
<p>我们知道，传统的虚拟机通过在宿主主机中运行 hypervisor 来模拟一整套完整的硬件环境提供给虚拟机的操作系统。虚拟机系统看到的环境是可限制的，也是彼此隔离的。 这种直接的做法实现了对资源最完整的封装，但很多时候往往意味着系统资源的浪费。 例如，以宿主机和虚拟机系统都为 Linux 系统为例，虚拟机中运行的应用其实可以利用宿主机系统中的运行环境。</p>
<p>我们知道，在操作系统中，包括内核、文件系统、网络、PID、UID、IPC、内存、硬盘、CPU 等等，所有的资源都是应用进程直接共享的。 要想实现虚拟化，除了要实现对内存、CPU、网络IO、硬盘IO、存储空间等的限制外，还要实现文件系统、网络、PID、UID、IPC等等的相互隔离。 前者相对容易实现一些，后者则需要宿主机系统的深入支持。</p>
<p>随着 Linux 系统对于命名空间功能的完善实现，程序员已经可以实现上面的所有需求，让某些进程在彼此隔离的命名空间中运行。大家虽然都共用一个内核和某些运行时环境（例如一些系统命令和系统库），但是彼此却看不到，都以为系统中只有自己的存在。这种机制就是容器（Container），利用命名空间来做权限的隔离控制，利用 cgroups 来做资源分配。</p>
<h2 id="14-1-基本架构"><a href="#14-1-基本架构" class="headerlink" title="14.1. 基本架构"></a>14.1. 基本架构</h2><p>Docker 采用了 C/S 架构，包括客户端和服务端。Docker 守护进程 （Daemon）作为服务端接受来自客户端的请求，并处理这些请求（创建、运行、分发容器）。</p>
<p>客户端和服务端既可以运行在一个机器上，也可通过 socket 或者 RESTful API 来进行通信。</p>
<p>Docker 基本架构</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135152.jpg" alt="IMG_256"></p>
<p>Docker 守护进程一般在宿主主机后台运行，等待接收来自客户端的消息。</p>
<p>Docker 客户端则为用户提供一系列可执行命令，用户用这些命令实现跟 Docker 守护进程交互。</p>
<h2 id="14-2-命名空间"><a href="#14-2-命名空间" class="headerlink" title="14.2. 命名空间"></a>14.2. 命名空间</h2><p>命名空间是 Linux 内核一个强大的特性。每个容器都有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样。命名空间保证了容器之间彼此互不影响。</p>
<h3 id="14-2-1-pid-命名空间"><a href="#14-2-1-pid-命名空间" class="headerlink" title="14.2.1.    pid 命名空间"></a>14.2.1.    pid 命名空间</h3><p>不同用户的进程就是通过 pid 命名空间隔离开的，且不同命名空间中可以有相同 pid。所有的 LXC 进程在 Docker 中的父进程为Docker进程，每个 LXC 进程具有不同的命名空间。同时由于允许嵌套，因此可以很方便的实现嵌套的 Docker 容器。</p>
<h3 id="14-2-2-net-命名空间"><a href="#14-2-2-net-命名空间" class="headerlink" title="14.2.2.    net 命名空间"></a>14.2.2.    net 命名空间</h3><p>有了 pid 命名空间, 每个命名空间中的 pid 能够相互隔离，但是网络端口还是共享 host 的端口。网络隔离是通过 net 命名空间实现的， 每个 net 命名空间有独立的 网络设备, IP 地址, 路由表, /proc/net 目录。这样每个容器的网络就能隔离开来。Docker 默认采用 veth 的方式，将容器中的虚拟网卡同 host 上的一 个Docker 网桥 docker0 连接在一起。</p>
<h3 id="14-2-3-ipc-命名空间"><a href="#14-2-3-ipc-命名空间" class="headerlink" title="14.2.3.    ipc 命名空间"></a>14.2.3.    ipc 命名空间</h3><p>容器中进程交互还是采用了 Linux 常见的进程间交互方法(interprocess communication - IPC), 包括信号量、消息队列和共享内存等。然而同 VM 不同的是，容器的进程间交互实际上还是 host 上具有相同 pid 命名空间中的进程间交互，因此需要在 IPC 资源申请时加入命名空间信息，每个 IPC 资源有一个唯一的 32 位 id。</p>
<h3 id="14-2-4-mnt-命名空间"><a href="#14-2-4-mnt-命名空间" class="headerlink" title="14.2.4.    mnt 命名空间"></a>14.2.4.    mnt 命名空间</h3><p>类似 chroot，将一个进程放到一个特定的目录执行。mnt 命名空间允许不同命名空间的进程看到的文件结构不同，这样每个命名空间 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个命名空间中的容器在 /proc/mounts 的信息只包含所在命名空间的 mount point。</p>
<h3 id="14-2-5-uts-命名空间"><a href="#14-2-5-uts-命名空间" class="headerlink" title="14.2.5.    uts 命名空间"></a>14.2.5.    uts 命名空间</h3><p>UTS(“UNIX Time-sharing System”) 命名空间允许每个容器拥有独立的 hostname 和 domain name, 使其在网络上可以被视作一个独立的节点而非 主机上的一个进程。</p>
<h3 id="14-2-6-user-命名空间"><a href="#14-2-6-user-命名空间" class="headerlink" title="14.2.6.    user 命名空间"></a>14.2.6.    user 命名空间</h3><p>每个容器可以有不同的用户和组 id, 也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户。</p>
<h2 id="14-3-控制组"><a href="#14-3-控制组" class="headerlink" title="14.3. 控制组"></a>14.3. 控制组</h2><p>控制组（<a href="http://en.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroups</a>）是 Linux 内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，才能避免当多个容器同时运行时的对系统资源的竞争。</p>
<p>控制组技术最早是由 Google 的程序员在 2006 年提出，Linux 内核自 2.6.24 开始支持。</p>
<p>控制组可以提供对容器的内存、CPU、磁盘 IO 等资源的限制和审计管理。</p>
<h2 id="14-4-联合文件系统"><a href="#14-4-联合文件系统" class="headerlink" title="14.4. 联合文件系统"></a>14.4. 联合文件系统</h2><p>联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</p>
<p>联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。</p>
<p>Docker 中使用的 AUFS（AnotherUnionFS）就是一种联合文件系统。 AUFS 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 AUFS 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)。</p>
<p>Docker 目前支持的联合文件系统包括 OverlayFS, AUFS, Btrfs, VFS, ZFS 和 Device Mapper。</p>
<p>各 Linux 发行版 Docker 推荐使用的存储驱动如下表。</p>
<table>
<thead>
<tr>
<th><strong>Linux</strong> <strong>发行版</strong></th>
<th><strong>Docker</strong> <strong>推荐使用的存储驱动</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Docker CE on Ubuntu</td>
<td>aufs, devicemapper, overlay2 (Ubuntu  14.04.4 +, 16.04 +), overlay, zfs, vfs</td>
</tr>
<tr>
<td>Docker CE on Debian</td>
<td>aufs, devicemapper, overlay2 (Debian  Stretch), overlay, vfs</td>
</tr>
<tr>
<td>Docker CE on CentOS</td>
<td>devicemapper, vfs</td>
</tr>
<tr>
<td>Docker CE on Fedora</td>
<td>devicemapper, overlay2 (Fedora 26 +),  overlay (实验性支持), vfs</td>
</tr>
</tbody></table>
<p>在可能的情况下，推荐使用 overlay2 存储驱动，overlay2 是目前 Docker 默认的存储驱动，以前则是 aufs。你可以通过配置来使用以上提到的其他类型的存储驱动。</p>
<h2 id="14-5-容器格式"><a href="#14-5-容器格式" class="headerlink" title="14.5. 容器格式"></a>14.5. 容器格式</h2><p>最初，Docker 采用了 LXC 中的容器格式。从 0.7 版本以后开始去除 LXC，转而使用自行开发的 <a href="https://github.com/docker/libcontainer" target="_blank" rel="noopener">libcontainer</a>，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc" target="_blank" rel="noopener">runC</a> 和 <a href="https://containerd.tools/" target="_blank" rel="noopener">containerd</a>。</p>
<p>对更多容器格式的支持，还在进一步的发展中。</p>
<h2 id="14-6-网络"><a href="#14-6-网络" class="headerlink" title="14.6. 网络"></a>14.6. 网络</h2><p>Docker 的网络实现其实就是利用了 Linux 上的网络命名空间和虚拟网络设备（特别是 veth pair）。建议先熟悉了解这两部分的基本概念再阅读本章。</p>
<h3 id="14-6-1-基本原理"><a href="#14-6-1-基本原理" class="headerlink" title="14.6.1.    基本原理"></a>14.6.1.    基本原理</h3><p>首先，要实现网络通信，机器需要至少一个网络接口（物理接口或虚拟接口）来收发数据包；此外，如果不同子网之间要进行通信，需要路由机制。</p>
<p>Docker 中的网络接口默认都是虚拟的接口。虚拟接口的优势之一是转发效率较高。 Linux 通过在内核中进行数据复制来实现虚拟接口之间的数据转发，发送接口的发送缓存中的数据包被直接复制到接收接口的接收缓存中。对于本地系统和容器内系统看来就像是一个正常的以太网卡，只是它不需要真正同外部网络设备通信，速度要快很多。</p>
<p>Docker 容器网络就利用了这项技术。它在本地主机和容器内分别创建一个虚拟接口，并让它们彼此连通（这样的一对接口叫做 veth pair）。</p>
<h3 id="14-6-2-创建网络参数"><a href="#14-6-2-创建网络参数" class="headerlink" title="14.6.2.    创建网络参数"></a>14.6.2.    创建网络参数</h3><p>Docker 创建一个容器的时候，会执行如下操作：</p>
<p>l 创建一对虚拟接口，分别放到本地主机和新容器中；</p>
<p>l 本地主机一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 veth65f9；</p>
<p>l 容器一端放到新容器中，并修改名字作为 eth0，这个接口只在容器的命名空间可见；</p>
<p>l 从网桥可用地址段中获取一个空闲地址分配给容器的 eth0，并配置默认路由到桥接网卡 veth65f9。</p>
<p>完成这些之后，容器就可以使用 eth0 虚拟网卡来连接其他容器和其他网络。</p>
<p>可以在 docker run 的时候通过 –net 参数来指定容器的网络配置，有4个可选值：</p>
<p>l –net=bridge 这个是默认值，连接到默认的网桥。</p>
<p>l –net=host 告诉 Docker 不要将容器网络放到隔离的命名空间中，即不要容器化容器内的网络。此时容器使用本地主机的网络，它拥有完全的本地主机接口访问权限。容器进程可以跟主机其它 root 进程一样可以打开低范围的端口，可以访问本地网络服务比如 D-bus，还可以让容器做一些影响整个主机系统的事情，比如重启主机。因此使用这个选项的时候要非常小心。如果进一步的使用 –privileged=true，容器会被允许直接配置主机的网络堆栈。</p>
<p>l –net=container:NAME_or_ID 让 Docker 将新建容器的进程放到一个已存在容器的网络栈中，新容器进程有自己的文件系统、进程列表和资源限制，但会和已存在的容器共享 IP 地址和端口等网络资源，两者进程可以直接通过 lo 环回接口通信。</p>
<p>l –net=none 让 Docker 将新容器放到隔离的网络栈中，但是不进行网络配置。之后，用户可以自己进行配置。</p>
<h3 id="14-6-3-网络配置细节"><a href="#14-6-3-网络配置细节" class="headerlink" title="14.6.3.    网络配置细节"></a>14.6.3.    网络配置细节</h3><p>用户使用 –net=none 后，可以自行配置网络，让容器达到跟平常一样具有访问网络的权限。通过这个过程，可以了解 Docker 配置网络的细节。</p>
<p>首先，启动一个 /bin/bash 容器，指定 –net=none 参数。</p>
<p>docker run -i -t –rm –net=none base /bin/bash</p>
<p>root@63f36fc01b5f:/#</p>
<p>在本地主机查找容器的进程 id，并为它创建网络命名空间。</p>
<p>docker inspect -f ‘{.State.Pid}’ 63f36fc01b5f</p>
<p>2778</p>
<p>pid=2778</p>
<p>sudo mkdir -p /var/run/netns</p>
<p>sudo ln -s /proc/$pid/ns/net /var/run/netns/$pid</p>
<p>检查桥接网卡的 IP 和子网掩码信息。</p>
<p>ip addr show docker0</p>
<p>21: docker0: …</p>
<p>inet 172.17.42.1/16 scope global docker0</p>
<p>…</p>
<p>创建一对 “veth pair” 接口 A 和 B，绑定 A 到网桥 docker0，并启用它</p>
<p>sudo ip link add A type veth peer name B</p>
<p>sudo brctl addif docker0 A</p>
<p>sudo ip link set A up</p>
<p>将B放到容器的网络命名空间，命名为 eth0，启动它并配置一个可用 IP（桥接网段）和默认网关。</p>
<p>sudo ip link set B netns $pid</p>
<p>sudo ip netns exec $pid ip link set dev B name eth0</p>
<p>sudo ip netns exec $pid ip link set eth0 up</p>
<p>sudo ip netns exec $pid ip addr add 172.17.42.99/16 dev eth0</p>
<p>sudo ip netns exec $pid ip route add default via 172.17.42.1</p>
<p>以上，就是 Docker 配置网络的具体过程。</p>
<p>当容器结束后，Docker 会清空容器，容器内的 eth0 会随网络命名空间一起被清除，A 接口也被自动从 docker0 卸载。</p>
<p>此外，用户可以使用 ip netns exec 命令来在指定网络命名空间中进行配置，从而配置容器内的网络。</p>
<h1 id="15-附录"><a href="#15-附录" class="headerlink" title="15.  附录"></a>15.  附录</h1><h2 id="15-1-Docker-命令查询"><a href="#15-1-Docker-命令查询" class="headerlink" title="15.1. Docker 命令查询"></a>15.1. Docker 命令查询</h2><h3 id="15-1-1-基本语法"><a href="#15-1-1-基本语法" class="headerlink" title="15.1.1.    基本语法"></a>15.1.1.    基本语法</h3><p>Docker 命令有两大类，客户端命令和服务端命令。前者是主要的操作接口，后者用来启动 Docker Daemon。</p>
<p>客户端命令：基本命令格式为 docker [OPTIONS] COMMAND [arg…]；</p>
<p>服务端命令：基本命令格式为 dockerd [OPTIONS]。</p>
<p>可以通过 man docker 或 docker help 来查看这些命令。</p>
<h3 id="15-1-2-客户端命令选项"><a href="#15-1-2-客户端命令选项" class="headerlink" title="15.1.2.    客户端命令选项"></a>15.1.2.    客户端命令选项</h3><p>–config=””：指定客户端配置文件，默认为 <code>/.docker</code>；</p>
<p>-D=true|false：是否使用 debug 模式。默认不开启；</p>
<p>-H, –host=[]：指定命令对应 Docker 守护进程的监听接口，可以为 unix 套接字（unix:///path/to/socket），文件句柄（fd://socketfd）或 tcp 套接字（tcp://[host[:port]]），默认为 unix:///var/run/docker.sock；</p>
<p>-l, –log-level=”debug|info|warn|error|fatal”：指定日志输出级别；</p>
<p>–tls=true|false：是否对 Docker 守护进程启用 TLS 安全机制，默认为否；</p>
<p>–tlscacert= /.docker/ca.pem：TLS CA 签名的可信证书文件路径；</p>
<p>–tlscert= /.docker/cert.pem：TLS 可信证书文件路径；</p>
<p>–tlscert= /.docker/key.pem：TLS 密钥文件路径；</p>
<p>–tlsverify=true|false：启用 TLS 校验，默认为否。</p>
<h3 id="15-1-3-dockerd-命令选项"><a href="#15-1-3-dockerd-命令选项" class="headerlink" title="15.1.3.    dockerd 命令选项"></a>15.1.3.    dockerd 命令选项</h3><p>–api-cors-header=””：CORS 头部域，默认不允许 CORS，要允许任意的跨域访问，可以指定为 “*”；</p>
<p>–authorization-plugin=””：载入认证的插件；</p>
<p>-b=””：将容器挂载到一个已存在的网桥上。指定为 ‘none’ 时则禁用容器的网络，与 –bip 选项互斥；</p>
<p>–bip=””：让动态创建的 docker0 网桥采用给定的 CIDR 地址; 与 -b 选项互斥；</p>
<p>–cgroup-parent=””：指定 cgroup 的父组，默认 fs cgroup 驱动为 <code>/docker</code>，systemd cgroup 驱动为 <code>system.slice</code>；</p>
<p>–cluster-store=””：构成集群（如 Swarm）时，集群键值数据库服务地址；</p>
<p>–cluster-advertise=””：构成集群时，自身的被访问地址，可以为 <code>host:port</code> 或 <code>interface:port</code>；</p>
<p>–cluster-store-opt=””：构成集群时，键值数据库的配置选项；</p>
<p>–config-file=”/etc/docker/daemon.json”：daemon 配置文件路径；</p>
<p>–containerd=””：containerd 文件的路径；</p>
<p>-D, –debug=true|false：是否使用 Debug 模式。缺省为 false；</p>
<p>–default-gateway=””：容器的 IPv4 网关地址，必须在网桥的子网段内；</p>
<p>–default-gateway-v6=””：容器的 IPv6 网关地址；</p>
<p>–default-ulimit=[]：默认的 ulimit 值；</p>
<p>–disable-legacy-registry=true|false：是否允许访问旧版本的镜像仓库服务器；</p>
<p>–dns=””：指定容器使用的 DNS 服务器地址；</p>
<p>–dns-opt=””：DNS 选项；</p>
<p>–dns-search=[]：DNS 搜索域；</p>
<p>–exec-opt=[]：运行时的执行选项；</p>
<p>–exec-root=””：容器执行状态文件的根路径，默认为 <code>/var/run/docker</code>；</p>
<p>–fixed-cidr=””：限定分配 IPv4 地址范围；</p>
<p>–fixed-cidr-v6=””：限定分配 IPv6 地址范围；</p>
<p>-G, –group=””：分配给 unix 套接字的组，默认为 <code>docker</code>；</p>
<p>-g, –graph=””：Docker 运行时的根路径，默认为 <code>/var/lib/docker</code>；</p>
<p>-H, –host=[]：指定命令对应 Docker daemon 的监听接口，可以为 unix 套接字（unix:///path/to/socket），文件句柄（fd://socketfd）或 tcp 套接字（tcp://[host[:port]]），默认为 unix:///var/run/docker.sock；</p>
<p>–icc=true|false：是否启用容器间以及跟 daemon 所在主机的通信。默认为 true。</p>
<p>–insecure-registry=[]：允许访问给定的非安全仓库服务；</p>
<p>–ip=””：绑定容器端口时候的默认 IP 地址。缺省为 0.0.0.0；</p>
<p>–ip-forward=true|false：是否检查启动在 Docker 主机上的启用 IP 转发服务，默认开启。注意关闭该选项将不对系统转发能力进行任何检查修改；</p>
<p>–ip-masq=true|false：是否进行地址伪装，用于容器访问外部网络，默认开启；</p>
<p>–iptables=true|false：是否允许 Docker 添加 iptables 规则。缺省为 true；</p>
<p>–ipv6=true|false：是否启用 IPv6 支持，默认关闭；</p>
<p>-l, –log-level=”debug|info|warn|error|fatal”：指定日志输出级别；</p>
<p>–label=”[]”：添加指定的键值对标注；</p>
<p>–log-driver=”json-file|syslog|journald|gelf|fluentd|awslogs|splunk|etwlogs|gcplogs|none”：指定日志后端驱动，默认为 json-file；</p>
<p>–log-opt=[]：日志后端的选项；</p>
<p>–mtu=VALUE：指定容器网络的 mtu；</p>
<p>-p=””：指定 daemon 的 PID 文件路径。缺省为 <code>/var/run/docker.pid</code>；</p>
<p>–raw-logs：输出原始，未加色彩的日志信息；</p>
<p>–registry-mirror=<scheme>://<host>：指定 <code>docker pull</code> 时使用的注册服务器镜像地址；</p>
<p>-s, –storage-driver=””：指定使用给定的存储后端；</p>
<p>–selinux-enabled=true|false：是否启用 SELinux 支持。缺省值为 false。SELinux 目前尚不支持 overlay 存储驱动；</p>
<p>–storage-opt=[]：驱动后端选项；</p>
<p>–tls=true|false：是否对 Docker daemon 启用 TLS 安全机制，默认为否；</p>
<p>–tlscacert= /.docker/ca.pem：TLS CA 签名的可信证书文件路径；</p>
<p>–tlscert= /.docker/cert.pem：TLS 可信证书文件路径；</p>
<p>–tlscert= /.docker/key.pem：TLS 密钥文件路径；</p>
<p>–tlsverify=true|false：启用 TLS 校验，默认为否；</p>
<p>–userland-proxy=true|false：是否使用用户态代理来实现容器间和出容器的回环通信，默认为 true；</p>
<p>–userns-remap=default|uid:gid|user:group|user|uid：指定容器的用户命名空间，默认是创建新的 UID 和 GID 映射到容器内进程。</p>
<h3 id="15-1-4-客户端命令"><a href="#15-1-4-客户端命令" class="headerlink" title="15.1.4.    客户端命令"></a>15.1.4.    客户端命令</h3><p>可以通过 docker COMMAND –help 来查看这些命令的具体用法。</p>
<p>attach：依附到一个正在运行的容器中；</p>
<p>build：从一个 Dockerfile 创建一个镜像；</p>
<p>commit：从一个容器的修改中创建一个新的镜像；</p>
<p>cp：在容器和本地宿主系统之间复制文件中；</p>
<p>create：创建一个新容器，但并不运行它；</p>
<p>diff：检查一个容器内文件系统的修改，包括修改和增加；</p>
<p>events：从服务端获取实时的事件；</p>
<p>exec：在运行的容器内执行命令；</p>
<p>export：导出容器内容为一个 tar 包；</p>
<p>history：显示一个镜像的历史信息；</p>
<p>images：列出存在的镜像；</p>
<p>import：导入一个文件（典型为 tar 包）路径或目录来创建一个本地镜像；</p>
<p>info：显示一些相关的系统信息；</p>
<p>inspect：显示一个容器的具体配置信息；</p>
<p>kill：关闭一个运行中的容器 (包括进程和所有相关资源)；</p>
<p>load：从一个 tar 包中加载一个镜像；</p>
<p>login：注册或登录到一个 Docker 的仓库服务器；</p>
<p>logout：从 Docker 的仓库服务器登出；</p>
<p>logs：获取容器的 log 信息；</p>
<p>network：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；</p>
<p>node：管理 swarm 集群中的节点，包括查看、更新、删除、提升/取消管理节点等；</p>
<p>pause：暂停一个容器中的所有进程；</p>
<p>port：查找一个 nat 到一个私有网口的公共口；</p>
<p>ps：列出主机上的容器；</p>
<p>pull：从一个Docker的仓库服务器下拉一个镜像或仓库；</p>
<p>push：将一个镜像或者仓库推送到一个 Docker 的注册服务器；</p>
<p>rename：重命名一个容器；</p>
<p>restart：重启一个运行中的容器；</p>
<p>rm：删除给定的若干个容器；</p>
<p>rmi：删除给定的若干个镜像；</p>
<p>run：创建一个新容器，并在其中运行给定命令；</p>
<p>save：保存一个镜像为 tar 包文件；</p>
<p>search：在 Docker index 中搜索一个镜像；</p>
<p>service：管理 Docker 所启动的应用服务，包括创建、更新、删除等；</p>
<p>start：启动一个容器；</p>
<p>stats：输出（一个或多个）容器的资源使用统计信息；</p>
<p>stop：终止一个运行中的容器；</p>
<p>swarm：管理 Docker swarm 集群，包括创建、加入、退出、更新等；</p>
<p>tag：为一个镜像打标签；</p>
<p>top：查看一个容器中的正在运行的进程信息；</p>
<p>unpause：将一个容器内所有的进程从暂停状态中恢复；</p>
<p>update：更新指定的若干容器的配置信息；</p>
<p>version：输出 Docker 的版本信息；</p>
<p>volume：管理 Docker volume，包括查看、创建、删除等；</p>
<p>wait：阻塞直到一个容器终止，然后输出它的退出符。</p>
<h3 id="15-1-5-一张图总结-Docker-的命令"><a href="#15-1-5-一张图总结-Docker-的命令" class="headerlink" title="15.1.5.    一张图总结 Docker 的命令"></a>15.1.5.    一张图总结 Docker 的命令</h3><p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135205.jpg" alt="IMG_256"></p>
<h2 id="15-2-Docker-资源链接"><a href="#15-2-Docker-资源链接" class="headerlink" title="15.2. Docker 资源链接"></a>15.2. Docker 资源链接</h2><h3 id="15-2-1-官方网站"><a href="#15-2-1-官方网站" class="headerlink" title="15.2.1.    官方网站"></a>15.2.1.    官方网站</h3><p>l Docker 官方主页：<a href="https://www.docker.com" target="_blank" rel="noopener">https://www.docker.com</a></p>
<p>l Docker 官方博客：<a href="https://blog.docker.com/" target="_blank" rel="noopener">https://blog.docker.com/</a></p>
<p>l Docker 官方文档：<a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></p>
<p>l Docker Store：<a href="https://store.docker.com" target="_blank" rel="noopener">https://store.docker.com</a></p>
<p>l Docker Cloud：<a href="https://cloud.docker.com" target="_blank" rel="noopener">https://cloud.docker.com</a></p>
<p>l Docker Hub：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a></p>
<p>l Docker 的源代码仓库：<a href="https://github.com/moby/moby" target="_blank" rel="noopener">https://github.com/moby/moby</a></p>
<p>l Docker 发布版本历史：<a href="https://docs.docker.com/release-notes/" target="_blank" rel="noopener">https://docs.docker.com/release-notes/</a></p>
<p>l Docker 常见问题：<a href="https://docs.docker.com/engine/faq/" target="_blank" rel="noopener">https://docs.docker.com/engine/faq/</a></p>
<p>l Docker 远端应用 API：<a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">https://docs.docker.com/develop/sdk/</a></p>
<h3 id="15-2-2-实践参考"><a href="#15-2-2-实践参考" class="headerlink" title="15.2.2.    实践参考"></a>15.2.2.    实践参考</h3><p>l Dockerfile 参考：<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></p>
<p>l Dockerfile 最佳实践：</p>
<p>l <a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/</a></p>
<h3 id="15-2-3-技术交流"><a href="#15-2-3-技术交流" class="headerlink" title="15.2.3.    技术交流"></a>15.2.3.    技术交流</h3><p>l Docker 邮件列表： <a href="https://groups.google.com/forum/#!forum/docker-user" target="_blank" rel="noopener">https://groups.google.com/forum/#!forum/docker-user</a></p>
<p>l Docker 的 IRC 频道：<a href="https://chat.freenode.net#docker" target="_blank" rel="noopener">https://chat.freenode.net#docker</a></p>
<p>l Docker 的 Twitter 主页：<a href="https://twitter.com/docker" target="_blank" rel="noopener">https://twitter.com/docker</a></p>
<h3 id="15-2-4-其它"><a href="#15-2-4-其它" class="headerlink" title="15.2.4.    其它"></a>15.2.4.    其它</h3><p>l Docker 的 StackOverflow 问答主页：<a href="https://stackoverflow.com/search?q=docker" target="_blank" rel="noopener">https://stackoverflow.com/search?q=docker</a></p>

          
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.songwh.top/2020/02/05/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E9%9B%86%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="浩子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/head.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="浩子同学">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/05/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E9%9B%86%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/" itemprop="url">Java网络编程的集中实现方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-05T00:00:00+08:00">
                2020-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A7/" itemprop="url" rel="index">
                    <span itemprop="name">奇技淫巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>从JDK提供的BIO到NIO，从tomcat到Netty，网络是这个互联网世界永远不可缺少的一个环节。</p>
<p>这里介绍利用Java实现的一个服务端对应多个客户端的聊天功能的几种方式：</p>
<ol>
<li>传统的BIO</li>
<li>JDK提供的NIO</li>
<li>Netty高效网络框架</li>
</ol>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/02/05/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E9%9B%86%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    
	<div>
	  
	</div>

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.png"
                alt="浩子" />
            
              <p class="site-author-name" itemprop="name">浩子</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">87</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">84</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">浩子</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
