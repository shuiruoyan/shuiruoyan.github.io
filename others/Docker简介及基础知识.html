<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon_32x32.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon_16x16.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content=",," />










<meta name="description" content="Docker简介及基础知识">
<meta property="og:type" content="website">
<meta property="og:title" content="Docker简介及基础知识">
<meta property="og:url" content="http://www.songwh.top/others/Docker%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html">
<meta property="og:site_name" content="浩子同学">
<meta property="og:description" content="Docker简介及基础知识">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134707.gif">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134711.gif">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134719.jpg">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134729.jpg">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134748.gif">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134756.gif">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134801.gif">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134804.gif">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134807.gif">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134811.gif">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134815.gif">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134818.gif">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134821.gif">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134833.gif">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134836.gif">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135244.jpg">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134944.gif">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135253.gif">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135124.jpg">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135127.jpg">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135135.gif">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135152.jpg">
<meta property="og:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135205.jpg">
<meta property="article:published_time" content="2020-03-30T16:00:00.000Z">
<meta property="article:modified_time" content="2020-04-06T10:49:05.011Z">
<meta property="article:author" content="浩子">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134707.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.songwh.top/others/Docker简介及基础知识.html"/>





  <title>Docker简介及基础知识 | 浩子同学</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">浩子同学</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">我的精神家园</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-主页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            主页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-归档">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-关于">
          <a href="/about.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    
    
    
    <div class="post-block page">
      <header class="post-header">

	<h1 class="post-title" itemprop="name headline">Docker简介及基础知识</h1>



</header>

      
      
      
      <div class="post-body">
        
        
          <p>Docker简介及基础知识</p>
<a id="more"></a>

<h1 id="1-Docker-简介"><a href="#1-Docker-简介" class="headerlink" title="1. Docker 简介"></a>1. Docker 简介</h1><h2 id="1-1-docker-是什么"><a href="#1-1-docker-是什么" class="headerlink" title="1.1.   docker 是什么"></a>1.1.   docker 是什么</h2><p>Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 <a href="https://github.com/moby/moby" target="_blank" rel="noopener">GitHub</a> 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 <a href="https://www.opencontainers.org/" target="_blank" rel="noopener">开放容器联盟（OCI）</a>。</p>
<p>Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目已经超过 4 万 6 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。</p>
<p>Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 AUFS 类的 Union FS 等技术，对进程进行封装隔离，属于 操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。最初实现是基于 LXC，从 0.7 版本以后开始去除 LXC，转而使用自行开发的 libcontainer，从 1.11 开始，则进一步演进为使用 runC 和 containerd。</p>
<p>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。</p>
<p>下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134707.gif" alt="传统虚拟化"></p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134711.gif" alt="Docker"></p>
<h2 id="1-2-为什么要使用-docker"><a href="#1-2-为什么要使用-docker" class="headerlink" title="1.2.   为什么要使用 docker"></a>1.2.   为什么要使用 docker</h2><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。</p>
<p><strong>更高效的利用系统资源</strong></p>
<p>由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。</p>
<p><strong>更快速的启动时间</strong></p>
<p>传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。</p>
<p><strong>一致的运行环境</strong></p>
<p>开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。</p>
<p><strong>持续交付和部署</strong></p>
<p>对开发和运维（DevOps）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。</p>
<p>使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) 系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) 系统进行自动部署。</p>
<p>而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。</p>
<p><strong>更轻松的迁移</strong></p>
<p>由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。</p>
<p><strong>更轻松的维护和扩展</strong></p>
<p>Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。</p>
<p><strong>对比传统虚拟机总结</strong></p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>容器</strong></th>
<th><strong>虚拟机</strong></th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>一般为 MB</td>
<td>一般为 GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
</tbody></table>
<h1 id="2-docker-基本概念"><a href="#2-docker-基本概念" class="headerlink" title="2. docker 基本概念"></a>2. docker 基本概念</h1><p>Docker 包括三个基本概念</p>
<p>l 镜像（Image）</p>
<p>l 容器（Container）</p>
<p>l 仓库（Repository）</p>
<p>理解了这三个概念，就理解了 Docker 的整个生命周期。</p>
<h2 id="2-1-docker-引擎"><a href="#2-1-docker-引擎" class="headerlink" title="2.1.   docker 引擎"></a>2.1.   docker 引擎</h2><p>Docker 引擎是一个包含以下主要组件的客户端服务器应用程序。</p>
<p>l 一种服务器，它是一种称为守护进程并且长时间运行的程序。</p>
<p>l REST API用于指定程序可以用来与守护进程通信的接口，并指示它做什么。</p>
<p>l 一个有命令行界面 (CLI) 工具的客户端。</p>
<p>Docker 引擎组件的流程如下图所示：</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134719.jpg" alt="https://www.funtl.com/assets/620140640_31678.png"></p>
<h2 id="2-2-docker-系统架构"><a href="#2-2-docker-系统架构" class="headerlink" title="2.2.   docker 系统架构"></a>2.2.   docker 系统架构</h2><p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程 API 来管理和创建 Docker 容器。</p>
<p>Docker 容器通过 Docker 镜像来创建。</p>
<p>容器与镜像的关系类似于面向对象编程中的对象与类。</p>
<table>
<thead>
<tr>
<th><strong>Docker</strong></th>
<th><strong>面向对象</strong></th>
</tr>
</thead>
<tbody><tr>
<td>容器</td>
<td>对象</td>
</tr>
<tr>
<td>镜像</td>
<td>类</td>
</tr>
</tbody></table>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134729.jpg" alt="https://www.funtl.com/assets/262150629_86976.png"></p>
<table>
<thead>
<tr>
<th><strong>标题</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>镜像(Images)</td>
<td>Docker 镜像是用于创建 Docker 容器的模板。</td>
</tr>
<tr>
<td>容器(Container)</td>
<td>容器是独立运行的一个或一组应用。</td>
</tr>
<tr>
<td>客户端(Client)</td>
<td>Docker 客户端通过命令行或者其他工具使用 Docker API (<a href="https://docs.docker.com/reference/api/docker_remote_api" target="_blank" rel="noopener">https://docs.docker.com/reference/api/docker_remote_api</a>)  与 Docker 的守护进程通信。</td>
</tr>
<tr>
<td>主机(Host)</td>
<td>一个物理或者虚拟的机器用于执行  Docker 守护进程和容器。</td>
</tr>
<tr>
<td>仓库(Registry)</td>
<td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub(<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。</td>
</tr>
<tr>
<td>Docker Machine</td>
<td>Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td>
</tr>
</tbody></table>
<h2 id="2-3-docker-镜像"><a href="#2-3-docker-镜像" class="headerlink" title="2.3.   docker 镜像"></a>2.3.   docker 镜像</h2><p>我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu 16.04 最小系统的 root 文件系统。</p>
<p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<p><strong>分层存储</strong></p>
<p>因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。</p>
<p>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p>
<p>分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。</p>
<p>关于镜像构建，将会在后续相关章节中做进一步的讲解。</p>
<h2 id="2-4-docker-容器"><a href="#2-4-docker-容器" class="headerlink" title="2.4.   docker 容器"></a>2.4.   docker 容器</h2><p>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</p>
<p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。也因为这种隔离的特性，很多人初学 Docker 时常常会混淆容器和虚拟机。</p>
<p>前面讲过镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，我们可以称这个为容器运行时读写而准备的存储层为容器存储层。</p>
<p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。</p>
<p>按照 Docker 最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用 数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p>
<p>数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。</p>
<h2 id="2-5-docker-仓库"><a href="#2-5-docker-仓库" class="headerlink" title="2.5.   docker 仓库"></a>2.5.   docker 仓库</h2><p>镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。</p>
<p>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。</p>
<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p>
<p>以 Ubuntu 镜像 为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，14.04, 16.04。我们可以通过 ubuntu:14.04，或者 ubuntu:16.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。</p>
<p>仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。</p>
<h3 id="2-5-1-公有-Docker-Registry"><a href="#2-5-1-公有-Docker-Registry" class="headerlink" title="2.5.1. 公有 Docker Registry"></a>2.5.1. 公有 Docker Registry</h3><p>Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p>
<p>最常使用的 Registry 公开服务是官方的 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 <a href="https://coreos.com/" target="_blank" rel="noopener">CoreOS </a>的 <a href="https://quay.io/repository/" target="_blank" rel="noopener">Quay.io</a>，CoreOS 相关的镜像存储在这里；Google 的 <a href="https://cloud.google.com/container-registry/" target="_blank" rel="noopener">Google Container Registry</a>，Kubernetes 的镜像使用的就是这个服务。</p>
<p>由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为加速器。常见的有 <a href="https://cr.console.aliyun.com/#/accelerator" target="_blank" rel="noopener">阿里云加速器</a>、<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud 加速器</a> 等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。</p>
<p>国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://hub.tenxcloud.com/" target="_blank" rel="noopener">时速云镜像仓库</a>、<a href="https://c.163.com/hub#/m/library/" target="_blank" rel="noopener">网易云镜像服务</a>、<a href="https://hub.daocloud.io/" target="_blank" rel="noopener">DaoCloud 镜像市场</a>、<a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener">阿里云镜像库</a> 等。</p>
<h3 id="2-5-2-私有-Docker-Registry"><a href="#2-5-2-私有-Docker-Registry" class="headerlink" title="2.5.2. 私有 Docker Registry"></a>2.5.2. 私有 Docker Registry</h3><p>除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 <a href="https://store.docker.com/images/registry/" target="_blank" rel="noopener">Docker Registry</a> 镜像，可以直接使用做为私有 Registry 服务。</p>
<p>开源的 Docker Registry 镜像只提供了 <a href="https://docs.docker.com/registry/spec/api/" target="_blank" rel="noopener">Docker Registry API</a> 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。在官方的商业化版本 <a href="https://docs.docker.com/datacenter/dtr/2.0/" target="_blank" rel="noopener">Docker Trusted Registry</a> 中，提供了这些高级功能。</p>
<p>除了官方的 Docker Registry 外，还有第三方软件实现了 Docker Registry API，甚至提供了用户界面以及一些高级功能。比如，<a href="https://github.com/vmware/harbor" target="_blank" rel="noopener">VMWare Harbor</a> 和 <a href="https://www.sonatype.com/docker" target="_blank" rel="noopener">Sonatype Nexus</a>。</p>
<h1 id="3-docker-安装"><a href="#3-docker-安装" class="headerlink" title="3. docker 安装"></a>3. docker 安装</h1><p>Docker 在 1.13 版本之后，从 2017 年的 3 月 1 日开始，版本命名规则变为如下：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>版本格式</td>
<td>YY.MM</td>
</tr>
<tr>
<td>Stable 版本</td>
<td>每个季度发行</td>
</tr>
<tr>
<td>Edge 版本</td>
<td>每个月发行</td>
</tr>
</tbody></table>
<p>同时 Docker 划分为 CE 和 EE。CE 即社区版（免费，支持周期三个月），EE 即企业版，强调安全，付费使用。</p>
<p>Docker CE 每月发布一个 Edge 版本 (17.03, 17.04, 17.05…)，每三个月发布一个 Stable 版本 (17.03, 17.06, 17.09…)，Docker EE 和 Stable 版本号保持一致，但每个版本提供一年维护。</p>
<p>官方网站上有各种环境下的 <a href="https://docs.docker.com/engine/installation/" target="_blank" rel="noopener">安装指南</a>，这里主要介绍 Docker CE 在 Linux 、Windows 10 (PC) 和 macOS 上的安装。</p>
<h2 id="3-1-ubuntu-安装docker"><a href="#3-1-ubuntu-安装docker" class="headerlink" title="3.1.   ubuntu 安装docker"></a>3.1.   ubuntu 安装docker</h2><p>警告：切勿在没有配置 Docker APT 源的情况下直接使用 apt 命令安装 Docker.</p>
<h3 id="3-1-1-准备工作"><a href="#3-1-1-准备工作" class="headerlink" title="3.1.1. 准备工作"></a><strong>3.1.1.</strong> <strong>准备工作</strong></h3><p><strong>1**</strong>、系统要求**</p>
<p>Docker CE 支持以下版本的 Ubuntu 操作系统：</p>
<p>l Artful 17.10 (Docker CE 17.11 Edge +)</p>
<p>l Xenial 16.04 (LTS)</p>
<p>l Trusty 14.04 (LTS)</p>
<p>Docker CE 可以安装在 64 位的 x86 平台或 ARM 平台上。Ubuntu 发行版中，LTS（Long-Term-Support）长期支持版本，会获得 5 年的升级维护支持，这样的版本会更稳定，因此在生产环境中推荐使用 LTS 版本,当前最新的 LTS 版本为 Ubuntu 16.04。</p>
<p><strong>2**</strong>、卸载旧版本**</p>
<p>旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：</p>
<p>sudo apt-get remove docker docker-engine docker.io</p>
<p><strong>3**</strong>、Ubuntu 14.04 可选内核模块**</p>
<p>从 Ubuntu 14.04 开始，一部分内核模块移到了可选内核模块包 (linux-image-extra-*) ，以减少内核软件包的体积。正常安装的系统应该会包含可选内核模块包，而一些裁剪后的系统可能会将其精简掉。AUFS 内核驱动属于可选内核模块的一部分，作为推荐的 Docker 存储层驱动，一般建议安装可选内核模块包以使用 AUFS。</p>
<p>如果系统没有安装可选内核模块的话，可以执行下面的命令来安装可选内核模块包：</p>
<p>sudo apt-get update</p>
<p>sudo apt-get install linux-image-extra-$(uname -r) linux-image-extra-virtual</p>
<p><strong>4**</strong>、Ubuntu 16.04 +**</p>
<p>Ubuntu 16.04 + 上的 Docker CE 默认使用 overlay2 存储层驱动,无需手动配置。</p>
<h3 id="3-1-2-使用-APT-安装"><a href="#3-1-2-使用-APT-安装" class="headerlink" title="3.1.2. 使用 APT 安装"></a><strong>3.1.2.</strong> <strong>使用 APT 安装</strong></h3><p>安装必要的一些系统工具</p>
<p>sudo apt-get update</p>
<p>sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common</p>
<p>安装 GPG 证书</p>
<p>curl -fsSL <a href="http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg" target="_blank" rel="noopener">http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg</a> | sudo apt-key add -</p>
<p>写入软件源信息</p>
<p>sudo add-apt-repository “deb [arch=amd64] <a href="http://mirrors.aliyun.com/docker-ce/linux/ubuntu" target="_blank" rel="noopener">http://mirrors.aliyun.com/docker-ce/linux/ubuntu</a> $(lsb_release -cs) stable”</p>
<p>更新并安装 Docker CE</p>
<p>sudo apt-get -y update</p>
<p>sudo apt-get -y install docker-ce</p>
<p>以上命令会添加稳定版本的 Docker CE APT 镜像源，如果需要最新或者测试版本的 Docker CE 请将 stable 改为 edge 或者 test。从 Docker 17.06 开始，edge test 版本的 APT 镜像源也会包含稳定版本的 Docker。</p>
<h3 id="3-1-3-使用脚本自动安装"><a href="#3-1-3-使用脚本自动安装" class="headerlink" title="3.1.3. 使用脚本自动安装"></a><strong>3.1.3.</strong> <strong>使用脚本自动安装</strong></h3><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，Ubuntu 系统上可以使用这套脚本安装：</p>
<p>curl -fsSL get.docker.com -o get-docker.sh</p>
<p># 可能会出现 404 错误，请移步下面的特别说明</p>
<p>sudo sh get-docker.sh –mirror Aliyun</p>
<p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。</p>
<p><strong>特别说明</strong></p>
<p>2018 年 7 月 21 日，貌似阿里云这边在做调整，故导致 Docker 的 Aliyun 安装脚本不可用，是永久性还是临时性的尚不清除，如果你已经按照之前的操作安装 Docker，请按以下步骤进行修复并重新安装</p>
<p>l 如果已经使用了 Aliyun 脚本安装并成功的</p>
<p>ü 请先卸载 Docker，命令为：apt-get autoremove docker-ce</p>
<p>ü 删除 /etc/apt/sources.list.d 目录下的 docker.list 文件</p>
<p>l 使用 AzureChinaCloud 镜像脚本重新安装，命令为：sudo sh get-docker.sh –mirror AzureChinaCloud</p>
<h3 id="3-1-4-启动-Docker-CE"><a href="#3-1-4-启动-Docker-CE" class="headerlink" title="3.1.4. 启动 Docker CE"></a>3.1.4. 启动 Docker CE</h3><p>sudo systemctl enable docker</p>
<p>sudo systemctl start docker</p>
<p>Ubuntu 14.04 请使用以下命令启动：</p>
<p>sudo service docker start</p>
<h3 id="3-1-5-建立-docker-用户组"><a href="#3-1-5-建立-docker-用户组" class="headerlink" title="3.1.5. 建立 docker 用户组"></a>3.1.5. 建立 docker 用户组</h3><p>默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。</p>
<p>建立 docker 组：</p>
<p>sudo groupadd docker</p>
<p>将当前用户加入 docker 组：</p>
<p>sudo usermod -aG docker $USER</p>
<p>退出当前终端并重新登录，进行如下测试。</p>
<h3 id="3-1-6-测试-Docker-是否安装正确"><a href="#3-1-6-测试-Docker-是否安装正确" class="headerlink" title="3.1.6. 测试 Docker 是否安装正确"></a>3.1.6. 测试 Docker 是否安装正确</h3><p>docker run hello-world</p>
<p>Unable to find image ‘hello-world:latest’ locally</p>
<p>latest: Pulling from library/hello-world</p>
<p>ca4f61b1923c: Pull complete</p>
<p>Digest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905c</p>
<p>Status: Downloaded newer image for hello-world:latest</p>
<p>Hello from Docker!</p>
<p>This message shows that your installation appears to be working correctly.</p>
<p>To generate this message, Docker took the following steps:</p>
<p> \1. The Docker client contacted the Docker daemon.</p>
<p> \2. The Docker daemon pulled the “hello-world” image from the Docker Hub.</p>
<p>  (amd64)</p>
<p> \3. The Docker daemon created a new container from that image which runs the</p>
<p>  executable that produces the output you are currently reading.</p>
<p> \4. The Docker daemon streamed that output to the Docker client, which sent it</p>
<p>  to your terminal.</p>
<p>To try something more ambitious, you can run an Ubuntu container with:</p>
<p> $ docker run -it ubuntu bash</p>
<p>Share images, automate workflows, and more with a free Docker ID:</p>
<p> <a href="https://cloud.docker.com/" target="_blank" rel="noopener">https://cloud.docker.com/</a></p>
<p>For more examples and ideas, visit:</p>
<p> <a href="https://docs.docker.com/engine/userguide/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/</a></p>
<p>若能正常输出以上信息，则说明安装成功。</p>
<h3 id="3-1-7-镜像加速"><a href="#3-1-7-镜像加速" class="headerlink" title="3.1.7. 镜像加速"></a>3.1.7. 镜像加速</h3><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，强烈建议安装 Docker 之后配置 国内镜像加速。</p>
<h3 id="3-1-8-参考文档"><a href="#3-1-8-参考文档" class="headerlink" title="3.1.8. 参考文档"></a>3.1.8. 参考文档</h3><p><a href="https://docs.docker.com/engine/installation/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">Docker 官方 Ubuntu 安装文档</a></p>
<h2 id="3-2-centOS-安装-docker"><a href="#3-2-centOS-安装-docker" class="headerlink" title="3.2.   centOS 安装 docker"></a>3.2.   centOS 安装 docker</h2><p>警告：切勿在没有配置 Docker YUM 源的情况下直接使用 yum 命令安装 Docker.</p>
<h3 id="3-2-1-准备工作"><a href="#3-2-1-准备工作" class="headerlink" title="3.2.1. 准备工作"></a>3.2.1. 准备工作</h3><p><strong>1**</strong>、系统要求**</p>
<p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10。 CentOS 7 满足最低内核的要求，但由于内核版本比较低，部分功能（如 overlay2 存储层驱动）无法使用，并且部分功能可能不太稳定。</p>
<p><strong>2**</strong>、卸载旧版本**</p>
<p>旧版本的 Docker 称为 docker 或者 docker-engine，使用以下命令卸载旧版本：</p>
<p>sudo yum remove docker \</p>
<p>​         docker-client \</p>
<p>​         docker-client-latest \</p>
<p>​         docker-common \</p>
<p>​         docker-latest \</p>
<p>​         docker-latest-logrotate \</p>
<p>​         docker-logrotate \</p>
<p>​         docker-selinux \</p>
<p>​         docker-engine-selinux \</p>
<p>​         docker-engine</p>
<h3 id="3-2-2-使用-yum-安装"><a href="#3-2-2-使用-yum-安装" class="headerlink" title="3.2.2. 使用 yum 安装"></a>3.2.2. 使用 yum 安装</h3><p>执行以下命令安装依赖包：</p>
<p>sudo yum install -y yum-utils \</p>
<p>​      device-mapper-persistent-data \</p>
<p>​      lvm2</p>
<p>鉴于国内网络问题，强烈建议使用国内源，官方源请在注释中查看。</p>
<p>执行下面的命令添加 yum 软件源：</p>
<p>sudo yum-config-manager \</p>
<p>  –add-repo \</p>
<p>  <a href="https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo" target="_blank" rel="noopener">https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo</a></p>
<p># 官方源</p>
<p># sudo yum-config-manager \</p>
<p>#  –add-repo \</p>
<p>#  <a href="https://download.docker.com/linux/centos/docker-ce.repo" target="_blank" rel="noopener">https://download.docker.com/linux/centos/docker-ce.repo</a></p>
<p>如果需要最新版本的 Docker CE 请使用以下命令：</p>
<p>sudo yum-config-manager –enable docker-ce-edge</p>
<p>如果需要测试版本的 Docker CE 请使用以下命令：</p>
<p>sudo yum-config-manager –enable docker-ce-test</p>
<p><strong>安装 Docker CE</strong></p>
<p>更新 yum 软件源缓存，并安装 docker-ce。</p>
<p>sudo yum makecache fast</p>
<p>sudo yum install docker-ce</p>
<h3 id="3-2-3-使用脚本自动安装"><a href="#3-2-3-使用脚本自动安装" class="headerlink" title="3.2.3. 使用脚本自动安装"></a>3.2.3. 使用脚本自动安装</h3><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装：</p>
<p>curl -fsSL get.docker.com -o get-docker.sh</p>
<p>sudo sh get-docker.sh –mirror Aliyun</p>
<p>执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker CE 的 Edge 版本安装在系统中。</p>
<h3 id="3-2-4-启动-Docker-CE"><a href="#3-2-4-启动-Docker-CE" class="headerlink" title="3.2.4. 启动 Docker CE"></a>3.2.4. 启动 Docker CE</h3><p>sudo systemctl enable docker</p>
<p>sudo systemctl start docker</p>
<h3 id="3-2-5-建立-docker-用户组"><a href="#3-2-5-建立-docker-用户组" class="headerlink" title="3.2.5. 建立 docker 用户组"></a>3.2.5. 建立 docker 用户组</h3><p>默认情况下，docker 命令会使用 Unix socket 与 Docker 引擎通讯。而只有 root 用户和 docker 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 root 用户。因此，更好地做法是将需要使用 docker 的用户加入 docker 用户组。</p>
<p>建立 docker 组：</p>
<p>sudo groupadd docker</p>
<p>将当前用户加入 docker 组：</p>
<p>sudo usermod -aG docker $USER</p>
<p>退出当前终端并重新登录，进行如下测试。</p>
<h3 id="3-2-6-测试-Docker-是否安装正确"><a href="#3-2-6-测试-Docker-是否安装正确" class="headerlink" title="3.2.6. 测试 Docker 是否安装正确"></a>3.2.6. 测试 Docker 是否安装正确</h3><p>docker run hello-world</p>
<p>Unable to find image ‘hello-world:latest’ locally</p>
<p>latest: Pulling from library/hello-world</p>
<p>ca4f61b1923c: Pull complete</p>
<p>Digest: sha256:be0cd392e45be79ffeffa6b05338b98ebb16c87b255f48e297ec7f98e123905c</p>
<p>Status: Downloaded newer image for hello-world:latest</p>
<p>Hello from Docker!</p>
<p>This message shows that your installation appears to be working correctly.</p>
<p>To generate this message, Docker took the following steps:</p>
<p> \1. The Docker client contacted the Docker daemon.</p>
<p> \2. The Docker daemon pulled the “hello-world” image from the Docker Hub.</p>
<p>  (amd64)</p>
<p> \3. The Docker daemon created a new container from that image which runs the</p>
<p>  executable that produces the output you are currently reading.</p>
<p> \4. The Docker daemon streamed that output to the Docker client, which sent it</p>
<p>  to your terminal.</p>
<p>To try something more ambitious, you can run an Ubuntu container with:</p>
<p> $ docker run -it ubuntu bash</p>
<p>Share images, automate workflows, and more with a free Docker ID:</p>
<p> <a href="https://cloud.docker.com/" target="_blank" rel="noopener">https://cloud.docker.com/</a></p>
<p>For more examples and ideas, visit:</p>
<p> <a href="https://docs.docker.com/engine/userguide/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/</a></p>
<p>若能正常输出以上信息，则说明安装成功。</p>
<h3 id="3-2-7-镜像加速"><a href="#3-2-7-镜像加速" class="headerlink" title="3.2.7. 镜像加速"></a>3.2.7. 镜像加速</h3><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，强烈建议安装 Docker 之后配置 国内镜像加速。</p>
<h3 id="3-2-8-添加内核参数"><a href="#3-2-8-添加内核参数" class="headerlink" title="3.2.8. 添加内核参数"></a>3.2.8. 添加内核参数</h3><p>默认配置下，如果在 CentOS 使用 Docker CE 看到下面的这些警告信息：</p>
<p>WARNING: bridge-nf-call-iptables is disabled</p>
<p>WARNING: bridge-nf-call-ip6tables is disabled</p>
<p>请添加内核配置参数以启用这些功能。</p>
<p>sudo tee -a /etc/sysctl.conf &lt;&lt;-EOF</p>
<p>net.bridge.bridge-nf-call-ip6tables = 1</p>
<p>net.bridge.bridge-nf-call-iptables = 1</p>
<p>EOF</p>
<p>然后重新加载 sysctl.conf 即可</p>
<p>sudo sysctl -p</p>
<h3 id="3-2-9-参考文档"><a href="#3-2-9-参考文档" class="headerlink" title="3.2.9. 参考文档"></a>3.2.9. 参考文档</h3><p><a href="https://docs.docker.com/engine/installation/linux/docker-ce/centos/" target="_blank" rel="noopener">Docker 官方 CentOS 安装文档</a>。</p>
<h2 id="3-3-mac-安装-docker"><a href="#3-3-mac-安装-docker" class="headerlink" title="3.3.   mac 安装 docker"></a>3.3.   mac 安装 docker</h2><h3 id="3-3-1-系统要求"><a href="#3-3-1-系统要求" class="headerlink" title="3.3.1. 系统要求"></a>3.3.1. 系统要求</h3><p><a href="https://docs.docker.com/docker-for-mac/" target="_blank" rel="noopener">Docker for Mac</a> 要求系统最低为 macOS 10.10.3 Yosemite。如果系统不满足需求，可以安装 <a href="https://docs.docker.com/toolbox/overview/" target="_blank" rel="noopener">Docker Toolbox</a>。</p>
<h3 id="3-3-2-安装"><a href="#3-3-2-安装" class="headerlink" title="3.3.2. 安装"></a>3.3.2. 安装</h3><p><strong>1**</strong>、使用 Homebrew 安装**</p>
<p>Homebrew 的 Cask 已经支持 Docker for Mac，因此可以很方便的使用 Homebrew Cask 来进行安装：</p>
<p>brew cask install docker</p>
<p><strong>2**</strong>、手动下载安装**</p>
<p>如果需要手动下载，请点击以下链接下载 Stable 或 Edge 版本的 Docker for Mac。</p>
<p>如同 macOS 其它软件一样，安装也非常简单，双击下载的 .dmg 文件，然后将那只叫 Moby 的鲸鱼图标拖拽到 Application 文件夹即可（其间需要输入用户密码）。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134748.gif" alt="https://www.funtl.com/assets/install-mac-dmg.png"></p>
<h3 id="3-3-3-运行"><a href="#3-3-3-运行" class="headerlink" title="3.3.3. 运行"></a>3.3.3. 运行</h3><p>从应用中找到 Docker 图标并点击运行。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134756.gif" alt="https://www.funtl.com/assets/install-mac-apps.png"></p>
<p>运行之后，会在右上角菜单栏看到多了一个鲸鱼图标，这个图标表明了 Docker 的运行状态。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134801.gif" alt="https://www.funtl.com/assets/install-mac-menubar.png"></p>
<p>第一次点击图标，可能会看到这个安装成功的界面，点击 “Got it!” 可以关闭这个窗口。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134804.gif" alt="https://www.funtl.com/assets/install-mac-success.png"></p>
<p>以后每次点击鲸鱼图标会弹出操作菜单。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134807.gif" alt="https://www.funtl.com/assets/install-mac-menu.png"></p>
<p>启动终端后，通过命令可以检查安装后的 Docker 版本。</p>
<p>docker –version</p>
<p>docker-compose –version</p>
<p>docker-machine –version</p>
<p>如果 docker version、docker info 都正常的话，可以尝试运行一个 Nginx 服务器：</p>
<p>docker run -d -p 80:80 –name webserver nginx</p>
<p>服务运行后，可以访问 <a href="http://localhost，如果看到了" target="_blank" rel="noopener">http://localhost，如果看到了</a> “Welcome to nginx!”，就说明 Docker for Mac 安装成功了。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134811.gif" alt="https://www.funtl.com/assets/install-mac-example-nginx.png"></p>
<p>要停止 Nginx 服务器并删除执行下面的命令：</p>
<p>docker stop webserver</p>
<p>docker rm webserver</p>
<h3 id="3-3-4-镜像加速"><a href="#3-3-4-镜像加速" class="headerlink" title="3.3.4. 镜像加速"></a>3.3.4. 镜像加速</h3><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，强烈建议安装 Docker 之后配置 国内镜像加速。</p>
<h2 id="3-4-windos-安装-docker"><a href="#3-4-windos-安装-docker" class="headerlink" title="3.4.   windos 安装 docker"></a>3.4.   windos 安装 docker</h2><h3 id="3-4-1-系统要求"><a href="#3-4-1-系统要求" class="headerlink" title="3.4.1. 系统要求"></a>3.4.1. 系统要求</h3><p><a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">Docker for Windows</a> 支持 64 位版本的 Windows 10 Pro，且必须开启 Hyper-V。</p>
<h3 id="3-4-2-安装"><a href="#3-4-2-安装" class="headerlink" title="3.4.2. 安装"></a>3.4.2. 安装</h3><p>点击以下链接下载 Stable 或 Edge 版本的 Docker for Windows。</p>
<p>下载好之后双击 Docker for Windows Installer.exe 开始安装。</p>
<h3 id="3-4-3-运行"><a href="#3-4-3-运行" class="headerlink" title="3.4.3. 运行"></a>3.4.3. 运行</h3><p>在 Windows 搜索栏输入 Docker 点击 Docker for Windows 开始运行。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134815.gif" alt="https://www.funtl.com/assets/install-win-docker-app-search.png"></p>
<p>Docker CE 启动之后会在 Windows 任务栏出现鲸鱼图标。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134818.gif" alt="https://www.funtl.com/assets/install-win-taskbar-circle.png"></p>
<p>等待片刻，点击 Got it 开始使用 Docker CE。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134821.gif" alt="https://www.funtl.com/assets/install-win-success-popup-cloud.png"></p>
<h3 id="3-4-4-镜像加速"><a href="#3-4-4-镜像加速" class="headerlink" title="3.4.4. 镜像加速"></a>3.4.4. 镜像加速</h3><p>鉴于国内网络问题，后续拉取 Docker 镜像十分缓慢，强烈建议安装 Docker 之后配置 国内镜像加速。</p>
<h2 id="3-5-镜像加速"><a href="#3-5-镜像加速" class="headerlink" title="3.5.   镜像加速"></a>3.5.   镜像加速</h2><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如：</p>
<p>l Docker 官方提供的中国 registry mirror</p>
<p>l 阿里云加速器</p>
<p>l DaoCloud 加速器</p>
<p>我们以 Docker 官方加速器为例进行介绍。</p>
<h3 id="3-5-1-Ubuntu-14-04、Debian-7-Wheezy"><a href="#3-5-1-Ubuntu-14-04、Debian-7-Wheezy" class="headerlink" title="3.5.1. Ubuntu 14.04、Debian 7 Wheezy"></a>3.5.1. Ubuntu 14.04、Debian 7 Wheezy</h3><p>对于使用 upstart 的系统而言，编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS 中配置加速器地址：</p>
<p>DOCKER_OPTS=”–registry-mirror=<a href="https://registry.docker-cn.com&quot;" target="_blank" rel="noopener">https://registry.docker-cn.com&quot;</a></p>
<p>重新启动服务。</p>
<p>sudo service docker restart</p>
<h3 id="3-5-2-Ubuntu-16-04-、Debian-8-、CentOS-7"><a href="#3-5-2-Ubuntu-16-04-、Debian-8-、CentOS-7" class="headerlink" title="3.5.2. Ubuntu 16.04+、Debian 8+、CentOS 7"></a>3.5.2. Ubuntu 16.04+、Debian 8+、CentOS 7</h3><p>对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）</p>
<p>{</p>
<p> “registry-mirrors”: [</p>
<p>  “<a href="https://registry.docker-cn.com&quot;" target="_blank" rel="noopener">https://registry.docker-cn.com&quot;</a></p>
<p> ]</p>
<p>}</p>
<p>注意，一定要保证该文件符合 json 规范，否则 Docker 将不能启动。</p>
<p>之后重新启动服务。</p>
<p>sudo systemctl daemon-reload</p>
<p>sudo systemctl restart docker</p>
<p>注意：如果您之前查看旧教程，修改了 docker.service 文件内容，请去掉您添加的内容（–registry-mirror=<a href="https://registry.docker-cn.com），这里不再赘述。" target="_blank" rel="noopener">https://registry.docker-cn.com），这里不再赘述。</a></p>
<h3 id="3-5-3-Windows-10"><a href="#3-5-3-Windows-10" class="headerlink" title="3.5.3. Windows 10"></a>3.5.3. Windows 10</h3><p>对于使用 Windows 10 的系统，在系统右下角托盘 Docker 图标内右键菜单选择 Settings，打开配置窗口后左侧导航菜单选择 Daemon。在 Registry mirrors 一栏中填写加速器地址 <a href="https://registry.docker-cn.com，之后点击" target="_blank" rel="noopener">https://registry.docker-cn.com，之后点击</a> Apply 保存后 Docker 就会重启并应用配置的镜像地址了。</p>
<h3 id="3-5-4-macOS"><a href="#3-5-4-macOS" class="headerlink" title="3.5.4. macOS"></a>3.5.4. macOS</h3><p>对于使用 macOS 的用户，在任务栏点击 Docker for mac 应用图标 -&gt; Perferences… -&gt; Daemon -&gt; Registry mirrors。在列表中填写加速器地址 <a href="https://registry.docker-cn.com。修改完成之后，点击" target="_blank" rel="noopener">https://registry.docker-cn.com。修改完成之后，点击</a> Apply &amp; Restart 按钮，Docker 就会重启并应用配置的镜像地址了。</p>
<h3 id="3-5-5-检查加速器是否生效"><a href="#3-5-5-检查加速器是否生效" class="headerlink" title="3.5.5. 检查加速器是否生效"></a>3.5.5. 检查加速器是否生效</h3><p>配置加速器之后，如果拉取镜像仍然十分缓慢，请手动检查加速器配置是否生效，在命令行执行 docker info，如果从结果中看到了如下内容，说明配置成功。</p>
<p>Registry Mirrors:</p>
<p> <a href="https://registry.docker-cn.com/" target="_blank" rel="noopener">https://registry.docker-cn.com/</a></p>
<h1 id="4-docker-镜像"><a href="#4-docker-镜像" class="headerlink" title="4. docker 镜像"></a>4. docker 镜像</h1><p>在之前的介绍中，我们知道镜像是 Docker 的三大组件之一。</p>
<p>Docker 运行容器前需要本地存在对应的镜像，如果本地不存在该镜像，Docker 会从镜像仓库下载该镜像。</p>
<p>本章将介绍更多关于镜像的内容，包括：</p>
<p>l 从仓库获取镜像；</p>
<p>l 管理本地主机上的镜像；</p>
<p>l 介绍镜像实现的基本原理。</p>
<h2 id="4-1-Docker-获取镜像"><a href="#4-1-Docker-获取镜像" class="headerlink" title="4.1.   Docker 获取镜像"></a>4.1.   Docker 获取镜像</h2><p>之前提到过，Docker Hub 上有大量的高质量的镜像可以用，这里我们就说一下怎么获取这些镜像。</p>
<p>从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：</p>
<p>docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</p>
<p>具体的选项可以通过 docker pull –help 命令看到，这里我们说一下镜像名称的格式。</p>
<p>l Docker 镜像仓库地址：地址的格式一般是 &lt;域名/IP&gt;[:端口号]。默认地址是 Docker Hub。</p>
<p>l 仓库名：如之前所说，这里的仓库名是两段式名称，即 &lt;用户名&gt;/&lt;软件名&gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。</p>
<p>比如：</p>
<p>docker pull ubuntu:16.04</p>
<p>16.04: Pulling from library/ubuntu</p>
<p>bf5d46315322: Pull complete</p>
<p>9f13e0ac480c: Pull complete</p>
<p>e8988b5b3097: Pull complete</p>
<p>40af181810e7: Pull complete</p>
<p>e6f7c7e5c03e: Pull complete</p>
<p>Digest: sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe</p>
<p>Status: Downloaded newer image for ubuntu:16.04</p>
<p>上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 ubuntu:16.04，因此将会获取官方镜像 library/ubuntu 仓库中标签为 16.04 的镜像。</p>
<p>从下载过程中可以看到我们之前提及的分层存储的概念，镜像是由多层存储所构成。下载也是一层层的去下载，并非单一文件。下载过程中给出了每一层的 ID 的前 12 位。并且下载结束后，给出该镜像完整的 sha256 的摘要，以确保下载一致性。</p>
<p>在使用上面命令的时候，你可能会发现，你所看到的层 ID 以及 sha256 的摘要和这里的不一样。这是因为官方镜像是一直在维护的，有任何新的 bug，或者版本更新，都会进行修复再以原来的标签发布，这样可以确保任何使用这个标签的用户可以获得更安全、更稳定的镜像。</p>
<p>如果从 Docker Hub 下载镜像非常缓慢，可以参照 镜像加速器 一节配置加速器。</p>
<h3 id="4-1-1-运行"><a href="#4-1-1-运行" class="headerlink" title="4.1.1. 运行"></a>4.1.1. 运行</h3><p>有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 ubuntu:16.04 为例，如果我们打算启动里面的 bash 并且进行交互式操作的话，可以执行下面的命令。</p>
<p>docker run -it –rm \</p>
<p>  ubuntu:16.04 \</p>
<p>  bash</p>
<p>root@e7009c6ce357:/# cat /etc/os-release</p>
<p>NAME=”Ubuntu”</p>
<p>VERSION=”16.04.4 LTS, Trusty Tahr”</p>
<p>ID=ubuntu</p>
<p>ID_LIKE=debian</p>
<p>PRETTY_NAME=”Ubuntu 16.04.4 LTS”</p>
<p>VERSION_ID=”16.04”</p>
<p>HOME_URL=”<a href="http://www.ubuntu.com/&quot;" target="_blank" rel="noopener">http://www.ubuntu.com/&quot;</a></p>
<p>SUPPORT_URL=”<a href="http://help.ubuntu.com/&quot;" target="_blank" rel="noopener">http://help.ubuntu.com/&quot;</a></p>
<p>BUG_REPORT_URL=”<a href="http://bugs.launchpad.net/ubuntu/&quot;" target="_blank" rel="noopener">http://bugs.launchpad.net/ubuntu/&quot;</a></p>
<p>docker run 就是运行容器的命令，我们这里简要的说明一下上面用到的参数。</p>
<p>l -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。</p>
<p>l –rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间。</p>
<p>l ubuntu:16.04：这是指用 ubuntu:16.04 镜像为基础来启动容器。</p>
<p>l bash：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 bash。</p>
<p>进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 16.04.4 LTS 系统。</p>
<p>最后我们通过 exit 退出了这个容器。</p>
<h2 id="4-2-docker-列出镜像"><a href="#4-2-docker-列出镜像" class="headerlink" title="4.2.   docker 列出镜像"></a>4.2.   docker 列出镜像</h2><p>Docker 列出镜像</p>
<p>要想列出已经下载下来的镜像，可以使用 docker image ls 命令。</p>
<p>docker image ls</p>
<p>REPOSITORY      TAG         IMAGE ID      CREATED       SIZE</p>
<p>redis        latest       5f515359c7f8    5 days ago     183 MB</p>
<p>nginx        latest       05a60462f8ba     5 days ago     181 MB</p>
<p>mongo        3.2         fe9198c04d62    5 days ago     342 MB</p>
<p><none>        <none>       00285df0df87    5 days ago     342 MB</p>
<p>ubuntu        16.04        f753707788c5    4 weeks ago     127 MB</p>
<p>ubuntu        latest       f753707788c5    4 weeks ago     127 MB</p>
<p>ubuntu        14.04        1e0c3dd64ccd    4 weeks ago     188 MB</p>
<p>列表包含了 仓库名、标签、镜像 ID、创建时间 以及 所占用的空间。</p>
<p>其中仓库名、标签在之前的基础概念章节已经介绍过了。镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个标签。因此，在上面的例子中，我们可以看到 ubuntu:16.04 和 ubuntu:latest 拥有相同的 ID，因为它们对应的是同一个镜像。</p>
<h3 id="4-2-1-镜像体积"><a href="#4-2-1-镜像体积" class="headerlink" title="4.2.1. 镜像体积"></a>4.2.1. 镜像体积</h3><p>如果仔细观察，会注意到，这里标识的所占用空间和在 Docker Hub 上看到的镜像大小不同。比如，ubuntu:16.04 镜像大小，在这里是 127 MB，但是在 Docker Hub 显示的却是 50 MB。这是因为 Docker Hub 中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像是保持着压缩状态的，因此 Docker Hub 所显示的大小是网络传输中更关心的流量大小。而 docker image ls 显示的是镜像下载到本地后，展开的大小，准确说，是展开后的各层所占空间的总和，因为镜像到本地后，查看空间的时候，更关心的是本地磁盘空间占用的大小。</p>
<p>另外一个需要注意的问题是，docker image ls 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p>
<p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p>
<p>docker system df</p>
<p>TYPE        TOTAL        ACTIVE       SIZE        RECLAIMABLE</p>
<p>Images       24         0          1.992GB       1.992GB (100%)</p>
<p>Containers     1          0          62.82MB       62.82MB (100%)</p>
<p>Local Volumes    9          0          652.2MB       652.2MB (100%)</p>
<p>Build Cache                         0B         0B</p>
<h3 id="4-2-2-虚悬镜像"><a href="#4-2-2-虚悬镜像" class="headerlink" title="4.2.2. 虚悬镜像"></a>4.2.2. 虚悬镜像</h3><p>上面的镜像列表中，还可以看到一个特殊的镜像，这个镜像既没有仓库名，也没有标签，均为 <none>。：</p>
<p><none>        <none>       00285df0df87    5 days ago      342 MB</p>
<p>这个镜像原本是有镜像名和标签的，原来为 mongo:3.2，随着官方镜像维护，发布了新版本后，重新 docker pull mongo:3.2 时，mongo:3.2 这个镜像名被转移到了新下载的镜像身上，而旧的镜像上的这个名称则被取消，从而成为了 <none>。除了 docker pull 可能导致这种情况，docker build 也同样可以导致这种现象。由于新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 <none> 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image) ，可以用下面的命令专门显示这类镜像：</p>
<p>docker image ls -f dangling=true</p>
<p>REPOSITORY     TAG         IMAGE ID      CREATED       SIZE</p>
<p><none>       <none>       00285df0df87    5 days ago     342 MB</p>
<p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p>
<p>docker image prune</p>
<h3 id="4-2-3-中间层镜像"><a href="#4-2-3-中间层镜像" class="headerlink" title="4.2.3. 中间层镜像"></a>4.2.3. 中间层镜像</h3><p>为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。所以在使用一段时间后，可能会看到一些依赖的中间层镜像。默认的 docker image ls 列表中只会显示顶层镜像，如果希望显示包括中间层镜像在内的所有镜像的话，需要加 -a 参数。</p>
<p>docker image ls -a</p>
<p>这样会看到很多无标签的镜像，与之前的虚悬镜像不同，这些无标签的镜像很多都是中间层镜像，是其它镜像所依赖的镜像。这些无标签镜像不应该删除，否则会导致上层镜像因为依赖丢失而出错。实际上，这些镜像也没必要删除，因为之前说过，相同的层只会存一遍，而这些镜像是别的镜像的依赖，因此并不会因为它们被列出来而多存了一份，无论如何你也会需要它们。只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除。</p>
<h3 id="4-2-4-列出部分镜像"><a href="#4-2-4-列出部分镜像" class="headerlink" title="4.2.4. 列出部分镜像"></a>4.2.4. 列出部分镜像</h3><p>不加任何参数的情况下，docker image ls 会列出所有顶级镜像，但是有时候我们只希望列出部分镜像。docker image ls 有好几个参数可以帮助做到这个事情。</p>
<p>根据仓库名列出镜像</p>
<p>docker image ls ubuntu</p>
<p>REPOSITORY     TAG         IMAGE ID      CREATED       SIZE</p>
<p>ubuntu       16.04        f753707788c5    4 weeks ago     127 MB</p>
<p>ubuntu       latest       f753707788c5    4 weeks ago     127 MB</p>
<p>ubuntu       14.04        1e0c3dd64ccd    4 weeks ago     188 MB</p>
<p>列出特定的某个镜像，也就是说指定仓库名和标签</p>
<p>docker image ls ubuntu:16.04</p>
<p>REPOSITORY     TAG         IMAGE ID      CREATED       SIZE</p>
<p>ubuntu       16.04        f753707788c5    4 weeks ago     127 MB</p>
<p>除此以外，docker image ls 还支持强大的过滤器参数 –filter，或者简写 -f。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 mongo:3.2 之后建立的镜像，可以用下面的命令：</p>
<p>docker image ls -f since=mongo:3.2</p>
<p>REPOSITORY     TAG         IMAGE ID      CREATED       SIZE</p>
<p>redis        latest       5f515359c7f8    5 days ago     183 MB</p>
<p>nginx        latest       05a60462f8ba    5 days ago     181 MB</p>
<p>想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。</p>
<p>此外，如果镜像构建时，定义了 LABEL，还可以通过 LABEL 来过滤。</p>
<p>docker image ls -f label=com.example.version=0.1</p>
<h3 id="4-2-5-以特定格式显示"><a href="#4-2-5-以特定格式显示" class="headerlink" title="4.2.5. 以特定格式显示"></a>4.2.5. 以特定格式显示</h3><p>默认情况下，docker image ls 会输出一个完整的表格，但是我们并非所有时候都会需要这些内容。比如，刚才删除虚悬镜像的时候，我们需要利用 docker image ls 把所有的虚悬镜像的 ID 列出来，然后才可以交给 docker image rm 命令作为参数来删除指定的这些镜像，这个时候就用到了 -q 参数。</p>
<p>docker image ls -q</p>
<p>5f515359c7f8</p>
<p>05a60462f8ba</p>
<p>fe9198c04d62</p>
<p>00285df0df87</p>
<p>f753707788c5</p>
<p>f753707788c5</p>
<p>1e0c3dd64ccd</p>
<p>–filter 配合 -q 产生出指定范围的 ID 列表，然后送给另一个 docker 命令作为参数，从而针对这组实体成批的进行某种操作的做法在 Docker 命令行使用过程中非常常见，不仅仅是镜像，将来我们会在各个命令中看到这类搭配以完成很强大的功能。因此每次在文档看到过滤器后，可以多注意一下它们的用法。</p>
<p>另外一些时候，我们可能只是对表格的结构不满意，希望自己组织列；或者不希望有标题，这样方便其它程序解析结果等，这就用到了 Go 的模板语法。</p>
<p>比如，下面的命令会直接列出镜像结果，并且只包含镜像ID和仓库名：</p>
<p>docker image ls –format “{.ID}: {.Repository}”</p>
<p>5f515359c7f8: redis</p>
<p>05a60462f8ba: nginx</p>
<p>fe9198c04d62: mongo</p>
<p>00285df0df87: <none></p>
<p>f753707788c5: ubuntu</p>
<p>f753707788c5: ubuntu</p>
<p>1e0c3dd64ccd: ubuntu</p>
<p>或者打算以表格等距显示，并且有标题行，和默认一样，不过自己定义列：</p>
<p>docker image ls –format “table {.ID}\t{.Repository}\t{.Tag}”</p>
<p>IMAGE ID      REPOSITORY     TAG</p>
<p>5f515359c7f8    redis        latest</p>
<p>05a60462f8ba    nginx        latest</p>
<p>fe9198c04d62    mongo        3.2</p>
<p>00285df0df87    <none>       <none></p>
<p>f753707788c5    ubuntu       16.04</p>
<p>f753707788c5    ubuntu       latest</p>
<p>1e0c3dd64ccd    ubuntu       14.04</p>
<h2 id="4-3-docker-删除本地镜像"><a href="#4-3-docker-删除本地镜像" class="headerlink" title="4.3.   docker 删除本地镜像"></a>4.3.   docker 删除本地镜像</h2><p>如果要删除本地的镜像，可以使用 docker image rm 命令，其格式为：</p>
<p>docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; …]</p>
<h3 id="4-3-1-用-ID、镜像名、摘要删除镜像"><a href="#4-3-1-用-ID、镜像名、摘要删除镜像" class="headerlink" title="4.3.1. 用 ID、镜像名、摘要删除镜像"></a>4.3.1. 用 ID、镜像名、摘要删除镜像</h3><p>其中，&lt;镜像&gt; 可以是 镜像短 ID、镜像长 ID、镜像名 或者 镜像摘要。</p>
<p>比如我们有这么一些镜像：</p>
<p>docker image ls</p>
<p>REPOSITORY     TAG         IMAGE ID      CREATED       SIZE</p>
<p>centos        latest       0584b3d2cf6d    3 weeks ago     196.5 MB</p>
<p>redis         alpine       501ad78535f0    3 weeks ago     21.03 MB</p>
<p>docker        latest       cf693ec9b5c7    3 weeks ago     105.1 MB</p>
<p>nginx         latest       e43d811ce2f4    5 weeks ago     181.5 MB</p>
<p>我们可以用镜像的完整 ID，也称为 长 ID，来删除镜像。使用脚本的时候可能会用长 ID，但是人工输入就太累了，所以更多的时候是用 短 ID 来删除镜像。docker image ls 默认列出的就已经是短 ID 了，一般取前3个字符以上，只要足够区分于别的镜像就可以了。</p>
<p>比如这里，如果我们要删除 redis:alpine 镜像，可以执行：</p>
<p>docker image rm 501</p>
<p>Untagged: redis:alpine</p>
<p>Untagged: redis@sha256:f1ed3708f538b537eb9c2a7dd50dc90a706f7debd7e1196c9264edeea521a86d</p>
<p>Deleted: sha256:501ad78535f015d88872e13fa87a828425117e3d28075d0c117932b05bf189b7</p>
<p>Deleted: sha256:96167737e29ca8e9d74982ef2a0dda76ed7b430da55e321c071f0dbff8c2899b</p>
<p>Deleted: sha256:32770d1dcf835f192cafd6b9263b7b597a1778a403a109e2cc2ee866f74adf23</p>
<p>Deleted: sha256:127227698ad74a5846ff5153475e03439d96d4b1c7f2a449c7a826ef74a2d2fa</p>
<p>Deleted: sha256:1333ecc582459bac54e1437335c0816bc17634e131ea0cc48daa27d32c75eab3</p>
<p>Deleted: sha256:4fc455b921edf9c4aea207c51ab39b10b06540c8b4825ba57b3feed1668fa7c7</p>
<p>我们也可以用镜像名，也就是 &lt;仓库名&gt;:&lt;标签&gt;，来删除镜像。</p>
<p>docker image rm centos</p>
<p>Untagged: centos:latest</p>
<p>Untagged: centos@sha256:b2f9d1c0ff5f87a4743104d099a3d561002ac500db1b9bfa02a783a46e0d366c</p>
<p>Deleted: sha256:0584b3d2cf6d235ee310cf14b54667d889887b838d3f3d3033acd70fc3c48b8a</p>
<p>Deleted: sha256:97ca462ad9eeae25941546209454496e1d66749d53dfa2ee32bf1faabd239d38</p>
<p>当然，更精确的是使用 镜像摘要 删除镜像。</p>
<p>docker image ls –digests</p>
<p>REPOSITORY         TAG         DIGEST                                   IMAGE ID      CREATED       SIZE</p>
<p>node            slim        sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228  6e0c4c8e3913    3 weeks ago     214 MB</p>
<p>docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</p>
<p>Untagged: node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</p>
<h3 id="4-3-2-Untagged-和-Deleted"><a href="#4-3-2-Untagged-和-Deleted" class="headerlink" title="4.3.2. Untagged 和 Deleted"></a>4.3.2. Untagged 和 Deleted</h3><p>如果观察上面这几个命令的运行输出信息的话，你会注意到删除行为分为两类，一类是 Untagged，另一类是 Deleted。我们之前介绍过，镜像的唯一标识是其 ID 和摘要，而一个镜像可以有多个标签。</p>
<p>因此当我们使用上面命令删除镜像的时候，实际上是在要求删除某个标签的镜像。所以首先需要做的是将满足我们要求的所有镜像标签都取消，这就是我们看到的 Untagged 的信息。因为一个镜像可以对应多个标签，因此当我们删除了所指定的标签后，可能还有别的标签指向了这个镜像，如果是这种情况，那么 Delete 行为就不会发生。所以并非所有的 docker image rm 都会产生删除镜像的行为，有可能仅仅是取消了某个标签而已。</p>
<p>当该镜像所有的标签都被取消了，该镜像很可能会失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，因此在删除的时候也是从上层向基础层方向依次进行判断删除。镜像的多层结构让镜像复用变动非常容易，因此很有可能某个其它镜像正依赖于当前镜像的某一层。这种情况，依旧不会触发删除该层的行为。直到没有任何层依赖当前层时，才会真实的删除当前层。这就是为什么，有时候会奇怪，为什么明明没有别的标签指向这个镜像，但是它还是存在的原因，也是为什么有时候会发现所删除的层数和自己 docker pull 看到的层数不一样的源。</p>
<p>除了镜像依赖以外，还需要注意的是容器对镜像的依赖。如果有用这个镜像启动的容器存在（即使容器没有运行），那么同样不可以删除这个镜像。之前讲过，容器是以镜像为基础，再加一层容器存储层，组成这样的多层存储结构去运行的。因此该镜像如果被这个容器所依赖的，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后再来删除镜像。</p>
<h3 id="4-3-3-用-docker-image-ls-命令来配合"><a href="#4-3-3-用-docker-image-ls-命令来配合" class="headerlink" title="4.3.3. 用 docker image ls 命令来配合"></a>4.3.3. 用 docker image ls 命令来配合</h3><p>像其它可以承接多个实体的命令一样，可以使用 docker image ls -q 来配合使用 docker image rm，这样可以成批的删除希望删除的镜像。我们在“镜像列表”章节介绍过很多过滤镜像列表的方式都可以拿过来使用。</p>
<p>比如，我们需要删除所有仓库名为 redis 的镜像：</p>
<p>docker image rm $(docker image ls -q redis)</p>
<p>或者删除所有在 mongo:3.2 之前的镜像：</p>
<p>docker image rm $(docker image ls -q -f before=mongo:3.2)</p>
<p>充分利用你的想象力和 Linux 命令行的强大，你可以完成很多非常赞的功能。</p>
<h3 id="4-3-4-CentOS-RHEL-的用户需要注意的事项"><a href="#4-3-4-CentOS-RHEL-的用户需要注意的事项" class="headerlink" title="4.3.4. CentOS/RHEL 的用户需要注意的事项"></a>4.3.4. CentOS/RHEL 的用户需要注意的事项</h3><p>在 Ubuntu/Debian 上有 UnionFS 可以使用，如 aufs 或者 overlay2，而 CentOS 和 RHEL 的内核中没有相关驱动。因此对于这类系统，一般使用 devicemapper 驱动利用 LVM 的一些机制来模拟分层存储。这样的做法除了性能比较差外，稳定性一般也不好，而且配置相对复杂。Docker 安装在 CentOS/RHEL 上后，会默认选择 devicemapper，但是为了简化配置，其 devicemapper 是跑在一个稀疏文件模拟的块设备上，也被称为 loop-lvm。这样的选择是因为不需要额外配置就可以运行 Docker，这是自动配置唯一能做到的事情。但是 loop-lvm 的做法非常不好，其稳定性、性能更差，无论是日志还是 docker info 中都会看到警告信息。官方文档有明确的文章讲解了如何配置块设备给 devicemapper 驱动做存储层的做法，这类做法也被称为配置 direct-lvm。</p>
<p>除了前面说到的问题外，devicemapper + loop-lvm 还有一个缺陷，因为它是稀疏文件，所以它会不断增长。用户在使用过程中会注意到 /var/lib/docker/devicemapper/devicemapper/data 不断增长，而且无法控制。很多人会希望删除镜像或者可以解决这个问题，结果发现效果并不明显。原因就是这个稀疏文件的空间释放后基本不进行垃圾回收的问题。因此往往会出现即使删除了文件内容，空间却无法回收，随着使用这个稀疏文件一直在不断增长。</p>
<p>所以对于 CentOS/RHEL 的用户来说，在没有办法使用 UnionFS 的情况下，一定要配置 direct-lvm 给 devicemapper，无论是为了性能、稳定性还是空间利用率。</p>
<p>或许有人注意到了 CentOS 7 中存在被 backports 回来的 overlay 驱动，不过 CentOS 里的这个驱动达不到生产环境使用的稳定程度，所以不推荐使用。</p>
<h2 id="4-4-利用-commit-理解镜像构成"><a href="#4-4-利用-commit-理解镜像构成" class="headerlink" title="4.4.   利用 commit 理解镜像构成"></a>4.4.   利用 commit 理解镜像构成</h2><p>注意： docker commit 命令除了学习之外，还有一些特殊的应用场合，比如被入侵后保存现场等。但是，不要使用 docker commit 定制镜像，定制镜像应该使用 Dockerfile 来完成。如果你想要定制镜像请查看下一小节。</p>
<p>镜像是容器的基础，每次执行 docker run 的时候都会指定哪个镜像作为容器运行的基础。在之前的例子中，我们所使用的都是来自于 Docker Hub 的镜像。直接使用这些镜像是可以满足一定的需求，而当这些镜像无法直接满足需求时，我们就需要定制这些镜像。接下来的几节就将讲解如何定制镜像。</p>
<p>回顾一下之前我们学到的知识，镜像是多层存储，每一层是在前一层的基础上进行的修改；而容器同样也是多层存储，是在以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p>
<p>现在让我们以定制一个 Web 服务器为例子，来讲解镜像是如何构建的。</p>
<p>docker run –name webserver -d -p 80:80 nginx</p>
<p>这条命令会用 nginx 镜像启动一个容器，命名为 webserver，并且映射了 80 端口，这样我们可以用浏览器去访问这个 nginx 服务器。</p>
<p>如果是在 Linux 本机运行的 Docker，或者如果使用的是 Docker for Mac、Docker for Windows，那么可以直接访问：<a href="http://localhost；如果使用的是" target="_blank" rel="noopener">http://localhost；如果使用的是</a> Docker Toolbox，或者是在虚拟机、云服务器上安装的 Docker，则需要将 localhost 换为虚拟机地址或者实际云服务器地址。</p>
<p>直接用浏览器访问的话，我们会看到默认的 Nginx 欢迎页面。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134833.gif" alt="https://www.funtl.com/assets/images-mac-example-nginx.png"></p>
<p>现在，假设我们非常不喜欢这个欢迎页面，我们希望改成欢迎 Docker 的文字，我们可以使用 docker exec 命令进入容器，修改其内容。</p>
<p>docker exec -it webserver bash</p>
<p>root@3729b97e8226:/# echo ‘<h1>Hello, Docker!</h1>‘ &gt; /usr/share/nginx/html/index.html</p>
<p>root@3729b97e8226:/# exit</p>
<p>exit</p>
<p>我们以交互式终端方式进入 webserver 容器，并执行了 bash 命令，也就是获得一个可操作的 Shell。</p>
<p>然后，我们用 <h1>Hello, Docker!</h1> 覆盖了 /usr/share/nginx/html/index.html 的内容。</p>
<p>现在我们再刷新浏览器的话，会发现内容被改变了。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134836.gif" alt="https://www.funtl.com/assets/images-create-nginx-docker.png"></p>
<p>我们修改了容器的文件，也就是改动了容器的存储层。我们可以通过 docker diff 命令看到具体的改动。</p>
<p>docker diff webserver</p>
<p>C /root</p>
<p>A /root/.bash_history</p>
<p>C /run</p>
<p>C /usr</p>
<p>C /usr/share</p>
<p>C /usr/share/nginx</p>
<p>C /usr/share/nginx/html</p>
<p>C /usr/share/nginx/html/index.html</p>
<p>C /var</p>
<p>C /var/cache</p>
<p>C /var/cache/nginx</p>
<p>A /var/cache/nginx/client_temp</p>
<p>A /var/cache/nginx/fastcgi_temp</p>
<p>A /var/cache/nginx/proxy_temp</p>
<p>A /var/cache/nginx/scgi_temp</p>
<p>A /var/cache/nginx/uwsgi_temp</p>
<p>现在我们定制好了变化，我们希望能将其保存下来形成镜像。</p>
<p>要知道，当我们运行一个容器的时候（如果不使用卷的话），我们做的任何文件修改都会被记录于容器存储层里。而 Docker 提供了一个 docker commit 命令，可以将容器的存储层保存下来成为镜像。换句话说，就是在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原有容器最后的文件变化。</p>
<p>docker commit 的语法格式为：</p>
<p>docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</p>
<p>我们可以用下面的命令将容器保存为镜像：</p>
<p>docker commit \</p>
<p>  –author “Tao Wang <a href="mailto:&#x74;&#x77;&#97;&#x6e;&#x67;&#x32;&#50;&#x31;&#x38;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;">&#x74;&#x77;&#97;&#x6e;&#x67;&#x32;&#50;&#x31;&#x38;&#64;&#x67;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;</a>“ \</p>
<p>  –message “修改了默认网页” \</p>
<p>  webserver \</p>
<p>  nginx:v2</p>
<p>其中 –author 是指定修改的作者，而 –message 则是记录本次修改的内容。这点和 git 版本控制相似，不过这里这些信息可以省略留空。</p>
<p>我们可以在 docker image ls 中看到这个新定制的镜像：</p>
<p>docker image ls nginx</p>
<p>REPOSITORY     TAG         IMAGE ID      CREATED       SIZE</p>
<p>nginx        v2          07e334659748    9 seconds ago    181.5 MB</p>
<p>nginx        1.11        05a60462f8ba    12 days ago     181.5 MB</p>
<p>nginx        latest       e43d811ce2f4    4 weeks ago     181.5 MB</p>
<p>我们还可以用 <code>docker history</code> 具体查看镜像内的历史记录，如果比较 <code>nginx:latest</code> 的历史记录，我们会发现新增了我们刚刚提交的这一层。</p>
<p>docker history nginx:v2</p>
<p>IMAGE        CREATED       CREATED BY                   SIZE        COMMENT</p>
<p>07e334659748    54 seconds ago   nginx -g daemon off;              95 B        修改了默认网页</p>
<p>e43d811ce2f4    4 weeks ago     /bin/sh -c #(nop) CMD [“nginx” “-g” “daemon  0 B</p>
<p><missing>      4 weeks ago     /bin/sh -c #(nop) EXPOSE 443/tcp 80/tcp    0 B</p>
<p><missing>      4 weeks ago     /bin/sh -c ln -sf /dev/stdout /var/log/nginx/  22 B</p>
<p><missing>      4 weeks ago     /bin/sh -c apt-key adv –keyserver hkp://pgp.  58.46 MB</p>
<p><missing>      4 weeks ago     /bin/sh -c #(nop) ENV NGINX_VERSION=1.11.5-1  0 B</p>
<p><missing>      4 weeks ago     /bin/sh -c #(nop) MAINTAINER NGINX Docker Ma  0 B</p>
<p><missing>      4 weeks ago     /bin/sh -c #(nop) CMD [“/bin/bash”]      0 B</p>
<p><missing>      4 weeks ago     /bin/sh -c #(nop) ADD file:23aa4f893e3288698c  123 MB</p>
<p>新的镜像定制好后，我们可以来运行这个镜像。</p>
<p>docker run –name web2 -d -p 81:80 nginx:v2</p>
<p>这里我们命名为新的服务为 web2，并且映射到 81 端口。如果是 Docker for Mac/Windows 或 Linux 桌面的话，我们就可以直接访问 <a href="http://localhost:81" target="_blank" rel="noopener">http://localhost:81</a> 看到结果，其内容应该和之前修改后的 webserver 一样。</p>
<p>至此，我们第一次完成了定制镜像，使用的是 docker commit 命令，手动操作给旧的镜像添加了新的一层，形成新的镜像，对镜像多层存储应该有了更直观的感觉。</p>
<h3 id="4-4-1-慎用-docker-commit"><a href="#4-4-1-慎用-docker-commit" class="headerlink" title="4.4.1. 慎用 docker commit"></a>4.4.1. 慎用 docker commit</h3><p>使用 docker commit 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。</p>
<p>首先，如果仔细观察之前的 docker diff webserver 的结果，你会发现除了真正想要修改的 /usr/share/nginx/html/index.html 文件外，由于命令的执行，还有很多文件被改动或添加了。这还仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像极为臃肿。</p>
<p>此外，使用 docker commit 意味着所有对镜像的操作都是黑箱操作，生成的镜像也被称为黑箱镜像，换句话说，就是除了制作镜像的人知道执行过什么命令、怎么生成的镜像，别人根本无从得知。而且，即使是这个制作镜像的人，过一段时间后也无法记清具体在操作的。虽然 docker diff 或许可以告诉得到一些线索，但是远远不到可以确保生成一致镜像的地步。这种黑箱镜像的维护工作是非常痛苦的。</p>
<p>而且，回顾之前提及的镜像所使用的分层存储的概念，除当前层外，之前的每一层都是不会发生改变的，换句话说，任何修改的结果仅仅是在当前层进行标记、添加、修改，而不会改动上一层。如果使用 docker commit 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。</p>
<h2 id="4-5-使用-Dockerfile-定制镜像"><a href="#4-5-使用-Dockerfile-定制镜像" class="headerlink" title="4.5.   使用 Dockerfile 定制镜像"></a>4.5.   使用 Dockerfile 定制镜像</h2><h3 id="4-5-1-Dockerfile-定制镜像"><a href="#4-5-1-Dockerfile-定制镜像" class="headerlink" title="4.5.1. Dockerfile 定制镜像"></a>4.5.1. Dockerfile 定制镜像</h3><p>从刚才的 docker commit 的学习中，我们可以了解到，镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>还以之前定制 nginx 镜像为例，这次我们使用 Dockerfile 来定制。</p>
<p>在一个空白目录中，建立一个文本文件，并命名为 Dockerfile：</p>
<p>mkdir mynginx</p>
<p>cd mynginx</p>
<p>touch Dockerfile</p>
<p>其内容为：</p>
<p>FROM nginx</p>
<p>RUN echo ‘<h1>Hello, Docker!</h1>‘ &gt; /usr/share/nginx/html/index.html</p>
<p>这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。</p>
<h3 id="4-5-2-FROM-指定基础镜像"><a href="#4-5-2-FROM-指定基础镜像" class="headerlink" title="4.5.2. FROM 指定基础镜像"></a>4.5.2. FROM 指定基础镜像</h3><p>所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。</p>
<p>在 Docker Store 上有非常多的高质量的官方镜像，有可以直接拿来使用的服务类的镜像，如 nginx、redis、mongo、mysql、httpd、php、tomcat 等；也有一些方便开发、构建、运行各种语言应用的镜像，如 node、openjdk、python、ruby、golang 等。可以在其中寻找一个最符合我们最终目标的镜像为基础镜像进行定制。</p>
<p>如果没有找到对应服务的镜像，官方镜像中还提供了一些更为基础的操作系统镜像，如 ubuntu、debian、centos、fedora、alpine 等，这些操作系统的软件库为我们提供了更广阔的扩展空间。</p>
<p>除了选择现有镜像为基础镜像外，Docker 还存在一个特殊的镜像，名为 scratch。这个镜像是虚拟的概念，并不实际存在，它表示一个空白的镜像。</p>
<p>FROM scratch</p>
<p>…</p>
<p>如果你以 scratch 为基础镜像的话，意味着你不以任何镜像为基础，接下来所写的指令将作为镜像第一层开始存在。</p>
<p>不以任何系统为基础，直接将可执行文件复制进镜像的做法并不罕见，比如 swarm、coreos/etcd。对于 Linux 下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接 FROM scratch 会让镜像体积更加小巧。使用 Go 语言 开发的应用很多会使用这种方式来制作镜像，这也是为什么有人认为 Go 是特别适合容器微服务架构的语言的原因之一。</p>
<h3 id="4-5-3-RUN-执行命令"><a href="#4-5-3-RUN-执行命令" class="headerlink" title="4.5.3. RUN 执行命令"></a>4.5.3. RUN 执行命令</h3><p>RUN 指令是用来执行命令行命令的。由于命令行的强大能力，RUN 指令在定制镜像时是最常用的指令之一。其格式有两种：</p>
<p>shell 格式：RUN &lt;命令&gt;，就像直接在命令行中输入的命令一样。刚才写的 Dockerfile 中的 RUN 指令就是这种格式。</p>
<p>RUN echo ‘<h1>Hello, Docker!</h1>‘ &gt; /usr/share/nginx/html/index.html</p>
<p>exec 格式：RUN [“可执行文件”, “参数1”, “参数2”]，这更像是函数调用中的格式。</p>
<p>既然 RUN 就像 Shell 脚本一样可以执行命令，那么我们是否就可以像 Shell 脚本一样把每个命令对应一个 RUN 呢？比如这样：</p>
<p>FROM debian:jessie</p>
<p>RUN apt-get update</p>
<p>RUN apt-get install -y gcc libc6-dev make</p>
<p>RUN wget -O redis.tar.gz “<a href="http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;" target="_blank" rel="noopener">http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</a></p>
<p>RUN mkdir -p /usr/src/redis</p>
<p>RUN tar -xzf redis.tar.gz -C /usr/src/redis –strip-components=1</p>
<p>RUN make -C /usr/src/redis</p>
<p>RUN make -C /usr/src/redis install</p>
<p>之前说过，Dockerfile 中每一个指令都会建立一层，RUN 也不例外。每一个 RUN 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，commit 这一层的修改，构成新的镜像。</p>
<p>而上面的这种写法，创建了 7 层镜像。这是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。 这是很多初学 Docker 的人常犯的一个错误。</p>
<p>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</p>
<p>上面的 Dockerfile 正确的写法应该是这样：</p>
<p>FROM debian:jessie</p>
<p>RUN buildDeps=’gcc libc6-dev make’ \</p>
<p>  &amp;&amp; apt-get update \</p>
<p>  &amp;&amp; apt-get install -y $buildDeps \</p>
<p>  &amp;&amp; wget -O redis.tar.gz “<a href="http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;" target="_blank" rel="noopener">http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;</a> \</p>
<p>  &amp;&amp; mkdir -p /usr/src/redis \</p>
<p>  &amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis –strip-components=1 \</p>
<p>  &amp;&amp; make -C /usr/src/redis \</p>
<p>  &amp;&amp; make -C /usr/src/redis install \</p>
<p>  &amp;&amp; rm -rf /var/lib/apt/lists/* \</p>
<p>  &amp;&amp; rm redis.tar.gz \</p>
<p>  &amp;&amp; rm -r /usr/src/redis \</p>
<p>  &amp;&amp; apt-get purge -y –auto-remove $buildDeps</p>
<p>首先，之前所有的命令只有一个目的，就是编译、安装 redis 可执行文件。因此没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 RUN 对一一对应不同的命令，而是仅仅使用一个 RUN 指令，并使用 &amp;&amp; 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p>
<p>并且，这里为了格式化还进行了换行。Dockerfile 支持 Shell 类的行尾添加 \ 的命令换行方式，以及行首 # 进行注释的格式。良好的格式，比如换行、缩进、注释等，会让维护、排障更为容易，这是一个比较好的习惯。</p>
<p>此外，还可以看到这一组命令的最后添加了清理工作的命令，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了 apt 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p>
<p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。</p>
<h3 id="4-5-4-构建镜像"><a href="#4-5-4-构建镜像" class="headerlink" title="4.5.4. 构建镜像"></a>4.5.4. 构建镜像</h3><p>好了，让我们再回到之前定制的 nginx 镜像的 Dockerfile 来。现在我们明白了这个 Dockerfile 的内容，那么让我们来构建这个镜像吧。</p>
<p>在 Dockerfile 文件所在目录执行：</p>
<p>docker build -t nginx:v3 .</p>
<p>从命令的输出结果中，我们可以清晰的看到镜像的构建过程。在 Step 2 中，如同我们之前所说的那样，RUN 指令启动了一个容器 9cdc27646c7b，执行了所要求的命令，并最后提交了这一层 44aa4490ce2c，随后删除了所用到的这个容器 9cdc27646c7b。</p>
<p>这里我们使用了 docker build 命令进行镜像构建。其格式为：</p>
<p>docker build [选项] &lt;上下文路径/URL/-&gt;</p>
<p>在这里我们指定了最终镜像的名称 -t nginx:v3，构建成功后，我们可以像之前运行 nginx:v2 那样来运行这个镜像，其结果会和 nginx:v2 一样。</p>
<h3 id="4-5-5-镜像构建上下文（Context）"><a href="#4-5-5-镜像构建上下文（Context）" class="headerlink" title="4.5.5. 镜像构建上下文（Context）"></a>4.5.5. 镜像构建上下文（Context）</h3><p>如果注意，会看到 docker build 命令最后有一个 .。. 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定上下文路径。那么什么是上下文呢？</p>
<p>首先我们要理解 docker build 的工作原理。Docker 在运行时分为 Docker 引擎（也就是服务端守护进程）和客户端工具。Docker 的引擎提供了一组 REST API，被称为 Docker Remote API，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</p>
<p>当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p>
<p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p>
<p>如果在 Dockerfile 中这么写：</p>
<p>COPY ./package.json /app/</p>
<p>这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。</p>
<p>因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。</p>
<p>现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 .，实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。</p>
<p>如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程：</p>
<p>docker build -t nginx:v3 .</p>
<p>理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 COPY /opt/xxxx /app 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。</p>
<p>一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p>
<p>那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。</p>
<p>这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。</p>
<p>当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。</p>
<h3 id="4-5-6-其它-docker-build-的用法"><a href="#4-5-6-其它-docker-build-的用法" class="headerlink" title="4.5.6. 其它 docker build 的用法"></a>4.5.6. 其它 docker build 的用法</h3><h4 id="4-5-6-1-直接用-Git-repo-进行构建"><a href="#4-5-6-1-直接用-Git-repo-进行构建" class="headerlink" title="4.5.6.1.   直接用 Git repo 进行构建"></a>4.5.6.1.   直接用 Git repo 进行构建</h4><p>或许你已经注意到了，docker build 还支持从 URL 构建，比如可以直接从 Git repo 中构建：</p>
<p>docker build <a href="https://github.com/twang2218/gitlab-ce-zh.git#:8.14" target="_blank" rel="noopener">https://github.com/twang2218/gitlab-ce-zh.git#:8.14</a></p>
<p>这行命令指定了构建所需的 Git repo，并且指定默认的 master 分支，构建目录为 /8.14/，然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>
<h4 id="4-5-6-2-用给定的-tar-压缩包构建"><a href="#4-5-6-2-用给定的-tar-压缩包构建" class="headerlink" title="4.5.6.2.   用给定的 tar 压缩包构建"></a>4.5.6.2.   用给定的 tar 压缩包构建</h4><p>docker build <a href="http://server/context.tar.gz" target="_blank" rel="noopener">http://server/context.tar.gz</a></p>
<p>如果所给出的 URL 不是个 Git repo，而是个 tar 压缩包，那么 Docker 引擎会下载这个包，并自动解压缩，以其作为上下文，开始构建。</p>
<h4 id="4-5-6-3-从标准输入中读取-Dockerfile-进行构建"><a href="#4-5-6-3-从标准输入中读取-Dockerfile-进行构建" class="headerlink" title="4.5.6.3.   从标准输入中读取 Dockerfile 进行构建"></a>4.5.6.3.   从标准输入中读取 Dockerfile 进行构建</h4><p>docker build - &lt; Dockerfile</p>
<p>或</p>
<p>cat Dockerfile | docker build -</p>
<p>如果标准输入传入的是文本文件，则将其视为 Dockerfile，并开始构建。这种形式由于直接从标准输入中读取 Dockerfile 的内容，它没有上下文，因此不可以像其他方法那样可以将本地文件 COPY 进镜像之类的事情。</p>
<h4 id="4-5-6-4-从标准输入中读取上下文压缩包进行构建"><a href="#4-5-6-4-从标准输入中读取上下文压缩包进行构建" class="headerlink" title="4.5.6.4.   从标准输入中读取上下文压缩包进行构建"></a>4.5.6.4.   从标准输入中读取上下文压缩包进行构建</h4><p>docker build - &lt; context.tar.gz</p>
<p>如果发现标准输入的文件格式是 gzip、bzip2 以及 xz 的话，将会使其为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p>
<h2 id="4-6-Dockerfile-指令详解"><a href="#4-6-Dockerfile-指令详解" class="headerlink" title="4.6.   Dockerfile 指令详解"></a>4.6.   Dockerfile 指令详解</h2><p>我们已经介绍了 FROM，RUN，还提及了 COPY, ADD，其实 Dockerfile 功能很强大，它提供了十多个指令。下面我们继续讲解其他的指令。</p>
<h3 id="4-6-1-COPY-复制文件"><a href="#4-6-1-COPY-复制文件" class="headerlink" title="4.6.1. COPY 复制文件"></a>4.6.1. COPY 复制文件</h3><p>格式：</p>
<p>l COPY &lt;源路径&gt;… &lt;目标路径&gt;</p>
<p>l COPY [“&lt;源路径1&gt;”,… “&lt;目标路径&gt;”]</p>
<p>和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。</p>
<p>COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置。比如：</p>
<p>COPY package.json /usr/src/app/</p>
<p>&lt;源路径&gt; 可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：</p>
<p>COPY hom* /mydir/</p>
<p>COPY hom?.txt /mydir/</p>
<p>&lt;目标路径&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>
<h3 id="4-6-2-ADD-更高级的复制文件"><a href="#4-6-2-ADD-更高级的复制文件" class="headerlink" title="4.6.2. ADD 更高级的复制文件"></a>4.6.2. ADD 更高级的复制文件</h3><p>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。</p>
<p>比如 &lt;源路径&gt; 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 &lt;目标路径&gt; 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。</p>
<p>如果 &lt;源路径&gt; 为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 &lt;目标路径&gt; 去。</p>
<p>在某些情况下，这个自动解压缩的功能非常有用，比如官方镜像 ubuntu 中：</p>
<p>FROM scratch</p>
<p>ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</p>
<p>…</p>
<p>但在某些情况下，如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 ADD 命令了。</p>
<p>在 Docker 官方的 Dockerfile 最佳实践文档 中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。</p>
<p>另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>
<p>因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。</p>
<h3 id="4-6-3-CMD-容器启动命令"><a href="#4-6-3-CMD-容器启动命令" class="headerlink" title="4.6.3. CMD 容器启动命令"></a>4.6.3. CMD 容器启动命令</h3><p>CMD 指令的格式和 RUN 相似，也是两种格式：</p>
<p>l shell 格式：CMD &lt;命令&gt;</p>
<p>l exec 格式：CMD [“可执行文件”, “参数1”, “参数2”…]</p>
<p>l 参数列表格式：CMD [“参数1”, “参数2”…]。在指定了 ENTRYPOINT 指令后，用 CMD 指定具体的参数。</p>
<p>之前介绍容器的时候曾经说过，Docker 不是虚拟机，容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。</p>
<p>在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如，ubuntu 镜像默认的 CMD 是 /bin/bash，如果我们直接 docker run -it ubuntu 的话，会直接进入 bash。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release。这就是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，输出了系统版本信息。</p>
<p>在指令格式上，一般推荐使用 exec 格式，这类格式在解析时会被解析为 JSON 数组，因此一定要使用双引号 “，而不要使用单引号。</p>
<p>如果使用 shell 格式的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如：</p>
<p>CMD echo $HOME</p>
<p>在实际执行中，会将其变更为：</p>
<p>CMD [ “sh”, “-c”, “echo $HOME” ]</p>
<p>这就是为什么我们可以使用环境变量的原因，因为这些环境变量会被 shell 进行解析处理。</p>
<p>提到 CMD 就不得不提容器中应用在前台执行和后台执行的问题。这是初学者常出现的一个混淆。</p>
<p>Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 upstart/systemd 去启动后台服务，容器内没有后台服务的概念。</p>
<p>一些初学者将 CMD 写为：</p>
<p>CMD service nginx start</p>
<p>然后发现容器执行后就立即退出了。甚至在容器内去使用 systemctl 命令结果却发现根本执行不了。这就是因为没有搞明白前台、后台的概念，没有区分容器和虚拟机的差异，依旧在以传统虚拟机的角度去理解容器。</p>
<p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就失去了存在的意义，从而退出，其它辅助进程不是它需要关心的东西。</p>
<p>而使用 service nginx start 命令，则是希望 upstart 来以后台守护进程形式启动 nginx 服务。而刚才说了 CMD service nginx start 会被理解为 CMD [ “sh”, “-c”, “service nginx start”]，因此主进程实际上是 sh。那么当 service nginx start 命令结束后，sh 也就结束了，sh 作为主进程退出了，自然就会令容器退出。</p>
<p>正确的做法是直接执行 nginx 可执行文件，并且要求以前台形式运行。比如：</p>
<p>CMD [“nginx”, “-g”, “daemon off;”]</p>
<h3 id="4-6-4-ENTRYPOINT-入口点"><a href="#4-6-4-ENTRYPOINT-入口点" class="headerlink" title="4.6.4. ENTRYPOINT 入口点"></a>4.6.4. ENTRYPOINT 入口点</h3><p>ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。</p>
<p>ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 –entrypoint 来指定。</p>
<p>当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：</p>
<p><ENTRYPOINT> “<CMD>“</p>
<p>那么有了 CMD 后，为什么还要有 ENTRYPOINT 呢？这种 <ENTRYPOINT> “<CMD>“ 有什么好处么？让我们来看几个场景。</p>
<p><strong>场景一：让镜像变成像命令一样使用</strong></p>
<p>假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现：</p>
<p>FROM ubuntu:16.04</p>
<p>RUN apt-get update \</p>
<p>  &amp;&amp; apt-get install -y curl \</p>
<p>  &amp;&amp; rm -rf /var/lib/apt/lists/*</p>
<p>CMD [ “curl”, “-s”, “<a href="http://ip.cn&quot;" target="_blank" rel="noopener">http://ip.cn&quot;</a> ]</p>
<p>假如我们使用 docker build -t myip . 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行：</p>
<p>docker run myip</p>
<p>当前 IP：61.148.226.66 来自：北京市 联通</p>
<p>嗯，这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 CMD 中可以看到实质的命令是 curl，那么如果我们希望显示 HTTP 头信息，就需要加上 -i 参数。那么我们可以直接加 -i 参数给 docker run myip 么？</p>
<p>docker run myip -i</p>
<p>docker: Error response from daemon: invalid header field value “oci runtime error: container_linux.go:247: starting container process caused &quot;exec: \&quot;-i\&quot;: executable file not found in $PATH&quot;\n”.</p>
<p>我们可以看到可执行文件找不到的报错，executable file not found。之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的 CMD，而不是添加在原来的 curl -s <a href="http://ip.cn" target="_blank" rel="noopener">http://ip.cn</a> 后面。而 -i 根本不是命令，所以自然找不到。</p>
<p>那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令：</p>
<p>docker run myip curl -s <a href="http://ip.cn" target="_blank" rel="noopener">http://ip.cn</a> -i</p>
<p>这显然不是很好的解决方案，而使用 ENTRYPOINT 就可以解决这个问题。现在我们重新用 ENTRYPOINT 来实现这个镜像：</p>
<p>FROM ubuntu:16.04</p>
<p>RUN apt-get update \</p>
<p>  &amp;&amp; apt-get install -y curl \</p>
<p>  &amp;&amp; rm -rf /var/lib/apt/lists/*</p>
<p>ENTRYPOINT [ “curl”, “-s”, “<a href="http://ip.cn&quot;" target="_blank" rel="noopener">http://ip.cn&quot;</a> ]</p>
<p>这次我们再来尝试直接使用 docker run myip -i：</p>
<p>docker run myip</p>
<p>当前 IP：61.148.226.66 来自：北京市 联通</p>
<p>docker run myip -i</p>
<p>HTTP/1.1 200 OK</p>
<p>Server: nginx/1.8.0</p>
<p>Date: Tue, 22 Nov 2016 05:12:40 GMT</p>
<p>Content-Type: text/html; charset=UTF-8</p>
<p>Vary: Accept-Encoding</p>
<p>X-Powered-By: PHP/5.6.24-1~dotdeb+7.1</p>
<p>X-Cache: MISS from cache-2</p>
<p>X-Cache-Lookup: MISS from cache-2:80</p>
<p>X-Cache: MISS from proxy-2_6</p>
<p>Transfer-Encoding: chunked</p>
<p>Via: 1.1 cache-2:80, 1.1 proxy-2_6:8006</p>
<p>Connection: keep-alive</p>
<p>当前 IP：61.148.226.66 来自：北京市 联通</p>
<p>可以看到，这次成功了。这是因为当存在 ENTRYPOINT 后，CMD 的内容将会作为参数传给 ENTRYPOINT，而这里 -i 就是新的 CMD，因此会作为参数传给 curl，从而达到了我们预期的效果。</p>
<p><strong>场景二：应用运行前的准备工作</strong></p>
<p>启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。</p>
<p>比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。</p>
<p>此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。</p>
<p>这些准备工作是和容器 CMD 无关的，无论 CMD 为什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入 ENTRYPOINT 中去执行，而这个脚本会将接到的参数（也就是 <CMD>）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的：</p>
<p>FROM alpine:3.4</p>
<p>…</p>
<p>RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis</p>
<p>…</p>
<p>ENTRYPOINT [“docker-entrypoint.sh”]</p>
<p>EXPOSE 6379</p>
<p>CMD [ “redis-server” ]</p>
<p>可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了 ENTRYPOINT 为 docker-entrypoint.sh 脚本。</p>
<p>#!/bin/sh</p>
<p>…</p>
<p># allow the container to be started with <code>--user</code></p>
<p>if [ “$1” = ‘redis-server’ -a “$(id -u)” = ‘0’ ]; then</p>
<p>​    chown -R redis .</p>
<p>​    exec su-exec redis “$0” “$@”</p>
<p>fi</p>
<p>exec “$@”</p>
<p>该脚本的内容就是根据 CMD 的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行。比如：</p>
<p>docker run -it redis id</p>
<p>uid=0(root) gid=0(root) groups=0(root)</p>
<h3 id="4-6-5-ENV-设置环境变量"><a href="#4-6-5-ENV-设置环境变量" class="headerlink" title="4.6.5. ENV 设置环境变量"></a>4.6.5. ENV 设置环境变量</h3><p>格式有两种：</p>
<p>l ENV <key> <value></p>
<p>l ENV <key1>=<value1> <key2>=<value2>…</p>
<p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<p>ENV VERSION=1.0 DEBUG=on NAME=”Happy Feet”</p>
<p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p>
<p>定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。比如在官方 node 镜像 Dockerfile 中，就有类似这样的代码：</p>
<p>ENV NODE_VERSION 7.2.0</p>
<p>RUN curl -SLO “<a href="https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot;" target="_blank" rel="noopener">https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz&quot;</a> \</p>
<p> &amp;&amp; curl -SLO “<a href="https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;" target="_blank" rel="noopener">https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;</a> \</p>
<p> &amp;&amp; gpg –batch –decrypt –output SHASUMS256.txt SHASUMS256.txt.asc \</p>
<p> &amp;&amp; grep “ node-v$NODE_VERSION-linux-x64.tar.xz$“ SHASUMS256.txt | sha256sum -c - \</p>
<p> &amp;&amp; tar -xJf “node-v$NODE_VERSION-linux-x64.tar.xz” -C /usr/local –strip-components=1 \</p>
<p> &amp;&amp; rm “node-v$NODE_VERSION-linux-x64.tar.xz” SHASUMS256.txt.asc SHASUMS256.txt \</p>
<p> &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs</p>
<p>在这里先定义了环境变量 NODE_VERSION，其后的 RUN 这层里，多次使用 $NODE_VERSION 来进行操作定制。可以看到，将来升级镜像构建版本的时候，只需要更新 7.2.0 即可，Dockerfile 构建维护变得更轻松了。</p>
<p>下列指令可以支持环境变量展开： ADD、COPY、ENV、EXPOSE、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD。</p>
<p>可以从这个指令列表里感觉到，环境变量可以使用的地方很多，很强大。通过环境变量，我们可以让一份 Dockerfile 制作更多的镜像，只需使用不同的环境变量即可。</p>
<h3 id="4-6-6-ARG-构建参数"><a href="#4-6-6-ARG-构建参数" class="headerlink" title="4.6.6. ARG 构建参数"></a>4.6.6. ARG 构建参数</h3><p>格式：ARG &lt;参数名&gt;[=&lt;默认值&gt;]</p>
<p>构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。</p>
<p>Dockerfile 中的 ARG 指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令 docker build 中用 –build-arg &lt;参数名&gt;=&lt;值&gt; 来覆盖。</p>
<p>在 1.13 之前的版本，要求 –build-arg 中的参数名，必须在 Dockerfile 中用 ARG 定义过了，换句话说，就是 –build-arg 指定的参数，必须在 Dockerfile 中使用了。如果对应参数没有被使用，则会报错退出构建。从 1.13 开始，这种严格的限制被放开，不再报错退出，而是显示警告信息，并继续构建。这对于使用 CI 系统，用同样的构建流程构建不同的 Dockerfile 的时候比较有帮助，避免构建命令必须根据每个 Dockerfile 的内容修改。</p>
<h3 id="4-6-7-VOLUME-定义匿名卷"><a href="#4-6-7-VOLUME-定义匿名卷" class="headerlink" title="4.6.7. VOLUME 定义匿名卷"></a>4.6.7. VOLUME 定义匿名卷</h3><p>格式为：</p>
<p>l VOLUME [“&lt;路径1&gt;”, “&lt;路径2&gt;”…]</p>
<p>l VOLUME &lt;路径&gt;</p>
<p>之前我们说过，容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，后面的章节我们会进一步介绍 Docker 卷的概念。为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在 Dockerfile 中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。</p>
<p>VOLUME /data</p>
<p>这里的 /data 目录就会在运行时自动挂载为匿名卷，任何向 /data 中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。当然，运行时可以覆盖这个挂载设置。比如：</p>
<p>docker run -d -v mydata:/data xxxx</p>
<p>在这行命令中，就使用了 mydata 这个命名卷挂载到了 /data 这个位置，替代了 Dockerfile 中定义的匿名卷的挂载配置。</p>
<h3 id="4-6-8-EXPOSE-暴露端口"><a href="#4-6-8-EXPOSE-暴露端口" class="headerlink" title="4.6.8. EXPOSE 暴露端口"></a>4.6.8. EXPOSE 暴露端口</h3><p>格式为 EXPOSE &lt;端口1&gt; [&lt;端口2&gt;…]。</p>
<p>EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。</p>
<p>此外，在早期 Docker 版本中还有一个特殊的用处。以前所有容器都运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个 Docker 引擎参数 –icc=false，当指定该参数后，容器间将默认无法互访，除非互相间使用了 –links 参数的容器才可以互通，并且只有镜像中 EXPOSE 所声明的端口才可以被访问。这个 –icc=false 的用法，在引入了 docker network 后已经基本不用了，通过自定义网络可以很轻松的实现容器间的互联与隔离。</p>
<p>要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h3 id="4-6-9-WORKDIR-指定工作目录"><a href="#4-6-9-WORKDIR-指定工作目录" class="headerlink" title="4.6.9. WORKDIR 指定工作目录"></a>4.6.9. WORKDIR 指定工作目录</h3><p>格式为 WORKDIR &lt;工作目录路径&gt;。</p>
<p>使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。</p>
<p>之前提到一些初学者常犯的错误是把 Dockerfile 等同于 Shell 脚本来书写，这种错误的理解还可能会导致出现下面这样的错误：</p>
<p>RUN cd /app</p>
<p>RUN echo “hello” &gt; world.txt</p>
<p>如果将这个 Dockerfile 进行构建镜像运行后，会发现找不到 /app/world.txt 文件，或者其内容不是 hello。原因其实很简单，在 Shell 中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响后一个命令；而在 Dockerfile 中，这两行 RUN 命令的执行环境根本不同，是两个完全不同的容器。这就是对 Dockerfile 构建分层存储的概念不了解所导致的错误。</p>
<p>之前说过每一个 RUN 都是启动一个容器、执行命令、然后提交存储层文件变更。第一层 RUN cd /app 的执行仅仅是当前进程的工作目录变更，一个内存上的变化而已，其结果不会造成任何文件变更。而到第二层的时候，启动的是一个全新的容器，跟第一层的容器更完全没关系，自然不可能继承前一层构建过程中的内存变化。</p>
<p>因此如果需要改变以后各层的工作目录的位置，那么应该使用 WORKDIR 指令。</p>
<h3 id="4-6-10-USER-指定当前用户"><a href="#4-6-10-USER-指定当前用户" class="headerlink" title="4.6.10.    USER 指定当前用户"></a>4.6.10.    USER 指定当前用户</h3><p>格式：USER &lt;用户名&gt;</p>
<p>USER 指令和 WORKDIR 相似，都是改变环境状态并影响以后的层。WORKDIR 是改变工作目录，USER 则是改变之后层的执行 RUN, CMD 以及 ENTRYPOINT 这类命令的身份。</p>
<p>当然，和 WORKDIR 一样，USER 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<p>RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</p>
<p>USER redis</p>
<p>RUN [ “redis-server” ]</p>
<p>如果以 root 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 su 或者 sudo，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 gosu。</p>
<p># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</p>
<p>RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</p>
<p># 下载 gosu</p>
<p>RUN wget -O /usr/local/bin/gosu “<a href="https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot;" target="_blank" rel="noopener">https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot;</a> \</p>
<p>  &amp;&amp; chmod +x /usr/local/bin/gosu \</p>
<p>  &amp;&amp; gosu nobody true</p>
<p># 设置 CMD，并以另外的用户执行</p>
<p>CMD [ “exec”, “gosu”, “redis”, “redis-server” ]</p>
<h3 id="4-6-11-HEALTHCHECK-健康检查"><a href="#4-6-11-HEALTHCHECK-健康检查" class="headerlink" title="4.6.11.    HEALTHCHECK 健康检查"></a>4.6.11.    HEALTHCHECK 健康检查</h3><p>格式：</p>
<p>l HEALTHCHECK [选项] CMD &lt;命令&gt;：设置检查容器健康状况的命令</p>
<p>l HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令</p>
<p>HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。</p>
<p>在没有 HEALTHCHECK 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。</p>
<p>而自 1.12 之后，Docker 提供了 HEALTHCHECK 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。</p>
<p>当在一个镜像指定了 HEALTHCHECK 指令后，用其启动容器，初始状态会为 starting，在 HEALTHCHECK 指令检查成功后变为 healthy，如果连续一定次数失败，则会变为 unhealthy。</p>
<p>HEALTHCHECK 支持下列选项：</p>
<p>l –interval=&lt;间隔&gt;：两次健康检查的间隔，默认为 30 秒；</p>
<p>l –timeout=&lt;时长&gt;：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；</p>
<p>l –retries=&lt;次数&gt;：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。</p>
<p>和 CMD, ENTRYPOINT 一样，HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。</p>
<p>在 HEALTHCHECK [选项] CMD 后面的命令，格式和 ENTRYPOINT 一样，分为 shell 格式，和 exec 格式。命令的返回值决定了该次健康检查的成功与否：0：成功；1：失败；2：保留，不要使用这个值。</p>
<p>假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 curl 来帮助判断，其 Dockerfile 的 HEALTHCHECK 可以这么写：</p>
<p>FROM nginx</p>
<p>RUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*</p>
<p>HEALTHCHECK –interval=5s –timeout=3s \</p>
<p> CMD curl -fs <a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> || exit 1</p>
<p>这里我们设置了每 5 秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过 3 秒没响应就视为失败，并且使用 curl -fs <a href="http://localhost/" target="_blank" rel="noopener">http://localhost/</a> || exit 1 作为健康检查命令。</p>
<p>使用 docker build 来构建这个镜像：</p>
<p>docker build -t myweb:v1 .</p>
<p>构建好了后，我们启动一个容器：</p>
<p>docker run -d –name web -p 80:80 myweb:v1</p>
<p>当运行该镜像后，可以通过 docker container ls 看到最初的状态为 (health: starting)：</p>
<p>docker container ls</p>
<p>CONTAINER ID    IMAGE        COMMAND         CREATED       STATUS              PORTS        NAMES</p>
<p>03e28eb00bd0    myweb:v1      “nginx -g ‘daemon off”  3 seconds ago    Up 2 seconds (health: starting)  80/tcp, 443/tcp   web</p>
<p>在等待几秒钟后，再次 docker container ls，就会看到健康状态变化为了 (healthy)：</p>
<p>docker container ls</p>
<p>CONTAINER ID    IMAGE        COMMAND         CREATED       STATUS          PORTS        NAMES</p>
<p>03e28eb00bd0    myweb:v1      “nginx -g ‘daemon off”  18 seconds ago   Up 16 seconds (healthy)  80/tcp, 443/tcp   web</p>
<p>如果健康检查连续失败超过了重试次数，状态就会变为 (unhealthy)。</p>
<p>为了帮助排障，健康检查命令的输出（包括 stdout 以及 stderr）都会被存储于健康状态里，可以用 docker inspect 来查看。</p>
<p>docker inspect –format ‘{json .State.Health}’ web | python -m json.tool</p>
<p>{</p>
<p>  “FailingStreak”: 0,</p>
<p>  “Log”: [</p>
<p>​    {</p>
<p>​      “End”: “2016-11-25T14:35:37.940957051Z”,</p>
<p>​      “ExitCode”: 0,</p>
<p>​      “Output”: “<!DOCTYPE html>\n<html>…… </html>\n”,</p>
<p>​      “Start”: “2019-11-25T14:35:37.780192565Z”</p>
<p>​    }</p>
<p>  ],</p>
<p>  “Status”: “healthy”</p>
<p>}</p>
<h3 id="4-6-12-ONBUILD-为他人作嫁衣"><a href="#4-6-12-ONBUILD-为他人作嫁衣" class="headerlink" title="4.6.12.    ONBUILD 为他人作嫁衣"></a>4.6.12.    ONBUILD 为他人作嫁衣</h3><p>格式：ONBUILD &lt;其它指令&gt;。</p>
<p>ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。</p>
<p>Dockerfile 中的其它指令都是为了定制当前镜像而准备的，唯有 ONBUILD 是为了帮助别人定制自己而准备的。</p>
<p>假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 npm 进行包管理，所有依赖、配置、启动信息等会放到 package.json 文件里。在拿到程序代码后，需要先进行 npm install 才可以获得所有需要的依赖。然后就可以通过 npm start 来启动应用。因此，一般来说会这样写 Dockerfile：</p>
<p>FROM node:slim</p>
<p>RUN mkdir /app</p>
<p>WORKDIR /app</p>
<p>COPY ./package.json /app</p>
<p>RUN [ “npm”, “install” ]</p>
<p>COPY . /app/</p>
<p>CMD [ “npm”, “start” ]</p>
<p>把这个 Dockerfile 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 Dockerfile 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。</p>
<p>如果第一个 Node.js 项目在开发过程中，发现这个 Dockerfile 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 Dockerfile，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 Dockerfile 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 Dockerfile，而第二个项目的 Dockerfile 就会被自动修复。</p>
<p>那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 Dockerfile 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 Dockerfile 就会变为：</p>
<p>FROM node:slim</p>
<p>RUN mkdir /app</p>
<p>WORKDIR /app</p>
<p>CMD [ “npm”, “start” ]</p>
<p>这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 my-node 的话，各个项目内的自己的 Dockerfile 就变为：</p>
<p>FROM my-node</p>
<p>COPY ./package.json /app</p>
<p>RUN [ “npm”, “install” ]</p>
<p>COPY . /app/</p>
<p>基础镜像变化后，各个项目都用这个 Dockerfile 重新构建镜像，会继承基础镜像的更新。</p>
<p>那么，问题解决了么？没有。准确说，只解决了一半。如果这个 Dockerfile 里面有些东西需要调整呢？比如 npm install 都需要加一些参数，那怎么办？这一行 RUN 是不可能放入基础镜像的，因为涉及到了当前项目的 ./package.json，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 Dockerfile 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。</p>
<p>ONBUILD 可以解决这个问题。让我们用 ONBUILD 重新写一下基础镜像的 Dockerfile:</p>
<p>FROM node:slim</p>
<p>RUN mkdir /app</p>
<p>WORKDIR /app</p>
<p>ONBUILD COPY ./package.json /app</p>
<p>ONBUILD RUN [ “npm”, “install” ]</p>
<p>ONBUILD COPY . /app/</p>
<p>CMD [ “npm”, “start” ]</p>
<p>这次我们回到原始的 Dockerfile，但是这次将项目相关的指令加上 ONBUILD，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 Dockerfile 就变成了简单地：</p>
<p>FROM my-node</p>
<p>是的，只有这么一行。当在各个项目目录中，用这个只有一行的 Dockerfile 构建镜像时，之前基础镜像的那三行 ONBUILD 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 npm install，生成应用镜像。</p>
<h3 id="4-6-13-参考文档"><a href="#4-6-13-参考文档" class="headerlink" title="4.6.13.    参考文档"></a>4.6.13.    参考文档</h3><p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfie 官方文档</a></p>
<p><a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener">Dockerfile 最佳实践文档</a></p>
<p><a href="https://github.com/docker-library/docs" target="_blank" rel="noopener">Docker 官方镜像 Dockerfile</a></p>
<h2 id="4-7-Dockerfile-多阶段构建"><a href="#4-7-Dockerfile-多阶段构建" class="headerlink" title="4.7.   Dockerfile 多阶段构建"></a>4.7.   Dockerfile 多阶段构建</h2><h3 id="4-7-1-之前的做法"><a href="#4-7-1-之前的做法" class="headerlink" title="4.7.1. 之前的做法"></a>4.7.1. 之前的做法</h3><p>在 Docker 17.05 版本之前，我们构建 Docker 镜像时，通常会采用两种方式：</p>
<h4 id="4-7-1-1-全部放入一个-Dockerfile"><a href="#4-7-1-1-全部放入一个-Dockerfile" class="headerlink" title="4.7.1.1.   全部放入一个 Dockerfile"></a>4.7.1.1.   全部放入一个 Dockerfile</h4><p>一种方式是将所有的构建过程编包含在一个 Dockerfile 中，包括项目及其依赖库的编译、测试、打包等流程，这里可能会带来的一些问题：</p>
<p>Dockerfile 特别长，可维护性降低</p>
<p>镜像层次多，镜像体积较大，部署时间变长</p>
<p>源代码存在泄露的风险</p>
<p>例如</p>
<p>编写 app.go 文件，该程序输出 Hello World!</p>
<p>package main </p>
<p>import “fmt” </p>
<p>func main(){ </p>
<p>  fmt.Printf(“Hello World!”);</p>
<p>}</p>
<p>编写 Dockerfile.one 文件</p>
<p>FROM golang:1.9-alpine</p>
<p>RUN apk –no-cache add git ca-certificates</p>
<p>WORKDIR /go/src/github.com/go/helloworld/</p>
<p>COPY app.go .</p>
<p>RUN go get -d -v github.com/go-sql-driver/mysql \</p>
<p> &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . \</p>
<p> &amp;&amp; cp /go/src/github.com/go/helloworld/app /root</p>
<p>WORKDIR /root/</p>
<p>CMD [“./app”]</p>
<p>构建镜像</p>
<p>docker build -t go/helloworld:1 -f Dockerfile.one</p>
<h4 id="4-7-1-2-分散到多个-Dockerfile"><a href="#4-7-1-2-分散到多个-Dockerfile" class="headerlink" title="4.7.1.2.   分散到多个 Dockerfile"></a>4.7.1.2.   分散到多个 Dockerfile</h4><p>另一种方式，就是我们事先在一个 Dockerfile 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要我们编写两个 Dockerfile 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，但明显部署过程较复杂。</p>
<p>例如</p>
<p>编写 Dockerfile.build 文件</p>
<p>FROM golang:1.9-alpine</p>
<p>RUN apk –no-cache add git</p>
<p>WORKDIR /go/src/github.com/go/helloworld</p>
<p>COPY app.go .</p>
<p>RUN go get -d -v github.com/go-sql-driver/mysql \</p>
<p> &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . </p>
<p>编写 Dockerfile.copy 文件</p>
<p>FROM alpine:latest</p>
<p>RUN apk –no-cache add ca-certificates</p>
<p>WORKDIR /root/</p>
<p>COPY app .</p>
<p>CMD [“./app”] </p>
<p>新建 build.sh</p>
<p>#!/bin/sh</p>
<p>echo Building go/helloworld:build</p>
<p>docker build -t go/helloworld:build . -f Dockerfile.build</p>
<p>docker create –name extract go/helloworld:build</p>
<p>docker cp extract:/go/src/github.com/go/helloworld/app ./app</p>
<p>docker rm -f extract</p>
<p>echo Building go/helloworld:2</p>
<p>docker build –no-cache -t go/helloworld:2 . -f Dockerfile.copy</p>
<p>rm ./app </p>
<p>现在运行脚本即可构建镜像</p>
<p>chmod +x build.sh</p>
<p>./build.sh </p>
<p>对比两种方式生成的镜像大小</p>
<p>docker image ls </p>
<p>REPOSITORY   TAG  IMAGE ID    CREATED     SIZE</p>
<p>go/helloworld  2   f7cf3465432c  22 seconds ago 6.47MB</p>
<p>go/helloworld  1   f55d3e16affc  2 minutes ago  295MB</p>
<h3 id="4-7-2-使用多阶段构建"><a href="#4-7-2-使用多阶段构建" class="headerlink" title="4.7.2. 使用多阶段构建"></a>4.7.2. 使用多阶段构建</h3><p>为解决以上问题，Docker v17.05 开始支持多阶段构建 (multistage builds)。使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个 Dockerfile：</p>
<p>例如</p>
<p>编写 Dockerfile 文件</p>
<p>FROM golang:1.9-alpine as builder</p>
<p>RUN apk –no-cache add git</p>
<p>WORKDIR /go/src/github.com/go/helloworld/</p>
<p>RUN go get -d -v github.com/go-sql-driver/mysql</p>
<p>COPY app.go .</p>
<p>RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</p>
<p>FROM alpine:latest as prod</p>
<p>RUN apk –no-cache add ca-certificates</p>
<p>WORKDIR /root/</p>
<p>COPY –from=0 /go/src/github.com/go/helloworld/app .</p>
<p>CMD [“./app”]  </p>
<p>构建镜像</p>
<p>docker build -t go/helloworld:3 .  </p>
<p>对比三个镜像大小</p>
<p>docker image ls </p>
<p>REPOSITORY    TAG  IMAGE ID     CREATED      SIZE</p>
<p>go/helloworld   3   d6911ed9c846   7 seconds ago   6.47MB</p>
<p>go/helloworld   2   f7cf3465432c   22 seconds ago   6.47MB</p>
<p>go/helloworld   1   f55d3e16affc   2 minutes ago   295MB</p>
<p>很明显使用多阶段构建的镜像体积小，同时也完美解决了上边提到的问题。</p>
<p><strong>只构建某一阶段的镜像</strong></p>
<p>我们可以使用 as 来为某一阶段命名，例如</p>
<p>FROM golang:1.9-alpine as builder </p>
<p>例如当我们只想构建 builder 阶段的镜像时，我们可以在使用 docker build 命令时加上 –target 参数即可</p>
<p>docker build –target builder -t username/imagename:tag . </p>
<p><strong>构建时从其他镜像复制文件</strong></p>
<p>上面例子中我们使用 COPY –from=0 /go/src/github.com/go/helloworld/app . 从上一阶段的镜像中复制文件，我们也可以复制任意镜像中的文件。</p>
<p>COPY –from=nginx:latest /etc/nginx/nginx.conf /nginx.conf </p>
<h2 id="4-8-其他制作镜像方式"><a href="#4-8-其他制作镜像方式" class="headerlink" title="4.8.   其他制作镜像方式"></a>4.8.   其他制作镜像方式</h2><p>除了标准的使用 Dockerfile 生成镜像的方法外，由于各种特殊需求和历史原因，还提供了一些其它方法用以生成镜像。</p>
<h3 id="4-8-1-从-rootfs-压缩包导入"><a href="#4-8-1-从-rootfs-压缩包导入" class="headerlink" title="4.8.1. 从 rootfs 压缩包导入"></a>4.8.1. 从 rootfs 压缩包导入</h3><p>格式：docker import [选项] &lt;文件&gt;|<URL>|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</p>
<p>压缩包可以是本地文件、远程 Web 文件，甚至是从标准输入中得到。压缩包将会在镜像 / 目录展开，并直接作为镜像第一层提交。</p>
<p>比如我们想要创建一个 OpenVZ 的 Ubuntu 14.04 模板的镜像：</p>
<p>docker import \</p>
<p>  <a href="http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz" target="_blank" rel="noopener">http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz</a> \</p>
<p>  openvz/ubuntu:14.04</p>
<p>这条命令自动下载了 ubuntu-14.04-x86_64-minimal.tar.gz 文件，并且作为根文件系统展开导入，并保存为镜像 openvz/ubuntu:14.04。</p>
<p>导入成功后，我们可以用 docker image ls 看到这个导入的镜像：</p>
<p>docker image ls openvz/ubuntu</p>
<p>REPOSITORY     TAG         IMAGE ID      CREATED       SIZE</p>
<p>openvz/ubuntu    14.04        f477a6e18e98    55 seconds ago   214.9 MB</p>
<p>如果我们查看其历史的话，会看到描述中有导入的文件链接：</p>
<p>docker history openvz/ubuntu:14.04</p>
<p>IMAGE        CREATED       CREATED BY     SIZE        COMMENT</p>
<p>f477a6e18e98    About a minute ago            214.9 MB      Imported from <a href="http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz" target="_blank" rel="noopener">http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz</a></p>
<h3 id="4-8-2-docker-save-和-docker-load"><a href="#4-8-2-docker-save-和-docker-load" class="headerlink" title="4.8.2. docker save 和 docker load"></a>4.8.2. docker save 和 docker load</h3><p>Docker 还提供了 docker load 和 docker save 命令，用以将镜像保存为一个 tar 文件，然后传输到另一个位置上，再加载进来。这是在没有 Docker Registry 时的做法，现在已经不推荐，镜像迁移应该直接使用 Docker Registry，无论是直接使用 Docker Hub 还是使用内网私有 Registry 都可以。</p>
<p><strong>保存镜像</strong></p>
<p>使用 docker save 命令可以将镜像保存为归档文件。</p>
<p>比如我们希望保存这个 alpine 镜像。</p>
<p>docker image ls alpine</p>
<p>REPOSITORY     TAG         IMAGE ID      CREATED       SIZE</p>
<p>alpine       latest       baa5d63471ea    5 weeks ago     4.803 MB</p>
<p>保存镜像的命令为：</p>
<p>docker save alpine | gzip &gt; alpine-latest.tar.gz</p>
<p>然后我们将 alpine-latest.tar.gz 文件复制到了到了另一个机器上，可以用下面这个命令加载镜像：</p>
<p>docker load -i alpine-latest.tar.gz</p>
<p>Loaded image: alpine:latest</p>
<p>如果我们结合这两个命令以及 ssh 甚至 pv 的话，利用 Linux 强大的管道，我们可以写一个命令完成从一个机器将镜像迁移到另一个机器，并且带进度条的功能：</p>
<p>docker save &lt;镜像名&gt; | bzip2 | pv | ssh &lt;用户名&gt;@&lt;主机名&gt; ‘cat | docker load’</p>
<h2 id="4-9-镜像的实现原理"><a href="#4-9-镜像的实现原理" class="headerlink" title="4.9.   镜像的实现原理"></a>4.9.   镜像的实现原理</h2><p>Docker 镜像是怎么实现增量的修改和维护的？</p>
<p>每个镜像都由很多层次构成，Docker 使用 Union FS 将这些不同的层结合到一个镜像中去。</p>
<p>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不变的基础上允许用户在其上进行一些写操作。</p>
<p>Docker 在 AUFS 上构建的容器也是利用了类似的原理。</p>
<h1 id="5-docker-容器"><a href="#5-docker-容器" class="headerlink" title="5. docker 容器"></a>5. docker 容器</h1><p>容器是 Docker 又一核心概念。</p>
<p>简单的说，容器是独立运行的一个或一组应用，以及它们的运行态环境。对应的，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用。</p>
<p>本章将具体介绍如何来管理一个容器，包括创建、启动和停止等。</p>
<h2 id="5-1-启动容器"><a href="#5-1-启动容器" class="headerlink" title="5.1.   启动容器"></a>5.1.   启动容器</h2><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</p>
<p>因为 Docker 的容器实在太轻量级了，很多时候用户都是随时删除和新创建容器。</p>
<h3 id="5-1-1-新建并启动"><a href="#5-1-1-新建并启动" class="headerlink" title="5.1.1. 新建并启动"></a>5.1.1. 新建并启动</h3><p>所需要的命令主要为 docker run。</p>
<p>例如，下面的命令输出一个 “Hello World”，之后终止容器。</p>
<p>docker run ubuntu:14.04 /bin/echo ‘Hello world’</p>
<p>这跟在本地直接执行 /bin/echo ‘hello world’ 几乎感觉不出任何区别。</p>
<p>下面的命令则启动一个 bash 终端，允许用户进行交互。</p>
<p>docker run -t -i ubuntu:14.04 /bin/bash</p>
<p>其中，-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开。</p>
<p>在交互模式下，用户可以通过所创建的终端来输入命令，例如</p>
<p>root@af8bae53bdd3:/# pwd</p>
<p>/</p>
<p>root@af8bae53bdd3:/# ls</p>
<p>bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var</p>
<p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p>
<p>l 检查本地是否存在指定的镜像，不存在就从公有仓库下载</p>
<p>l 利用镜像创建并启动一个容器</p>
<p>l 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</p>
<p>l 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</p>
<p>l 从地址池配置一个 ip 地址给容器</p>
<p>l 执行用户指定的应用程序</p>
<p>l 执行完毕后容器被终止</p>
<h3 id="5-1-2-启动已终止容器"><a href="#5-1-2-启动已终止容器" class="headerlink" title="5.1.2. 启动已终止容器"></a>5.1.2. 启动已终止容器</h3><p>可以利用 docker container start 命令，直接将一个已经终止的容器启动运行。</p>
<p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的。除此之外，并没有其它的资源。可以在伪终端中利用 ps 或 top 来查看进程信息。</p>
<p>root@ba267838cc1b:/# ps</p>
<p> PID TTY     TIME CMD</p>
<p>  1 ?    00:00:00 bash</p>
<p>  11 ?    00:00:00 ps</p>
<p>可见，容器中仅运行了指定的 bash 应用。这种特点使得 Docker 对资源的利用率极高，是货真价实的轻量级虚拟化。</p>
<h2 id="5-2-守护状态运行"><a href="#5-2-守护状态运行" class="headerlink" title="5.2.   守护状态运行"></a>5.2.   守护状态运行</h2><p>更多的时候，需要让 Docker 在后台运行而不是直接把执行命令的结果输出在当前宿主机下。此时，可以通过添加 -d 参数来实现。</p>
<p>下面举两个例子来说明一下。</p>
<p>如果不使用 -d 参数运行容器。</p>
<p>docker run ubuntu:17.10 /bin/sh -c “while true; do echo hello world; sleep 1; done”</p>
<p>hello world</p>
<p>hello world</p>
<p>hello world</p>
<p>hello world</p>
<p>容器会把输出的结果 (STDOUT) 打印到宿主机上面</p>
<p>如果使用了 -d 参数运行容器。</p>
<p>docker run -d ubuntu:17.10 /bin/sh -c “while true; do echo hello world; sleep 1; done”</p>
<p>此时容器会在后台运行并不会把输出的结果 (STDOUT) 打印到宿主机上面(输出结果可以用 docker logs 查看)。</p>
<p>注： 容器是否会长久运行，是和 docker run 指定的命令有关，和 -d 参数无关。</p>
<p>使用 -d 参数启动后会返回一个唯一的 id，也可以通过 docker container ls 命令来查看容器信息。</p>
<p>docker container ls</p>
<p>要获取容器的输出信息，可以通过 docker container logs 命令。</p>
<p>docker container logs [container ID or NAMES]</p>
<h2 id="5-3-终止容器"><a href="#5-3-终止容器" class="headerlink" title="5.3.   终止容器"></a>5.3.   终止容器</h2><p>可以使用 docker container stop 来终止一个运行中的容器。</p>
<p>此外，当 Docker 容器中指定的应用终结时，容器也自动终止。</p>
<p>例如对于上一章节中只启动了一个终端的容器，用户通过 exit 命令或 Ctrl+d 来退出终端时，所创建的容器立刻终止。</p>
<p>终止状态的容器可以用 docker container ls -a 命令看到。例如</p>
<p>docker container ls -a</p>
<p>处于终止状态的容器，可以通过 docker container start 命令来重新启动。</p>
<p>此外，docker container restart 命令会将一个运行态的容器终止，然后再重新启动它。</p>
<h2 id="5-4-进入容器"><a href="#5-4-进入容器" class="headerlink" title="5.4.   进入容器"></a>5.4.   进入容器</h2><p>在使用 -d 参数时，容器启动后会进入后台。</p>
<p>某些时候需要进入容器进行操作，包括使用 docker attach 命令或 docker exec 命令，推荐大家使用 docker exec 命令，原因会在下面说明。</p>
<h3 id="5-4-1-attach-命令"><a href="#5-4-1-attach-命令" class="headerlink" title="5.4.1. attach 命令"></a>5.4.1. attach 命令</h3><p>docker attach 是 Docker 自带的命令。下面示例如何使用该命令。</p>
<p>docker run -dit ubuntu</p>
<p>docker run -dit Ubuntu</p>
<p>docker attach 243c</p>
<p>注意： 如果从这个 stdin 中 exit，会导致容器的停止。</p>
<h3 id="5-4-2-exec-命令"><a href="#5-4-2-exec-命令" class="headerlink" title="5.4.2. exec 命令"></a>5.4.2. exec 命令</h3><p><strong>-i -t</strong> <strong>参数</strong></p>
<p>docker exec 后边可以跟多个参数，这里主要说明 -i -t 参数。</p>
<p>只用 -i 参数时，由于没有分配伪终端，界面没有我们熟悉的 Linux 命令提示符，但命令执行结果仍然可以返回。</p>
<p>当 -i -t 参数一起使用时，则可以看到我们熟悉的 Linux 命令提示符。</p>
<p>docker run -dit ubuntu</p>
<p>docker container ls</p>
<p>docker exec -it 69d1 bash</p>
<p>docker exec -i 69d1 bash</p>
<p>如果从这个 stdin 中 exit，不会导致容器的停止。这就是为什么推荐大家使用 docker exec 的原因。</p>
<p>更多参数说明请使用 docker exec –help 查看。</p>
<h2 id="5-5-导出和导入容器"><a href="#5-5-导出和导入容器" class="headerlink" title="5.5.   导出和导入容器"></a>5.5.   导出和导入容器</h2><h3 id="5-5-1-导出容器"><a href="#5-5-1-导出容器" class="headerlink" title="5.5.1. 导出容器"></a>5.5.1. 导出容器</h3><p>如果要导出本地某个容器，可以使用 docker export 命令。</p>
<p>docker container ls -a</p>
<p>CONTAINER ID    IMAGE        COMMAND       CREATED       STATUS          PORTS        NAMES</p>
<p>7691a814370e    ubuntu:14.04    “/bin/bash”     36 hours ago    Exited (0) 21 hours ago            test</p>
<p>docker export 7691a814370e &gt; ubuntu.tar</p>
<p>这样将导出容器快照到本地文件。</p>
<h3 id="5-5-2-导入容器快照"><a href="#5-5-2-导入容器快照" class="headerlink" title="5.5.2. 导入容器快照"></a>5.5.2. 导入容器快照</h3><p>可以使用 docker import 从容器快照文件中再导入为镜像，例如</p>
<p>cat ubuntu.tar | docker import - test/ubuntu:v1.0</p>
<p>docker image ls</p>
<p>REPOSITORY     TAG         IMAGE ID      CREATED       VIRTUAL SIZE</p>
<p>test/ubuntu     v1.0        9d37a6082e97    About a minute ago  171.3 MB</p>
<p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p>
<p>docker import <a href="http://example.com/exampleimage.tgz" target="_blank" rel="noopener">http://example.com/exampleimage.tgz</a> example/imagerepo</p>
<p>注：用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者的区别在于容器快照文件将丢弃所有的历史记录和元数据信息（即仅保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大。此外，从容器快照文件导入时可以重新指定标签等元数据信息。</p>
<h2 id="5-6-删除容器"><a href="#5-6-删除容器" class="headerlink" title="5.6.   删除容器"></a>5.6.   删除容器</h2><p>可以使用 docker container rm 来删除一个处于终止状态的容器。例如</p>
<p>docker container rm trusting_newton</p>
<p>如果要删除一个运行中的容器，可以添加 -f 参数。Docker 会发送 SIGKILL 信号给容器。</p>
<p>#清理所有处于终止状态的容器</p>
<p>用 docker container ls -a 命令可以查看所有已经创建的包括终止状态的容器，如果数量太多要一个个删除可能会很麻烦，用下面的命令可以清理掉所有处于终止状态的容器。</p>
<p>docker container prune</p>
<h1 id="6-docker-仓库"><a href="#6-docker-仓库" class="headerlink" title="6. docker 仓库"></a>6. docker 仓库</h1><p>仓库（Repository）是集中存放镜像的地方。</p>
<p>一个容易混淆的概念是注册服务器（Registry）。实际上注册服务器是管理仓库的具体服务器，每个服务器上可以有多个仓库，而每个仓库下面有多个镜像。从这方面来说，仓库可以被认为是一个具体的项目或目录。例如对于仓库地址 dl.dockerpool.com/ubuntu 来说，dl.dockerpool.com 是注册服务器地址，ubuntu 是仓库名。</p>
<p>大部分时候，并不需要严格区分这两者的概念。</p>
<h2 id="6-1-docker-hub"><a href="#6-1-docker-hub" class="headerlink" title="6.1.   docker hub"></a>6.1.   docker hub</h2><h3 id="6-1-1-注册"><a href="#6-1-1-注册" class="headerlink" title="6.1.1. 注册"></a>6.1.1. 注册</h3><p>你可以在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">https://hub.docker.com/</a> 免费注册一个 Docker 账号。</p>
<h3 id="6-1-2-登录"><a href="#6-1-2-登录" class="headerlink" title="6.1.2. 登录"></a>6.1.2. 登录</h3><p>可以通过执行 docker login 命令交互式的输入用户名及密码来完成在命令行界面登录 Docker Hub。</p>
<p>你可以通过 docker logout 退出登录。</p>
<h3 id="6-1-3-拉取镜像"><a href="#6-1-3-拉取镜像" class="headerlink" title="6.1.3. 拉取镜像"></a>6.1.3. 拉取镜像</h3><p>你可以通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将它下载到本地。</p>
<p>例如以 centos 为关键词进行搜索：</p>
<p>docker search centos</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135244.jpg" alt="img"></p>
<p>可以看到返回了很多包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建、是否自动创建。</p>
<p>官方的镜像说明是官方项目组创建和维护的，automated 资源允许用户验证镜像的来源和内容。</p>
<p>根据是否是官方提供，可将镜像资源分为两类。</p>
<p>一种是类似 centos 这样的镜像，被称为基础镜像或根镜像。这些基础镜像由 Docker 公司创建、验证、支持、提供。这样的镜像往往使用单个单词作为名字。</p>
<p>还有一种类型，比如 tianon/centos 镜像，它是由 Docker 的用户创建并维护的，往往带有用户名称前缀。可以通过前缀 username/ 来指定使用某个用户提供的镜像，比如 tianon 用户。</p>
<p>另外，在查找的时候通过 –filter=stars=N 参数可以指定仅显示收藏数量为 N 以上的镜像。</p>
<p>下载官方 centos 镜像到本地。</p>
<p>docker pull centos</p>
<p>Pulling repository centos</p>
<p>0b443ba03958: Download complete</p>
<p>539c0211cd76: Download complete</p>
<p>511136ea3c5a: Download complete</p>
<p>7064731afe90: Download complete</p>
<h3 id="6-1-4-推送镜像"><a href="#6-1-4-推送镜像" class="headerlink" title="6.1.4. 推送镜像"></a>6.1.4. 推送镜像</h3><p>用户也可以在登录后通过 docker push 命令来将自己的镜像推送到 Docker Hub。</p>
<p>以下命令中的 username 请替换为你的 Docker 账号用户名</p>
<p>docker tag ubuntu:17.10 username/ubuntu:17.10</p>
<p>docker image ls</p>
<p>docker push username/ubuntu:17.10</p>
<p>docker search username</p>
<h3 id="6-1-5-自动创建"><a href="#6-1-5-自动创建" class="headerlink" title="6.1.5. 自动创建"></a>6.1.5. 自动创建</h3><p>自动创建（Automated Builds）功能对于需要经常升级镜像内程序来说，十分方便。</p>
<p>有时候，用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。</p>
<p>而自动创建允许用户通过 Docker Hub 指定跟踪一个目标网站（目前支持 GitHub 或 BitBucket）上的项目，一旦项目发生新的提交或者创建新的标签（tag），Docker Hub 会自动构建镜像并推送到 Docker Hub 中。</p>
<p>要配置自动创建，包括如下的步骤：</p>
<p>创建并登录 Docker Hub，以及目标网站；</p>
<p>在目标网站中连接帐户到 Docker Hub；</p>
<p>在 Docker Hub 中 配置一个自动创建；</p>
<p>选取一个目标网站中的项目（需要含 Dockerfile）和分支；</p>
<p>指定 Dockerfile 的位置，并提交创建。</p>
<p>之后，可以在 Docker Hub 的 自动创建页面 中跟踪每次创建的状态。</p>
<h2 id="6-2-docker-私有仓库"><a href="#6-2-docker-私有仓库" class="headerlink" title="6.2.   docker 私有仓库"></a>6.2.   docker 私有仓库</h2><p>有时候使用 Docker Hub 这样的公共仓库可能不方便，用户可以创建一个本地仓库供私人使用。</p>
<p>本节介绍如何使用本地仓库。</p>
<p><a href="https://docs.docker.com/registry/spec/api/" target="_blank" rel="noopener">docker-registry</a> 是官方提供的工具，可以用于构建私有的镜像仓库。本文内容基于 <a href="https://github.com/docker/distribution" target="_blank" rel="noopener">docker-registry v2.x</a> 版本。</p>
<h3 id="6-2-1-安装运行-docker-registry"><a href="#6-2-1-安装运行-docker-registry" class="headerlink" title="6.2.1. 安装运行 docker-registry"></a>6.2.1. 安装运行 docker-registry</h3><p>你可以通过获取官方 registry 镜像来运行。</p>
<p>docker run -d -p 5000:5000 –restart=always –name registry registry</p>
<p>这将使用官方的 registry 镜像来启动私有仓库。默认情况下，仓库会被创建在容器的 /var/lib/registry 目录下。你可以通过 -v 参数来将镜像文件存放在本地的指定路径。例如下面的例子将上传的镜像放到本地的 /opt/data/registry 目录。</p>
<p>docker run -d \</p>
<p>  -p 5000:5000 \</p>
<p>  -v /opt/data/registry:/var/lib/registry \</p>
<p>  registry</p>
<h3 id="6-2-2-在私有仓库上传、搜索、下载镜像"><a href="#6-2-2-在私有仓库上传、搜索、下载镜像" class="headerlink" title="6.2.2. 在私有仓库上传、搜索、下载镜像"></a>6.2.2. 在私有仓库上传、搜索、下载镜像</h3><p>创建好私有仓库之后，就可以使用 docker tag 来标记一个镜像，然后推送它到仓库。例如私有仓库地址为 127.0.0.1:5000。</p>
<p>先在本机查看已有的镜像。</p>
<p>docker image ls</p>
<p>REPOSITORY      TAG    IMAGE ID      CREATED       VIRTUAL SIZE</p>
<p>ubuntu         latest   ba5877dc9bec    6 weeks ago     192.7 MB</p>
<p>使用 docker tag 将 ubuntu:latest 这个镜像标记为 127.0.0.1:5000/ubuntu:latest。</p>
<p>格式为 docker tag IMAGE[:TAG] [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]。</p>
<p>docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest</p>
<p>docker image ls</p>
<p>REPOSITORY    TAG    IMAGE ID      CREATED       VIRTUAL SIZE</p>
<p>ubuntu      latest    ba5877dc9bec    6 weeks ago     192.7 MB</p>
<p>127.0.0.1:5000/ubuntu:latest  latest  ba5877dc9bec    6 weeks ago     192.7 MB</p>
<p>使用 docker push 上传标记的镜像。</p>
<p>docker push 127.0.0.1:5000/ubuntu:latest</p>
<p>用 curl 查看仓库中的镜像。</p>
<p>curl 127.0.0.1:5000/v2/_catalog</p>
<p>{“repositories”:[“ubuntu”]}</p>
<p>这里可以看到 {“repositories”:[“ubuntu”]}，表明镜像已经被成功上传了。</p>
<p>先删除已有镜像，再尝试从私有仓库中下载这个镜像。</p>
<p>docker image rm 127.0.0.1:5000/ubuntu:latest</p>
<p>docker pull 127.0.0.1:5000/ubuntu:latestdocker image ls</p>
<p>docker image ls</p>
<h3 id="6-2-3-注意事项"><a href="#6-2-3-注意事项" class="headerlink" title="6.2.3. 注意事项"></a>6.2.3. 注意事项</h3><p>如果你不想使用 127.0.0.1:5000 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。你就得把例如 192.168.199.100:5000 这样的内网地址作为私有仓库地址，这时你会发现无法成功推送镜像。</p>
<p>这是因为 Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 HTTPS 访问的私有仓库。</p>
<h4 id="6-2-3-1-Ubuntu-14-04-Debian-7-Wheezy"><a href="#6-2-3-1-Ubuntu-14-04-Debian-7-Wheezy" class="headerlink" title="6.2.3.1.   Ubuntu 14.04, Debian 7 Wheezy"></a>6.2.3.1.   Ubuntu 14.04, Debian 7 Wheezy</h4><p>对于使用 upstart 的系统而言，编辑 /etc/default/docker 文件，在其中的 DOCKER_OPTS 中增加如下内容：</p>
<p>DOCKER_OPTS=”–registry-mirror=<a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a> –insecure-registries=192.168.199.100:5000”</p>
<p>重新启动服务。</p>
<p>sudo service docker restart</p>
<h4 id="6-2-3-2-Ubuntu-16-04-Debian-8-centos-7"><a href="#6-2-3-2-Ubuntu-16-04-Debian-8-centos-7" class="headerlink" title="6.2.3.2.   Ubuntu 16.04+, Debian 8+, centos 7"></a>6.2.3.2.   Ubuntu 16.04+, Debian 8+, centos 7</h4><p>对于使用 systemd 的系统，请在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）</p>
<p>{</p>
<p> “registry-mirrors”: [</p>
<p>  “<a href="https://registry.docker-cn.com&quot;" target="_blank" rel="noopener">https://registry.docker-cn.com&quot;</a></p>
<p> ],</p>
<p> “insecure-registries”: [</p>
<p>  “192.168.199.100:5000”</p>
<p> ]</p>
<p>}</p>
<p>注意：该文件必须符合 json 规范，否则 Docker 将不能启动。</p>
<h3 id="6-2-4-其他"><a href="#6-2-4-其他" class="headerlink" title="6.2.4. 其他"></a>6.2.4. 其他</h3><p>对于 Docker for Windows 、 Docker for Mac 在设置中编辑 daemon.json 增加和上边一样的字符串即可。</p>
<h3 id="6-2-5-docker-registry-配置证书"><a href="#6-2-5-docker-registry-配置证书" class="headerlink" title="6.2.5. docker registry 配置证书"></a>6.2.5. docker registry 配置证书</h3><p>上一节我们搭建了一个具有基础功能的私有仓库，本小节我们来使用 Docker Compose 搭建一个拥有权限认证、TLS 的私有仓库。</p>
<p>新建一个文件夹，以下步骤均在该文件夹中进行。</p>
<h4 id="6-2-5-1-准备站点证书"><a href="#6-2-5-1-准备站点证书" class="headerlink" title="6.2.5.1.   准备站点证书"></a>6.2.5.1.   准备站点证书</h4><p>如果你拥有一个域名，国内各大云服务商均提供免费的站点证书。你也可以使用 openssl 自行签发证书。</p>
<p>这里假设我们将要搭建的私有仓库地址为 docker.domain.com，下面我们介绍使用 openssl 自行签发 docker.domain.com 的站点 SSL 证书。</p>
<p>第一步创建 CA 私钥。</p>
<p>openssl genrsa -out “root-ca.key” 4096</p>
<p>第二步利用私钥创建 CA 根证书请求文件。</p>
<p>openssl req \</p>
<p>​     -new -key “root-ca.key” \</p>
<p>​     -out “root-ca.csr” -sha256 \</p>
<p>​     -subj ‘/C=CN/ST=Shanxi/L=Datong/O=Your Company Name/CN=Your Company Name Docker Registry CA’</p>
<p>以上命令中 -subj 参数里的 /C 表示国家，如 CN；/ST 表示省；/L 表示城市或者地区；/O 表示组织名；/CN 通用名称。</p>
<p>第三步配置 CA 根证书，新建 root-ca.cnf。</p>
<p>[root_ca]</p>
<p>basicConstraints = critical,CA:TRUE,pathlen:1</p>
<p>keyUsage = critical, nonRepudiation, cRLSign, keyCertSign</p>
<p>subjectKeyIdentifier=hash</p>
<p>第四步签发根证书。</p>
<p>openssl x509 -req -days 3650 -in “root-ca.csr” \</p>
<p>​        -signkey “root-ca.key” -sha256 -out “root-ca.crt” \</p>
<p>​        -extfile “root-ca.cnf” -extensions \</p>
<p>​        root_ca</p>
<p>第五步生成站点 SSL 私钥。</p>
<p>openssl genrsa -out “docker.domain.com.key” 4096</p>
<p>第六步使用私钥生成证书请求文件。</p>
<p>openssl req -new -key “docker.domain.com.key” -out “site.csr” -sha256 \</p>
<p>​     -subj ‘/C=CN/ST=Shanxi/L=Datong/O=Your Company Name/CN=docker.domain.com’</p>
<p>第七步配置证书，新建 site.cnf 文件。</p>
<p>[server]</p>
<p>authorityKeyIdentifier=keyid,issuer</p>
<p>basicConstraints = critical,CA:FALSE</p>
<p>extendedKeyUsage=serverAuth</p>
<p>keyUsage = critical, digitalSignature, keyEncipherment</p>
<p>subjectAltName = DNS:docker.domain.com, IP:127.0.0.1</p>
<p>subjectKeyIdentifier=hash</p>
<p>第八步签署站点 SSL 证书。</p>
<p>openssl x509 -req -days 750 -in “site.csr” -sha256 \</p>
<p>  -CA “root-ca.crt” -CAkey “root-ca.key” -CAcreateserial \</p>
<p>  -out “docker.domain.com.crt” -extfile “site.cnf” -extensions server</p>
<p>这样已经拥有了 docker.domain.com 的网站 SSL 私钥 docker.domain.com.key 和 SSL 证书 docker.domain.com.crt。</p>
<p>新建 ssl 文件夹并将 docker.domain.com.key docker.domain.com.crt 这两个文件移入，删除其他文件。</p>
<h4 id="6-2-5-2-配置私有仓库"><a href="#6-2-5-2-配置私有仓库" class="headerlink" title="6.2.5.2.   配置私有仓库"></a>6.2.5.2.   配置私有仓库</h4><p>私有仓库默认的配置文件位于 /etc/docker/registry/config.yml，我们先在本地编辑 config.yml，之后挂载到容器中。</p>
<p>version: 0.1</p>
<p>log:</p>
<p> accesslog:</p>
<p>  disabled: true</p>
<p> level: debug</p>
<p> formatter: text</p>
<p> fields:</p>
<p>  service: registry</p>
<p>  environment: staging</p>
<p>storage:</p>
<p> delete:</p>
<p>  enabled: true</p>
<p> cache:</p>
<p>  blobdescriptor: inmemory</p>
<p> filesystem:</p>
<p>  rootdirectory: /var/lib/registry</p>
<p>auth:</p>
<p> htpasswd:</p>
<p>  realm: basic-realm</p>
<p>  path: /etc/docker/registry/auth/nginx.htpasswd</p>
<p>http:</p>
<p> addr: :443</p>
<p> host: <a href="https://docker.domain.com" target="_blank" rel="noopener">https://docker.domain.com</a></p>
<p> headers:</p>
<p>  X-Content-Type-Options: [nosniff]</p>
<p> http2:</p>
<p>  disabled: false</p>
<p> tls:</p>
<p>  certificate: /etc/docker/registry/ssl/docker.domain.com.crt</p>
<p>  key: /etc/docker/registry/ssl/docker.domain.com.key</p>
<p>health:</p>
<p> storagedriver:</p>
<p>  enabled: true</p>
<p>  interval: 10s</p>
<p>threshold: 3</p>
<h4 id="6-2-5-3-生成-http-认证文件"><a href="#6-2-5-3-生成-http-认证文件" class="headerlink" title="6.2.5.3.   生成 http 认证文件"></a>6.2.5.3.   生成 http 认证文件</h4><p>mkdir auth</p>
<p>docker run –rm \</p>
<p>  –entrypoint htpasswd \</p>
<p>  registry \</p>
<p>  -Bbn username password &gt; auth/nginx.htpasswd</p>
<p>将上面的 username password 替换为你自己的用户名和密码。</p>
<h4 id="6-2-5-4-编辑-docker-compose-yml"><a href="#6-2-5-4-编辑-docker-compose-yml" class="headerlink" title="6.2.5.4.   编辑 docker-compose.yml"></a>6.2.5.4.   编辑 docker-compose.yml</h4><p>version: ‘3’</p>
<p>services:</p>
<p> registry:</p>
<p>  image: registry</p>
<p>  ports:</p>
<p>   - “443:443”</p>
<p>  volumes:</p>
<p>   - ./:/etc/docker/registry</p>
<p>   - registry-data:/var/lib/registry</p>
<p>volumes:</p>
<p> registry-data:</p>
<h4 id="6-2-5-5-修改-hosts"><a href="#6-2-5-5-修改-hosts" class="headerlink" title="6.2.5.5.   修改 hosts"></a>6.2.5.5.   修改 hosts</h4><p>编辑 /etc/hosts</p>
<p>docker.domain.com 127.0.0.1</p>
<h4 id="6-2-5-6-启动"><a href="#6-2-5-6-启动" class="headerlink" title="6.2.5.6.   启动"></a>6.2.5.6.   启动</h4><p>docker-compose up -d</p>
<p>这样我们就搭建好了一个具有权限认证、TLS 的私有仓库，接下来我们测试其功能是否正常。</p>
<h4 id="6-2-5-7-测试私有仓库功能"><a href="#6-2-5-7-测试私有仓库功能" class="headerlink" title="6.2.5.7.   测试私有仓库功能"></a>6.2.5.7.   测试私有仓库功能</h4><p>登录到私有仓库。</p>
<p>docker login docker.domain.com</p>
<p>尝试推送、拉取镜像。</p>
<p>docker pull ubuntu:17.10</p>
<p>docker tag ubuntu:17.10 docker.domain.com/username/ubuntu:17.10</p>
<p>docker push docker.domain.com/username/ubuntu:17.10</p>
<p>docker image rm docker.domain.com/username/ubuntu:17.10</p>
<p>docker pull docker.domain.com/username/ubuntu:17.10</p>
<p>如果我们退出登录，尝试推送镜像。</p>
<p>docker logout docker.domain.com</p>
<p>docker push docker.domain.com/username/ubuntu:17.10</p>
<p>发现会提示没有登录，不能将镜像推送到私有仓库中。</p>
<h4 id="6-2-5-8-注意事项"><a href="#6-2-5-8-注意事项" class="headerlink" title="6.2.5.8.   注意事项"></a>6.2.5.8.   注意事项</h4><p>如果你本机占用了 443 端口，你可以配置 <a href="https://docs.docker.com/registry/recipes/nginx/" target="_blank" rel="noopener">Nginx 代理</a>，这里不再赘述。</p>
<h2 id="6-3-docker-企业级仓库-Harbor"><a href="#6-3-docker-企业级仓库-Harbor" class="headerlink" title="6.3.   docker 企业级仓库 Harbor"></a>6.3.   docker 企业级仓库 Harbor</h2><p>在学完 compose 后再来安装部署。</p>
<h1 id="7-docker-数据管理"><a href="#7-docker-数据管理" class="headerlink" title="7. docker 数据管理"></a>7. docker 数据管理</h1><p>这一章介绍如何在 Docker 内部以及容器之间管理数据，在容器中管理数据主要有两种方式：</p>
<p>l 数据卷（Volumes）</p>
<p>l 挂载主机目录 (Bind mounts)</p>
<h2 id="7-1-docker-数据卷"><a href="#7-1-docker-数据卷" class="headerlink" title="7.1.   docker 数据卷"></a>7.1.   docker 数据卷</h2><p>数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<p>l 数据卷 可以在容器之间共享和重用</p>
<p>l 对 数据卷 的修改会立马生效</p>
<p>l 对 数据卷 的更新，不会影响镜像</p>
<p>l 数据卷 默认会一直存在，即使容器被删除</p>
<p>注意：数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会隐藏掉，能显示看的是挂载的 数据卷。</p>
<h3 id="7-1-1-选择-v-还是-–mount-参数"><a href="#7-1-1-选择-v-还是-–mount-参数" class="headerlink" title="7.1.1. 选择 -v 还是 -–mount 参数"></a>7.1.1. 选择 -v 还是 -–mount 参数</h3><p>Docker 新用户应该选择 –mount 参数，经验丰富的 Docker 使用者对 -v 或者 –volume 已经很熟悉了，但是推荐使用 –mount 参数。</p>
<h3 id="7-1-2-创建一个数据卷"><a href="#7-1-2-创建一个数据卷" class="headerlink" title="7.1.2. 创建一个数据卷"></a>7.1.2. 创建一个数据卷</h3><p>docker volume create my-vol</p>
<p>查看所有的 数据卷</p>
<p>docker volume ls</p>
<p>在主机里使用以下命令可以查看指定 数据卷 的信息</p>
<p>docker volume inspect my-vol</p>
<p> [</p>
<p>  {</p>
<p>​    “Driver”: “local”,</p>
<p>​    “Labels”: {},</p>
<p>​    “Mountpoint”: “/var/lib/docker/volumes/my-vol/_data”,</p>
<p>​    “Name”: “my-vol”,</p>
<p>​    “Options”: {},</p>
<p>​    “Scope”: “local”</p>
<p>  }</p>
<p>]</p>
<h3 id="7-1-3-启动一个挂载数据卷的容器"><a href="#7-1-3-启动一个挂载数据卷的容器" class="headerlink" title="7.1.3. 启动一个挂载数据卷的容器"></a>7.1.3. 启动一个挂载数据卷的容器</h3><p>在用 docker run 命令的时候，使用 –mount 标记来将 数据卷 挂载到容器里。在一次 docker run 中可以挂载多个 数据卷。</p>
<p>下面创建一个名为 web 的容器，并加载一个 数据卷 到容器的 /webapp 目录。</p>
<p>docker run -d -P \</p>
<p>  –name web \</p>
<p>  # -v my-vol:/wepapp \</p>
<p>  –mount source=my-vol,target=/webapp \</p>
<p>  training/webapp \</p>
<p>  python app.py</p>
<h3 id="7-1-4-查看数据卷的具体信息"><a href="#7-1-4-查看数据卷的具体信息" class="headerlink" title="7.1.4. 查看数据卷的具体信息"></a>7.1.4. 查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 web 容器的信息</p>
<p>docker inspect web</p>
<p>数据卷 信息在 “Mounts” Key 下面</p>
<p>“Mounts”: [</p>
<p>  {</p>
<p>​    “Type”: “volume”,</p>
<p>​    “Name”: “my-vol”,</p>
<p>​    “Source”: “/var/lib/docker/volumes/my-vol/_data”,</p>
<p>​    “Destination”: “/app”,</p>
<p>​    “Driver”: “local”,</p>
<p>​    “Mode”: “”,</p>
<p>​    “RW”: true,</p>
<p>​    “Propagation”: “”</p>
<p>  }</p>
<p>],</p>
<h3 id="7-1-5-删除数据卷"><a href="#7-1-5-删除数据卷" class="headerlink" title="7.1.5. 删除数据卷"></a>7.1.5. 删除数据卷</h3><p>docker volume rm my-vol</p>
<p>数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷，并且也不存在垃圾回收这样的机制来处理没有任何容器引用的 数据卷。如果需要在删除容器的同时移除数据卷。可以在删除容器的时候使用 docker rm -v 这个命令。</p>
<p>无主的数据卷可能会占据很多空间，要清理请使用以下命令</p>
<p>docker volume prune</p>
<h2 id="7-2-监听主机目录"><a href="#7-2-监听主机目录" class="headerlink" title="7.2.   监听主机目录"></a>7.2.   监听主机目录</h2><h3 id="7-2-1-v-还是-–mount-参数"><a href="#7-2-1-v-还是-–mount-参数" class="headerlink" title="7.2.1. -v 还是 -–mount 参数"></a>7.2.1. -v 还是 -–mount 参数</h3><p>Docker 新用户应该选择 –mount 参数，经验丰富的 Docker 使用者对 -v 或者 –volume 已经很熟悉了，但是推荐使用 –mount 参数。</p>
<h3 id="7-2-2-挂载一个主机目录作为数据卷"><a href="#7-2-2-挂载一个主机目录作为数据卷" class="headerlink" title="7.2.2. 挂载一个主机目录作为数据卷"></a>7.2.2. 挂载一个主机目录作为数据卷</h3><p>使用 –mount 标记可以指定挂载一个本地主机的目录到容器中去。</p>
<p>docker run -d -P \</p>
<p>  –name web \</p>
<p>  # -v /src/webapp:/opt/webapp \</p>
<p>  –mount type=bind,source=/src/webapp,target=/opt/webapp \</p>
<p>  training/webapp \</p>
<p>  python app.py</p>
<p>上面的命令加载主机的 /src/webapp 目录到容器的 /opt/webapp目录。这个功能在进行测试的时候十分方便，比如用户可以放置一些程序到本地目录中，来查看容器是否正常工作。本地目录的路径必须是绝对路径，以前使用 -v 参数时如果本地目录不存在 Docker 会自动为你创建一个文件夹，现在使用 –mount 参数时如果本地目录不存在，Docker 会报错。</p>
<p>Docker 挂载主机目录的默认权限是 读写，用户也可以通过增加 readonly 指定为 只读。</p>
<p>docker run -d -P \</p>
<p>  –name web \</p>
<p>  # -v /src/webapp:/opt/webapp:ro \</p>
<p>  –mount type=bind,source=/src/webapp,target=/opt/webapp,readonly \</p>
<p>  training/webapp \</p>
<p>  python app.py</p>
<p>加了 readonly 之后，就挂载为 只读 了。如果你在容器内 /opt/webapp 目录新建文件，会显示如下错误</p>
<p>/opt/webapp # touch new.txt</p>
<p>touch: new.txt: Read-only file system</p>
<h3 id="7-2-3-查看数据卷的具体信息"><a href="#7-2-3-查看数据卷的具体信息" class="headerlink" title="7.2.3. 查看数据卷的具体信息"></a>7.2.3. 查看数据卷的具体信息</h3><p>在主机里使用以下命令可以查看 web 容器的信息</p>
<p>docker inspect web</p>
<p>挂载主机目录 的配置信息在 “Mounts” Key 下面</p>
<p>“Mounts”: [</p>
<p>  {</p>
<p>​    “Type”: “bind”,</p>
<p>​    “Source”: “/src/webapp”,</p>
<p>​    “Destination”: “/opt/webapp”,</p>
<p>​    “Mode”: “”,</p>
<p>​    “RW”: true,</p>
<p>​    “Propagation”: “rprivate”</p>
<p>  }</p>
<p>],</p>
<h3 id="7-2-4-挂载一个本地主机文件作为数据卷"><a href="#7-2-4-挂载一个本地主机文件作为数据卷" class="headerlink" title="7.2.4. 挂载一个本地主机文件作为数据卷"></a>7.2.4. 挂载一个本地主机文件作为数据卷</h3><p>–mount 标记也可以从主机挂载单个文件到容器中</p>
<p>docker run –rm -it \</p>
<p>  # -v $HOME/.bash_history:/root/.bash_history \</p>
<p>  –mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history \</p>
<p>  ubuntu:17.10 \</p>
<p>  bash</p>
<p>root@2affd44b4667:/# history</p>
<p>1 ls</p>
<p>2 diskutil list </p>
<p>这样就可以记录在容器输入过的命令了。</p>
<h1 id="8-docker-网络配置"><a href="#8-docker-网络配置" class="headerlink" title="8. docker 网络配置"></a>8. docker 网络配置</h1><p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务</p>
<h2 id="8-1-Docker-外部访问容器"><a href="#8-1-Docker-外部访问容器" class="headerlink" title="8.1.   Docker 外部访问容器"></a>8.1.   Docker 外部访问容器</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些应用，可以通过 -P 或 -p 参数来指定端口映射。</p>
<p>当使用 -P 标记时，Docker 会随机映射一个 49000~49900 的端口到内部容器开放的网络端口。</p>
<p>使用 docker container ls 可以看到，本地主机的 49155 被映射到了容器的 5000 端口。此时访问本机的 49155 端口即可访问容器内 web 应用提供的界面。</p>
<p>docker run -d -P training/webapp python app.py</p>
<p>docker container ls -l</p>
<p>同样的，可以通过 docker logs 命令来查看应用的信息。</p>
<p>docker logs -f nostalgic_morse</p>
<p>* Running on <a href="http://0.0.0.0:5000/" target="_blank" rel="noopener">http://0.0.0.0:5000/</a></p>
<p>10.0.2.2 - - [23/May/2014 20:16:31] “GET / HTTP/1.1” 200 -</p>
<p>10.0.2.2 - - [23/May/2014 20:16:31] “GET /favicon.ico HTTP/1.1” 404 -</p>
<p>-p 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort。</p>
<h3 id="8-1-1-映射所有接口地址"><a href="#8-1-1-映射所有接口地址" class="headerlink" title="8.1.1. 映射所有接口地址"></a>8.1.1. 映射所有接口地址</h3><p>使用 hostPort:containerPort 格式本地的 5000 端口映射到容器的 5000 端口，可以执行</p>
<p>docker run -d -p 5000:5000 training/webapp python app.py</p>
<p>此时默认会绑定本地所有接口上的所有地址。</p>
<h3 id="8-1-2-映射到指定地址的指定端口"><a href="#8-1-2-映射到指定地址的指定端口" class="headerlink" title="8.1.2. 映射到指定地址的指定端口"></a>8.1.2. 映射到指定地址的指定端口</h3><p>可以使用 ip:hostPort:containerPort 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</p>
<p>docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</p>
<h3 id="8-1-3-映射到指定地址的任意端口"><a href="#8-1-3-映射到指定地址的任意端口" class="headerlink" title="8.1.3. 映射到指定地址的任意端口"></a>8.1.3. 映射到指定地址的任意端口</h3><p>使用 ip::containerPort 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</p>
<p>docker run -d -p 127.0.0.1::5000 training/webapp python app.py</p>
<p>还可以使用 udp 标记来指定 udp 端口</p>
<p>docker run -d -p 127.0.0.1:5000:5000/udp training/webapp python app.py</p>
<h3 id="8-1-4-查看映射端口配置"><a href="#8-1-4-查看映射端口配置" class="headerlink" title="8.1.4. 查看映射端口配置"></a>8.1.4. 查看映射端口配置</h3><p>使用 docker port 来查看当前映射的端口配置，也可以查看到绑定的地址</p>
<p>docker port nostalgic_morse 5000</p>
<p>注意：</p>
<p>l 容器有自己的内部网络和 ip 地址（使用 docker inspect 可以获取所有的变量，Docker 还可以有一个可变的网络配置。）</p>
<p>l -p 标记可以多次使用来绑定多个端口</p>
<p>例如</p>
<p>docker run -d \</p>
<p>  -p 5000:5000 \</p>
<p>  -p 3000:80 \</p>
<p>  training/webapp \</p>
<p>  python app.py</p>
<h2 id="8-2-Docker-容器互连"><a href="#8-2-Docker-容器互连" class="headerlink" title="8.2.   Docker 容器互连"></a>8.2.   Docker 容器互连</h2><p>如果你之前有 Docker 使用经验，你可能已经习惯了使用 –link 参数来使容器互联。</p>
<p>随着 Docker 网络的完善，强烈建议大家将容器加入自定义的 Docker 网络来连接多个容器，而不是使用 –link 参数。</p>
<h3 id="8-2-1-新建网络"><a href="#8-2-1-新建网络" class="headerlink" title="8.2.1. 新建网络"></a>8.2.1. 新建网络</h3><p>下面先创建一个新的 Docker 网络。</p>
<p>docker network create -d bridge my-net</p>
<p>-d 参数指定 Docker 网络类型，有 bridge overlay。其中 overlay 网络类型用于 Swarm mode，在本小节中你可以忽略它。</p>
<h3 id="8-2-2-连接容器"><a href="#8-2-2-连接容器" class="headerlink" title="8.2.2. 连接容器"></a>8.2.2. 连接容器</h3><p>运行一个容器并连接到新建的 my-net 网络</p>
<p>docker run -it –rm –name busybox1 –network my-net busybox sh</p>
<p>打开新的终端，再运行一个容器并加入到 my-net 网络</p>
<p>docker run -it –rm –name busybox2 –network my-net busybox sh</p>
<p>再打开一个新的终端查看容器信息</p>
<p>docker container ls</p>
<p>CONTAINER ID  IMAGE  COMMAND  CREATED   STATUS   PORTS        NAMES</p>
<p>b47060aca56b busybox  “sh”    11 minutes ago   Up 11 minutes  busybox2           </p>
<p>8720575823ec  busybox  “sh”    16 minutes ago   Up 16 minutes   busybox1           </p>
<p>下面通过 ping 来证明 busybox1 容器和 busybox2 容器建立了互联关系。</p>
<p>在 busybox1 容器输入以下命令</p>
<p>/ # ping busybox2</p>
<p>PING busybox2 (172.19.0.3): 56 data bytes</p>
<p>64 bytes from 172.19.0.3: seq=0 ttl=64 time=0.072 ms</p>
<p>64 bytes from 172.19.0.3: seq=1 ttl=64 time=0.118 ms</p>
<p>用 ping 来测试连接 busybox2 容器，它会解析成 172.19.0.3。</p>
<p>同理在 busybox2 容器执行 ping busybox1，也会成功连接到。</p>
<p>/ # ping busybox1</p>
<p>PING busybox1 (172.19.0.2): 56 data bytes</p>
<p>64 bytes from 172.19.0.2: seq=0 ttl=64 time=0.064 ms</p>
<p>64 bytes from 172.19.0.2: seq=1 ttl=64 time=0.143 ms</p>
<p>这样，busybox1 容器和 busybox2 容器建立了互联关系。</p>
<h3 id="8-2-3-Docker-Compose"><a href="#8-2-3-Docker-Compose" class="headerlink" title="8.2.3. Docker Compose"></a>8.2.3. Docker Compose</h3><p>如果你有多个容器之间需要互相连接，推荐使用 Docker Compose。</p>
<h2 id="8-3-Docker-配置-DNS"><a href="#8-3-Docker-配置-DNS" class="headerlink" title="8.3.   Docker 配置 DNS"></a>8.3.   Docker 配置 DNS</h2><p>如何自定义配置容器的主机名和 DNS 呢？秘诀就是 Docker 利用虚拟文件来挂载容器的 3 个相关配置文件。</p>
<p>在容器中使用 mount 命令可以看到挂载信息：</p>
<p>mount</p>
<p>/dev/disk/by-uuid/1fec…ebdf on /etc/hostname type ext4 …</p>
<p>/dev/disk/by-uuid/1fec…ebdf on /etc/hosts type ext4 …</p>
<p>tmpfs on /etc/resolv.conf type tmpfs …</p>
<p>这种机制可以让宿主主机 DNS 信息发生更新后，所有 Docker 容器的 DNS 配置通过 /etc/resolv.conf 文件立刻得到更新。</p>
<p>配置全部容器的 DNS ，也可以在 /etc/docker/daemon.json 文件中增加以下内容来设置。</p>
<p>{</p>
<p> “dns” : [</p>
<p>  “114.114.114.114”,</p>
<p>  “8.8.8.8”</p>
<p> ]</p>
<p>}</p>
<p>这样每次启动的容器 DNS 自动配置为 114.114.114.114 和 8.8.8.8。使用以下命令来证明其已经生效。</p>
<p>docker run -it –rm ubuntu:17.10 cat etc/resolv.conf</p>
<p>nameserver 114.114.114.114</p>
<p>nameserver 8.8.8.8</p>
<p>如果用户想要手动指定容器的配置，可以在使用 docker run 命令启动容器时加入如下参数：</p>
<p>-h HOSTNAME 或者 –hostname=HOSTNAME 设定容器的主机名，它会被写到容器内的 /etc/hostname 和 /etc/hosts。但它在容器外部看不到，既不会在 docker container ls 中显示，也不会在其他的容器的 /etc/hosts 看到。</p>
<p>–dns=IP_ADDRESS 添加 DNS 服务器到容器的 /etc/resolv.conf 中，让容器用这个服务器来解析所有不在 /etc/hosts 中的主机名。</p>
<p>–dns-search=DOMAIN 设定容器的搜索域，当设定搜索域为 .example.com 时，在搜索一个名为 host 的主机时，DNS 不仅搜索 host，还会搜索 host.example.com。</p>
<p>注意：如果在容器启动时没有指定最后两个参数，Docker 会默认用主机上的 /etc/resolv.conf 来配置容器。</p>
<h1 id="9-docker-高级网络配置"><a href="#9-docker-高级网络配置" class="headerlink" title="9. docker 高级网络配置"></a>9. docker 高级网络配置</h1><p>注意：本章属于 Docker 高级配置，如果您是初学者，您可以暂时跳过本章节，直接学习 Docker Compose 一节。</p>
<p>本章将介绍 Docker 的一些高级网络配置和选项。</p>
<p>当 Docker 启动时，会自动在主机上创建一个 docker0 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>
<p>同时，Docker 随机分配一个本地未占用的私有网段（在 RFC1918 中定义）中的一个地址给 docker0 接口。比如典型的 172.17.42.1，掩码为 255.255.0.0。此后启动的容器内的网口也会自动分配一个同一网段（172.17.0.0/16）的地址。</p>
<p>当创建一个 Docker 容器的时候，同时会创建了一对 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 eth0；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头（例如 vethAQI2QT）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p>
<p>Docker 网络</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406134944.gif" alt="Docker 网络"></p>
<p>接下来的部分将介绍在一些场景中，Docker 所有的网络定制配置。以及通过 Linux 命令来调整、补充、甚至替换 Docker 默认的网络配置。</p>
<h2 id="9-1-快速配置指南"><a href="#9-1-快速配置指南" class="headerlink" title="9.1.   快速配置指南"></a>9.1.   快速配置指南</h2><p>下面是一个跟 Docker 网络相关的命令列表。</p>
<p>其中有些命令选项只有在 Docker 服务启动的时候才能配置，而且不能马上生效。</p>
<p>l -b BRIDGE 或 –bridge=BRIDGE 指定容器挂载的网桥</p>
<p>l –bip=CIDR 定制 docker0 的掩码</p>
<p>l -H SOCKET… 或 –host=SOCKET… Docker 服务端接收命令的通道</p>
<p>l –icc=true|false 是否支持容器之间进行通信</p>
<p>l –ip-forward=true|false 请看下文容器之间的通信</p>
<p>l –iptables=true|false 是否允许 Docker 添加 iptables 规则</p>
<p>l –mtu=BYTES 容器网络中的 MTU</p>
<p>下面2个命令选项既可以在启动服务时指定，也可以在启动容器时指定。在 Docker 服务启动的时候指定则会成为默认值，后面执行 docker run 时可以覆盖设置的默认值。</p>
<p>l –dns=IP_ADDRESS… 使用指定的DNS服务器</p>
<p>l –dns-search=DOMAIN… 指定DNS搜索域</p>
<p>最后这些选项只有在 docker run 执行时使用，因为它是针对容器的特性内容。</p>
<p>l -h HOSTNAME 或 –hostname=HOSTNAME 配置容器主机名</p>
<p>l –link=CONTAINER_NAME:ALIAS 添加到另一个容器的连接</p>
<p>l –net=bridge|none|container:NAME_or_ID|host 配置容器的桥接模式</p>
<p>l -p SPEC 或 –publish=SPEC 映射容器端口到宿主主机</p>
<p>l -P or –publish-all=true|false 映射容器所有端口到宿主主机</p>
<h2 id="9-2-容器访问控制"><a href="#9-2-容器访问控制" class="headerlink" title="9.2.   容器访问控制"></a>9.2.   容器访问控制</h2><p>容器的访问控制，主要通过 Linux 上的 iptables 防火墙来进行管理和实现。iptables 是 Linux 上默认的防火墙软件，在大部分发行版中都自带。</p>
<h3 id="9-2-1-容器访问外部网络"><a href="#9-2-1-容器访问外部网络" class="headerlink" title="9.2.1. 容器访问外部网络"></a>9.2.1. 容器访问外部网络</h3><p>容器要想访问外部网络，需要本地系统的转发支持。在Linux 系统中，检查转发是否打开。</p>
<p>sysctl net.ipv4.ip_forward</p>
<p>net.ipv4.ip_forward = 1</p>
<p>如果为 0，说明没有开启转发，则需要手动打开。</p>
<p>sysctl -w net.ipv4.ip_forward=1</p>
<p>如果在启动 Docker 服务的时候设定 –ip-forward=true, Docker 就会自动设定系统的 ip_forward 参数为 1。</p>
<h3 id="9-2-2-容器之间访问"><a href="#9-2-2-容器之间访问" class="headerlink" title="9.2.2. 容器之间访问"></a>9.2.2. 容器之间访问</h3><p>容器之间相互访问，需要两方面的支持。</p>
<p>l 容器的网络拓扑是否已经互联。默认情况下，所有容器都会被连接到 docker0 网桥上。</p>
<p>l 本地系统的防火墙软件 – iptables 是否允许通过。</p>
<p><strong>访问所有端口</strong></p>
<p>当启动 Docker 服务时候，默认会添加一条转发策略到 iptables 的 FORWARD 链上。策略为通过（ACCEPT）还是禁止（DROP）取决于配置–icc=true（缺省值）还是 –icc=false。当然，如果手动指定 –iptables=false 则不会添加 iptables 规则。</p>
<p>可见，默认情况下，不同容器之间是允许网络互通的。如果为了安全考虑，可以在 /etc/default/docker 文件中配置 DOCKER_OPTS=–icc=false 来禁止它。</p>
<p><strong>访问指定端口</strong></p>
<p>在通过 -icc=false 关闭网络访问后，还可以通过 –link=CONTAINER_NAME:ALIAS 选项来访问容器的开放端口。</p>
<p>例如，在启动 Docker 服务时，可以同时使用 icc=false –iptables=true 参数来关闭允许相互的网络访问，并让 Docker 可以修改系统中的 iptables 规则。</p>
<p>此时，系统中的 iptables 规则可能是类似</p>
<p>sudo iptables -nL</p>
<p>…</p>
<p>Chain FORWARD (policy ACCEPT)</p>
<p>target   prot opt source        destination</p>
<p>DROP    all – 0.0.0.0/0      0.0.0.0/0</p>
<p>…</p>
<p>之后，启动容器（docker run）时使用 –link=CONTAINER_NAME:ALIAS 选项。Docker 会在 iptable 中为 两个容器分别添加一条 ACCEPT 规则，允许相互访问开放的端口（取决于 Dockerfile 中的 EXPOSE 指令）。</p>
<p>当添加了 –link=CONTAINER_NAME:ALIAS 选项后，添加了 iptables 规则。</p>
<p>sudo iptables -nL</p>
<p>Chain FORWARD (policy ACCEPT)</p>
<p>target   prot opt source        destination</p>
<p>ACCEPT   tcp – 172.17.0.2      172.17.0.3      tcp spt:80</p>
<p>ACCEPT   tcp – 172.17.0.3      172.17.0.2      tcp dpt:80</p>
<p>DROP    all – 0.0.0.0/0      0.0.0.0/0</p>
<p>注意：–link=CONTAINER_NAME:ALIAS 中的 CONTAINER_NAME 目前必须是 Docker 分配的名字，或使用 –name 参数指定的名字。主机名则不会被识别。</p>
<h2 id="9-3-端口映射实现"><a href="#9-3-端口映射实现" class="headerlink" title="9.3.   端口映射实现"></a>9.3.   端口映射实现</h2><p>默认情况下，容器可以主动访问到外部网络的连接，但是外部网络无法访问到容器。</p>
<h3 id="9-3-1-容器访问外部实现"><a href="#9-3-1-容器访问外部实现" class="headerlink" title="9.3.1. 容器访问外部实现"></a>9.3.1. 容器访问外部实现</h3><p>容器所有到外部网络的连接，源地址都会被 NAT 成本地系统的 IP 地址。这是使用 iptables 的源地址伪装操作实现的。</p>
<p>查看主机的 NAT 规则。</p>
<p>sudo iptables -t nat -nL</p>
<p>Chain POSTROUTING (policy ACCEPT)</p>
<p>target   prot opt source        destination</p>
<p>MASQUERADE all – 172.17.0.0/16    !172.17.0.0/16</p>
<p>…</p>
<p>其中，上述规则将所有源地址在 172.17.0.0/16 网段，目标地址为其他网段（外部网络）的流量动态伪装为从系统网卡发出。MASQUERADE 跟传统 SNAT 的好处是它能动态从网卡获取地址。</p>
<h3 id="9-3-2-外部访问容器实现"><a href="#9-3-2-外部访问容器实现" class="headerlink" title="9.3.2. 外部访问容器实现"></a>9.3.2. 外部访问容器实现</h3><p>容器允许外部访问，可以在 docker run 时候通过 -p 或 -P 参数来启用。</p>
<p>不管用那种办法，其实也是在本地的 iptable 的 nat 表中添加相应的规则。</p>
<p>使用 -P 时：</p>
<p>iptables -t nat -nL</p>
<p>Chain DOCKER (2 references)</p>
<p>target   prot opt source        destination</p>
<p>DNAT    tcp – 0.0.0.0/0      0.0.0.0/0      tcp dpt:49153 to:172.17.0.2:80</p>
<p>使用 -p 80:80 时：</p>
<p>iptables -t nat -nL</p>
<p>Chain DOCKER (2 references)</p>
<p>target   prot opt source        destination</p>
<p>DNAT    tcp – 0.0.0.0/0      0.0.0.0/0      tcp dpt:80 to:172.17.0.2:80</p>
<p>注意：</p>
<p>l 这里的规则映射了 0.0.0.0，意味着将接受主机来自所有接口的流量。用户可以通过 -p IP:host_port:container_port 或 -p IP::port 来指定允许访问容器的主机上的 IP、接口等，以制定更严格的规则。</p>
<p>l 如果希望永久绑定到某个固定的 IP 地址，可以在 Docker 配置文件 /etc/docker/daemon.json 中添加如下内容。</p>
<p>{</p>
<p> “ip”: “0.0.0.0”</p>
<p>}</p>
<h2 id="9-4-配置-docker0-网桥"><a href="#9-4-配置-docker0-网桥" class="headerlink" title="9.4.   配置 docker0 网桥"></a>9.4.   配置 docker0 网桥</h2><p>Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），它在内核层连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到同一个物理网络。</p>
<p>Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码，让主机和容器之间可以通过网桥相互通信，它还给出了 MTU（接口允许接收的最大传输单元），通常是 1500 Bytes，或宿主主机网络路由上支持的默认值。这些值都可以在服务启动的时候进行配置。</p>
<p>l –bip=CIDR IP 地址加掩码格式，例如 192.168.1.5/24</p>
<p>l –mtu=BYTES 覆盖默认的 Docker mtu 配置</p>
<p>也可以在配置文件中配置 DOCKER_OPTS，然后重启服务。</p>
<p>由于目前 Docker 网桥是 Linux 网桥，用户可以使用 brctl show 来查看网桥和端口连接信息。</p>
<p>sudo brctl show</p>
<p>bridge name  bridge id  STP enabled     interfaces</p>
<p>docker0   8000.3a1d7362b4ee no veth65f9  vethdda6</p>
<p>*注：brctl 命令在 Debian、Ubuntu 中可以使用 sudo apt-get install bridge-utils 来安装。</p>
<p>每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 eth0 端口。使用本地主机上 docker0 接口的 IP 作为所有容器的默认网关。</p>
<p>sudo docker run -i -t –rm base /bin/bash</p>
<p>ip addr show eth0</p>
<p>24: eth0: &lt;BROADCAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</p>
<p>  link/ether 32:6f:e0:35:57:91 brd ff:ff:ff:ff:ff:ff</p>
<p>  inet 172.17.0.3/16 scope global eth0</p>
<p>​    valid_lft forever preferred_lft forever</p>
<p>  inet6 fe80::306f:e0ff:fe35:5791/64 scope link</p>
<p>​    valid_lft forever preferred_lft forever</p>
<p>ip route</p>
<p>default via 172.17.42.1 dev eth0</p>
<p>172.17.0.0/16 dev eth0 proto kernel scope link src 172.17.0.3</p>
<h2 id="9-5-自定义网桥"><a href="#9-5-自定义网桥" class="headerlink" title="9.5.   自定义网桥"></a>9.5.   自定义网桥</h2><p>除了默认的 docker0 网桥，用户也可以指定网桥来连接各个容器。</p>
<p>在启动 Docker 服务的时候，使用 -b BRIDGE或–bridge=BRIDGE 来指定使用的网桥。</p>
<p>如果服务已经运行，那需要先停止服务，并删除旧的网桥。</p>
<p>sudo systemctl stop docker</p>
<p>sudo ip link set dev docker0 down</p>
<p>sudo brctl delbr docker0</p>
<p>然后创建一个网桥 bridge0。</p>
<p>sudo brctl addbr bridge0</p>
<p>sudo ip addr add 192.168.5.1/24 dev bridge0</p>
<p>sudo ip link set dev bridge0 up</p>
<p>查看确认网桥创建并启动。</p>
<p>ip addr show bridge0</p>
<p>4: bridge0: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state UP group default</p>
<p>  link/ether 66:38:d0:0d:76:18 brd ff:ff:ff:ff:ff:ff</p>
<p>  inet 192.168.5.1/24 scope global bridge0</p>
<p>​    valid_lft forever preferred_lft forever</p>
<p>在 Docker 配置文件 /etc/docker/daemon.json 中添加如下内容，即可将 Docker 默认桥接到创建的网桥上。</p>
<p>{</p>
<p> “bridge”: “bridge0”</p>
<p>}</p>
<p>启动 Docker 服务。</p>
<p>新建一个容器，可以看到它已经桥接到了 bridge0 上。</p>
<p>可以继续用 brctl show 命令查看桥接的信息。另外，在容器中可以使用 ip addr 和 ip route 命令来查看 IP 地址配置和路由信息。</p>
<h2 id="9-6-工具和示例"><a href="#9-6-工具和示例" class="headerlink" title="9.6.   工具和示例"></a>9.6.   工具和示例</h2><p>在介绍自定义网络拓扑之前，你可能会对一些外部工具和例子感兴趣：</p>
<h3 id="9-6-1-pipework"><a href="#9-6-1-pipework" class="headerlink" title="9.6.1. pipework"></a>9.6.1. pipework</h3><p>Jérôme Petazzoni 编写了一个叫 <a href="https://github.com/jpetazzo/pipework" target="_blank" rel="noopener">pipework</a> 的 shell 脚本，可以帮助用户在比较复杂的场景中完成容器的连接。</p>
<h3 id="9-6-2-playground"><a href="#9-6-2-playground" class="headerlink" title="9.6.2. playground"></a>9.6.2. playground</h3><p>Brandon Rhodes 创建了一个提供完整的 Docker 容器网络拓扑管理的 <a href="https://github.com/brandon-rhodes/fopnp/tree/m/playground" target="_blank" rel="noopener">Python库</a>，包括路由、NAT 防火墙；以及一些提供 HTTP, SMTP, POP, IMAP, Telnet, SSH, FTP 的服务器。</p>
<h2 id="9-7-编辑网络配置文件"><a href="#9-7-编辑网络配置文件" class="headerlink" title="9.7.   编辑网络配置文件"></a>9.7.   编辑网络配置文件</h2><p>Docker 1.2.0 开始支持在运行中的容器里编辑 /etc/hosts, /etc/hostname 和 /etc/resolv.conf 文件。</p>
<p>但是这些修改是临时的，只在运行的容器中保留，容器终止或重启后并不会被保存下来。也不会被 docker commit 提交。</p>
<h2 id="9-8-实例：创建一个点到点连接"><a href="#9-8-实例：创建一个点到点连接" class="headerlink" title="9.8.   实例：创建一个点到点连接"></a>9.8.   实例：创建一个点到点连接</h2><p>默认情况下，Docker 会将所有容器连接到由 docker0 提供的虚拟子网中。</p>
<p>用户有时候需要两个容器之间可以直连通信，而不用通过主机网桥进行桥接。</p>
<p>解决办法很简单：创建一对 peer 接口，分别放到两个容器中，配置成点到点链路类型即可。</p>
<p>首先启动 2 个容器：</p>
<p>docker run -i -t –rm –net=none base /bin/bash</p>
<p>docker run -i -t –rm –net=none base /bin/bash</p>
<p>找到进程号，然后创建网络命名空间的跟踪文件。</p>
<p>docker inspect -f ‘{.State.Pid}’ 1f1f4c1f931a</p>
<p>2989</p>
<p>docker inspect -f ‘{.State.Pid}’ 12e343489d2f</p>
<p>3004</p>
<p>sudo mkdir -p /var/run/netns</p>
<p>sudo ln -s /proc/2989/ns/net /var/run/netns/2989</p>
<p>sudo ln -s /proc/3004/ns/net /var/run/netns/3004</p>
<p>创建一对 peer 接口，然后配置路由</p>
<p>sudo ip link add A type veth peer name B</p>
<p>sudo ip link set A netns 2989</p>
<p>sudo ip netns exec 2989 ip addr add 10.1.1.1/32 dev A</p>
<p>sudo ip netns exec 2989 ip link set A up</p>
<p>sudo ip netns exec 2989 ip route add 10.1.1.2/32 dev A</p>
<p>sudo ip link set B netns 3004</p>
<p>sudo ip netns exec 3004 ip addr add 10.1.1.2/32 dev B</p>
<p>sudo ip netns exec 3004 ip link set B up</p>
<p>sudo ip netns exec 3004 ip route add 10.1.1.1/32 dev B</p>
<p>现在这 2 个容器就可以相互 ping 通，并成功建立连接。点到点链路不需要子网和子网掩码。</p>
<p>此外，也可以不指定 –net=none 来创建点到点链路。这样容器还可以通过原先的网络来通信。</p>
<p>利用类似的办法，可以创建一个只跟主机通信的容器。但是一般情况下，更推荐使用 –icc=false 来关闭容器之间的通信。</p>
<h1 id="10-docker-三剑客-compose"><a href="#10-docker-三剑客-compose" class="headerlink" title="10.  docker 三剑客 compose"></a>10.  docker 三剑客 compose</h1><p>Docker Compose 是 Docker 官方编排（Orchestration）项目之一，负责快速的部署分布式应用。</p>
<h2 id="10-1-docker-compose-简介"><a href="#10-1-docker-compose-简介" class="headerlink" title="10.1. docker compose 简介"></a>10.1. docker compose 简介</h2><p>Compose 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 OpenStack 中的 Heat 十分类似。</p>
<p>其代码目前在 <a href="https://github.com/docker/compose" target="_blank" rel="noopener">https://github.com/docker/compose</a> 上开源。</p>
<p>Compose 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>
<p>通过第一部分中的介绍，我们知道使用一个 Dockerfile 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>
<p>Compose 恰好满足了这样的需求。它允许用户通过一个单独的 docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p>Compose 中有两个重要的概念：</p>
<p>l 服务 (service)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</p>
<p>l 项目 (project)：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</p>
<p>Compose 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>
<p>Compose 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 Compose 来进行编排管理。</p>
<h2 id="10-2-docker-compose-安装和卸载"><a href="#10-2-docker-compose-安装和卸载" class="headerlink" title="10.2. docker compose 安装和卸载"></a>10.2. docker compose 安装和卸载</h2><p>Compose 支持 Linux、macOS、Windows 10 三大平台。</p>
<p>Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。</p>
<p>前两种方式是传统方式，适合本地环境下安装使用；最后一种方式则不破坏系统环境，更适合云计算场景。</p>
<p>Docker for Mac 、Docker for Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用。</p>
<p>docker-compose –version</p>
<p>Linux 系统请使用以下介绍的方法安装。</p>
<h3 id="10-2-1-二进制包"><a href="#10-2-1-二进制包" class="headerlink" title="10.2.1.    二进制包"></a>10.2.1.    二进制包</h3><p>在 Linux 上的也安装十分简单，从 官方 <a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener">GitHub Release</a> 处直接下载编译好的二进制文件即可。</p>
<p>例如，在 Linux 64 位系统上直接下载对应的二进制包。</p>
<p>sudo curl -L <a href="https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname" target="_blank" rel="noopener">https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname</a> -s<code>-</code>uname -m` &gt; /usr/local/bin/docker-compose</p>
<p>sudo chmod +x /usr/local/bin/docker-compose</p>
<h3 id="10-2-2-PIP-安装"><a href="#10-2-2-PIP-安装" class="headerlink" title="10.2.2.    PIP 安装"></a>10.2.2.    PIP 安装</h3><p>注： x86_64 架构的 Linux 建议按照上边的方法下载二进制包进行安装，如果您计算机的架构是 ARM (例如，树莓派)，再使用 pip 安装。</p>
<p>这种方式是将 Compose 当作一个 Python 应用来从 pip 源中安装。</p>
<p>执行安装命令：</p>
<p>sudo pip install -U docker-compose</p>
<p>可以看到类似如下输出，说明安装成功。</p>
<p>Collecting docker-compose</p>
<p> Downloading docker-compose-1.17.1.tar.gz (149kB): 149kB downloaded</p>
<p>…</p>
<p>Successfully installed docker-compose cached-property requests texttable websocket-client docker-py dockerpty six enum34 backports.ssl-match-hostname ipaddress</p>
<h3 id="10-2-3-bash-补全命令"><a href="#10-2-3-bash-补全命令" class="headerlink" title="10.2.3.    bash 补全命令"></a>10.2.3.    bash 补全命令</h3><p>curl -L <a href="https://raw.githubusercontent.com/docker/compose/1.8.0/contrib/completion/bash/docker-compose" target="_blank" rel="noopener">https://raw.githubusercontent.com/docker/compose/1.8.0/contrib/completion/bash/docker-compose</a> &gt; /etc/bash_completion.d/docker-compose</p>
<h3 id="10-2-4-容器中执行"><a href="#10-2-4-容器中执行" class="headerlink" title="10.2.4.    容器中执行"></a>10.2.4.    容器中执行</h3><p>Compose 既然是一个 Python 应用，自然也可以直接用容器来执行它。</p>
<p>curl -L <a href="https://github.com/docker/compose/releases/download/1.8.0/run.sh" target="_blank" rel="noopener">https://github.com/docker/compose/releases/download/1.8.0/run.sh</a> &gt; /usr/local/bin/docker-compose</p>
<p>chmod +x /usr/local/bin/docker-compose</p>
<p>实际上，查看下载的 run.sh 脚本内容，如下</p>
<p>set -e</p>
<p>VERSION=”1.8.0”</p>
<p>IMAGE=”docker/compose:$VERSION”</p>
<p># Setup options for connecting to docker host</p>
<p>if [ -z “$DOCKER_HOST” ]; then</p>
<p>  DOCKER_HOST=”/var/run/docker.sock”</p>
<p>fi</p>
<p>if [ -S “$DOCKER_HOST” ]; then</p>
<p>  DOCKER_ADDR=”-v $DOCKER_HOST:$DOCKER_HOST -e DOCKER_HOST”</p>
<p>else</p>
<p>  DOCKER_ADDR=”-e DOCKER_HOST -e DOCKER_TLS_VERIFY -e DOCKER_CERT_PATH”</p>
<p>fi</p>
<p># Setup volume mounts for compose config and context</p>
<p>if [ “$(pwd)” != ‘/‘ ]; then</p>
<p>  VOLUMES=”-v $(pwd):$(pwd)”</p>
<p>fi</p>
<p>if [ -n “$COMPOSE_FILE” ]; then</p>
<p>  compose_dir=$(dirname $COMPOSE_FILE)</p>
<p>fi</p>
<p># TODO: also check –file argument</p>
<p>if [ -n “$compose_dir” ]; then</p>
<p>  VOLUMES=”$VOLUMES -v $compose_dir:$compose_dir”</p>
<p>fi</p>
<p>if [ -n “$HOME” ]; then</p>
<p>  VOLUMES=”$VOLUMES -v $HOME:$HOME -v $HOME:/root” # mount $HOME in /root to share docker.config</p>
<p>fi</p>
<p># Only allocate tty if we detect one</p>
<p>if [ -t 1 ]; then</p>
<p>  DOCKER_RUN_OPTIONS=”-t”</p>
<p>fi</p>
<p>if [ -t 0 ]; then</p>
<p>  DOCKER_RUN_OPTIONS=”$DOCKER_RUN_OPTIONS -i”</p>
<p>fi</p>
<p>exec docker run –rm $DOCKER_RUN_OPTIONS $DOCKER_ADDR $COMPOSE_OPTIONS $VOLUMES -w “$(pwd)” $IMAGE “$@”</p>
<p>可以看到，它其实是下载了 docker/compose 镜像并运行。</p>
<h3 id="10-2-5-卸载"><a href="#10-2-5-卸载" class="headerlink" title="10.2.5.    卸载"></a>10.2.5.    卸载</h3><p>如果是二进制包方式安装的，删除二进制文件即可。</p>
<p>sudo rm /usr/local/bin/docker-compose</p>
<p>如果是通过 pip 安装的，则执行如下命令即可删除。</p>
<p>sudo pip uninstall docker-compose</p>
<h2 id="10-3-docker-compose-使用"><a href="#10-3-docker-compose-使用" class="headerlink" title="10.3. docker compose 使用"></a>10.3. docker compose 使用</h2><h3 id="10-3-1-术语"><a href="#10-3-1-术语" class="headerlink" title="10.3.1.    术语"></a>10.3.1.    术语</h3><p>首先介绍几个术语。</p>
<p>l 服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。</p>
<p>l 项目 (project)：由一组关联的应用容器组成的一个完整业务单元。</p>
<p>可见，一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理。</p>
<h3 id="10-3-2-场景"><a href="#10-3-2-场景" class="headerlink" title="10.3.2.    场景"></a>10.3.2.    场景</h3><p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>
<p>下面我们用 Python 来建立一个能够记录页面访问次数的 web 网站。</p>
<p><strong>web</strong> <strong>应用</strong></p>
<p>新建文件夹，在该目录中编写 app.py 文件</p>
<p>from flask import Flask</p>
<p>from redis import Redis</p>
<p>app = Flask(<strong>name</strong>)</p>
<p>redis = Redis(host=’redis’, port=6379)</p>
<p>@app.route(‘/‘)</p>
<p>def hello():</p>
<p>  count = redis.incr(‘hits’)</p>
<p>  return ‘Hello World! 该页面已被访问 {} 次。\n’.format(count)</p>
<p>if <strong>name</strong> == “<strong>main</strong>“:</p>
<p>  app.run(host=”0.0.0.0”, debug=True)</p>
<p><strong>Dockerfile</strong></p>
<p>编写 Dockerfile 文件，内容为</p>
<p>FROM python:3.6-alpine</p>
<p>ADD . /code</p>
<p>WORKDIR /code</p>
<p>RUN pip install redis flask</p>
<p>CMD [“python”, “app.py”]</p>
<p><strong>docker-compose.yml</strong></p>
<p>编写 docker-compose.yml 文件，这个是 Compose 使用的主模板文件。</p>
<p>version: ‘3’</p>
<p>services:</p>
<p> web:</p>
<p>  build: .</p>
<p>  ports:</p>
<p>   - “5000:5000”</p>
<p> redis:</p>
<p>  image: “redis:alpine”</p>
<p><strong>运行 compose 项目</strong></p>
<p>docker-compose up</p>
<p>此时访问本地 5000 端口，每次刷新页面，计数就会加 1。</p>
<h2 id="10-4-docker-compose-命令说明"><a href="#10-4-docker-compose-命令说明" class="headerlink" title="10.4. docker compose 命令说明"></a>10.4. docker compose 命令说明</h2><h3 id="10-4-1-命令对象与格式"><a href="#10-4-1-命令对象与格式" class="headerlink" title="10.4.1.    命令对象与格式"></a>10.4.1.    命令对象与格式</h3><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>
<p>执行 docker-compose [COMMAND] –help 或者 docker-compose help [COMMAND] 可以查看具体某个命令的使用格式。</p>
<p>docker-compose 命令的基本的使用格式是</p>
<p>docker-compose [-f=<arg>…] [options] [COMMAND] [ARGS…]</p>
<h3 id="10-4-2-命令选项"><a href="#10-4-2-命令选项" class="headerlink" title="10.4.2.    命令选项"></a>10.4.2.    命令选项</h3><p>l -f, –file FILE 指定使用的 Compose 模板文件，默认为 docker-compose.yml，可以多次指定。</p>
<p>l -p, –project-name NAME 指定项目名称，默认将使用所在目录名称作为项目名。</p>
<p>l –x-networking 使用 Docker 的可拔插网络后端特性</p>
<p>l –x-network-driver DRIVER 指定网络后端的驱动，默认为 bridge</p>
<p>l –verbose 输出更多调试信息。</p>
<p>l -v, –version 打印版本并退出。</p>
<h3 id="10-4-3-命令使用说明"><a href="#10-4-3-命令使用说明" class="headerlink" title="10.4.3.    命令使用说明"></a>10.4.3.    命令使用说明</h3><h4 id="10-4-3-1-build"><a href="#10-4-3-1-build" class="headerlink" title="10.4.3.1. build"></a>10.4.3.1. build</h4><p>格式为 docker-compose build [options] [SERVICE…]。</p>
<p>构建（重新构建）项目中的服务容器。</p>
<p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。</p>
<p>可以随时在项目目录下运行 docker-compose build 来重新构建服务。</p>
<p>选项包括：</p>
<p>l –force-rm 删除构建过程中的临时容器。</p>
<p>l –no-cache 构建镜像过程中不使用 cache（这将加长构建过程）。</p>
<p>l –pull 始终尝试通过 pull 来获取更新版本的镜像。</p>
<h4 id="10-4-3-2-config"><a href="#10-4-3-2-config" class="headerlink" title="10.4.3.2. config"></a>10.4.3.2. config</h4><p>验证 Compose 文件格式是否正确，若正确则显示配置，若格式错误显示错误原因。</p>
<h4 id="10-4-3-3-down"><a href="#10-4-3-3-down" class="headerlink" title="10.4.3.3. down"></a>10.4.3.3. down</h4><p>此命令将会停止 up 命令所启动的容器，并移除网络</p>
<h4 id="10-4-3-4-exec"><a href="#10-4-3-4-exec" class="headerlink" title="10.4.3.4. exec"></a>10.4.3.4. exec</h4><p>进入指定的容器。</p>
<h4 id="10-4-3-5-help"><a href="#10-4-3-5-help" class="headerlink" title="10.4.3.5. help"></a>10.4.3.5. help</h4><p>获得一个命令的帮助。</p>
<h4 id="10-4-3-6-images"><a href="#10-4-3-6-images" class="headerlink" title="10.4.3.6. images"></a>10.4.3.6. images</h4><p>列出 Compose 文件中包含的镜像。</p>
<h4 id="10-4-3-7-kill"><a href="#10-4-3-7-kill" class="headerlink" title="10.4.3.7. kill"></a>10.4.3.7. kill</h4><p>格式为 docker-compose kill [options] [SERVICE…]。</p>
<p>通过发送 SIGKILL 信号来强制停止服务容器。</p>
<p>支持通过 -s 参数来指定发送的信号，例如通过如下指令发送 SIGINT 信号。</p>
<p>docker-compose kill -s SIGINT</p>
<h4 id="10-4-3-8-logs"><a href="#10-4-3-8-logs" class="headerlink" title="10.4.3.8. logs"></a>10.4.3.8. logs</h4><p>格式为 docker-compose logs [options] [SERVICE…]。</p>
<p>查看服务容器的输出。默认情况下，docker-compose 将对不同的服务输出使用不同的颜色来区分。可以通过 –no-color 来关闭颜色。</p>
<p>该命令在调试问题的时候十分有用。</p>
<h4 id="10-4-3-9-pause"><a href="#10-4-3-9-pause" class="headerlink" title="10.4.3.9. pause"></a>10.4.3.9. pause</h4><p>格式为 docker-compose pause [SERVICE…]。</p>
<p>暂停一个服务容器。</p>
<h4 id="10-4-3-10-port"><a href="#10-4-3-10-port" class="headerlink" title="10.4.3.10.    port"></a>10.4.3.10.    port</h4><p>格式为 docker-compose port [options] SERVICE PRIVATE_PORT。</p>
<p>打印某个容器端口所映射的公共端口。</p>
<p>选项：</p>
<p>l –protocol=proto 指定端口协议，tcp（默认值）或者 udp。</p>
<p>l –index=index 如果同一服务存在多个容器，指定命令对象容器的序号（默认为 1）。</p>
<h4 id="10-4-3-11-ps"><a href="#10-4-3-11-ps" class="headerlink" title="10.4.3.11.    ps"></a>10.4.3.11.    ps</h4><p>格式为 docker-compose ps [options] [SERVICE…]。</p>
<p>列出项目中目前的所有容器。</p>
<p>选项：</p>
<p>l -q 只打印容器的 ID 信息。</p>
<h4 id="10-4-3-12-pull"><a href="#10-4-3-12-pull" class="headerlink" title="10.4.3.12.    pull"></a>10.4.3.12.    pull</h4><p>格式为 docker-compose pull [options] [SERVICE…]。</p>
<p>拉取服务依赖的镜像。</p>
<p>选项：</p>
<p>l –ignore-pull-failures 忽略拉取镜像过程中的错误。</p>
<h4 id="10-4-3-13-push"><a href="#10-4-3-13-push" class="headerlink" title="10.4.3.13.    push"></a>10.4.3.13.    push</h4><p>推送服务依赖的镜像到 Docker 镜像仓库。</p>
<h4 id="10-4-3-14-restart"><a href="#10-4-3-14-restart" class="headerlink" title="10.4.3.14.    restart"></a>10.4.3.14.    restart</h4><p>格式为 docker-compose restart [options] [SERVICE…]。</p>
<p>重启项目中的服务。</p>
<p>选项：</p>
<p>l -t, –timeout TIMEOUT 指定重启前停止容器的超时（默认为 10 秒）。</p>
<h4 id="10-4-3-15-rm"><a href="#10-4-3-15-rm" class="headerlink" title="10.4.3.15.    rm"></a>10.4.3.15.    rm</h4><p>格式为 docker-compose rm [options] [SERVICE…]。</p>
<p>删除所有（停止状态的）服务容器。推荐先执行 docker-compose stop 命令来停止容器。</p>
<p>选项：</p>
<p>l -f, –force 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</p>
<p>l -v 删除容器所挂载的数据卷。</p>
<h4 id="10-4-3-16-run"><a href="#10-4-3-16-run" class="headerlink" title="10.4.3.16.    run"></a>10.4.3.16.    run</h4><p>格式为 docker-compose run [options] [-p PORT…] [-e KEY=VAL…] SERVICE [COMMAND] [ARGS…]。</p>
<p>在指定服务上执行一个命令。</p>
<p>例如：</p>
<p>docker-compose run ubuntu ping docker.com</p>
<p>将会启动一个 ubuntu 服务容器，并执行 ping docker.com 命令。</p>
<p>默认情况下，如果存在关联，则所有关联的服务将会自动被启动，除非这些服务已经在运行中。</p>
<p>该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照配置自动创建。</p>
<p>两个不同点：</p>
<p>l 给定命令将会覆盖原有的自动运行命令；</p>
<p>l 不会自动创建端口，以避免冲突。</p>
<p>如果不希望自动启动关联的容器，可以使用 –no-deps 选项，例如</p>
<p>docker-compose run –no-deps web python manage.py shell</p>
<p>将不会启动 web 容器所关联的其它容器。</p>
<p>选项：</p>
<p>l -d 后台运行容器。</p>
<p>l –name NAME 为容器指定一个名字。</p>
<p>l –entrypoint CMD 覆盖默认的容器启动指令。</p>
<p>l -e KEY=VAL 设置环境变量值，可多次使用选项来设置多个环境变量。</p>
<p>l -u, –user=”” 指定运行容器的用户名或者 uid。</p>
<p>l –no-deps 不自动启动关联的服务容器。</p>
<p>l –rm 运行命令后自动删除容器，d 模式下将忽略。</p>
<p>l -p, –publish=[] 映射容器端口到本地主机。</p>
<p>l –service-ports 配置服务端口并映射到本地主机。</p>
<p>l -T 不分配伪 tty，意味着依赖 tty 的指令将无法运行。</p>
<h4 id="10-4-3-17-scale"><a href="#10-4-3-17-scale" class="headerlink" title="10.4.3.17.    scale"></a>10.4.3.17.    scale</h4><p>格式为 docker-compose scale [options] [SERVICE=NUM…]。</p>
<p>设置指定服务运行的容器个数。</p>
<p>通过 service=num 的参数来设置数量。例如：</p>
<p>docker-compose scale web=3 db=2</p>
<p>将启动 3 个容器运行 web 服务，2 个容器运行 db 服务。</p>
<p>一般的，当指定数目多于该服务当前实际运行容器，将新创建并启动容器；反之，将停止容器。</p>
<p>选项：</p>
<p>l -t, –timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。</p>
<h4 id="10-4-3-18-start"><a href="#10-4-3-18-start" class="headerlink" title="10.4.3.18.    start"></a>10.4.3.18.    start</h4><p>格式为 docker-compose start [SERVICE…]。</p>
<p>启动已经存在的服务容器。</p>
<h4 id="10-4-3-19-stop"><a href="#10-4-3-19-stop" class="headerlink" title="10.4.3.19.    stop"></a>10.4.3.19.    stop</h4><p>格式为 docker-compose stop [options] [SERVICE…]。</p>
<p>停止已经处于运行状态的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。</p>
<p>选项：</p>
<p>l -t, –timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。</p>
<h4 id="10-4-3-20-top"><a href="#10-4-3-20-top" class="headerlink" title="10.4.3.20.    top"></a>10.4.3.20.    top</h4><p>查看各个服务容器内运行的进程。</p>
<h4 id="10-4-3-21-unpause"><a href="#10-4-3-21-unpause" class="headerlink" title="10.4.3.21.    unpause"></a>10.4.3.21.    unpause</h4><p>格式为 docker-compose unpause [SERVICE…]。</p>
<p>恢复处于暂停状态中的服务。</p>
<h4 id="10-4-3-22-up"><a href="#10-4-3-22-up" class="headerlink" title="10.4.3.22.    up"></a>10.4.3.22.    up</h4><p>格式为 docker-compose up [options] [SERVICE…]。</p>
<p>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</p>
<p>链接的服务都将会被自动启动，除非已经处于运行状态。</p>
<p>可以说，大部分时候都可以直接通过该命令来启动一个项目。</p>
<p>默认情况，docker-compose up 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</p>
<p>当通过 Ctrl-C 停止命令时，所有容器将会停止。</p>
<p>如果使用 docker-compose up -d，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</p>
<p>默认情况，如果服务容器已经存在，docker-compose up 将会尝试停止容器，然后重新创建（保持使用 volumes-from 挂载的卷），以保证新启动的服务匹配 docker-compose.yml 文件的最新内容。如果用户不希望容器被停止并重新创建，可以使用 docker-compose up –no-recreate。这样将只会启动处于停止状态的容器，而忽略已经运行的服务。如果用户只想重新部署某个服务，可以使用 docker-compose up –no-deps -d <SERVICE_NAME> 来重新创建服务并后台停止旧服务，启动新服务，并不会影响到其所依赖的服务。</p>
<p>选项：</p>
<p>l -d 在后台运行服务容器。</p>
<p>l –no-color 不使用颜色来区分不同的服务的控制台输出。</p>
<p>l –no-deps 不启动服务所链接的容器。</p>
<p>l –force-recreate 强制重新创建容器，不能与 –no-recreate 同时使用。</p>
<p>l –no-recreate 如果容器已经存在了，则不重新创建，不能与 –force-recreate 同时使用。</p>
<p>l –no-build 不自动构建缺失的服务镜像。</p>
<p>l -t, –timeout TIMEOUT 停止容器时候的超时（默认为 10 秒）。</p>
<h4 id="10-4-3-23-version"><a href="#10-4-3-23-version" class="headerlink" title="10.4.3.23.    version"></a>10.4.3.23.    version</h4><p>格式为 docker-compose version。</p>
<p>打印版本信息。</p>
<h2 id="10-5-docker-compose-模板文件"><a href="#10-5-docker-compose-模板文件" class="headerlink" title="10.5. docker compose 模板文件"></a>10.5. docker compose 模板文件</h2><p>模板文件是使用 Compose 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 docker run 相关参数的含义都是类似的。</p>
<p>默认的模板文件名称为 docker-compose.yml，格式为 YAML 格式。</p>
<p>version: “3”</p>
<p>services:</p>
<p> webapp:</p>
<p>  image: examples/web</p>
<p>  ports:</p>
<p>   - “80:80”</p>
<p>  volumes:</p>
<p>   - “/data”</p>
<p>注意每个服务都必须通过 image 指令指定镜像或 build 指令（需要 Dockerfile）等来自动构建生成镜像。</p>
<p>如果使用 build 指令，在 Dockerfile 中设置的选项(例如：CMD, EXPOSE, VOLUME, ENV 等) 将会自动被获取，无需在 docker-compose.yml 中再次设置。</p>
<p>下面分别介绍各个指令的用法。</p>
<h3 id="10-5-1-build"><a href="#10-5-1-build" class="headerlink" title="10.5.1.    build"></a>10.5.1.    build</h3><p>指定 Dockerfile 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。</p>
<p>version: ‘3’</p>
<p>services:</p>
<p> webapp:</p>
<p>  build: ./dir</p>
<p>你也可以使用 context 指令指定 Dockerfile 所在文件夹的路径。</p>
<p>使用 dockerfile 指令指定 Dockerfile 文件名。</p>
<p>使用 arg 指令指定构建镜像时的变量。</p>
<p>version: ‘3’</p>
<p>services:</p>
<p> webapp:</p>
<p>  build:</p>
<p>   context: ./dir</p>
<p>   dockerfile: Dockerfile-alternate</p>
<p>   args:</p>
<p>​    buildno: 1</p>
<p>使用 cache_from 指定构建镜像的缓存</p>
<p>build:</p>
<p> context: .</p>
<p> cache_from:</p>
<p>  - alpine:latest</p>
<p>  - corp/web_app:3.14</p>
<h3 id="10-5-2-cap-add-cap-drop"><a href="#10-5-2-cap-add-cap-drop" class="headerlink" title="10.5.2.    cap_add, cap_drop"></a>10.5.2.    cap_add, cap_drop</h3><p>指定容器的内核能力（capacity）分配。</p>
<p>例如，让容器拥有所有能力可以指定为：</p>
<p>cap_add:</p>
<p> - ALL</p>
<p>去掉 NET_ADMIN 能力可以指定为：</p>
<p>cap_drop:</p>
<p> - NET_ADMIN</p>
<h3 id="10-5-3-command"><a href="#10-5-3-command" class="headerlink" title="10.5.3.    command"></a>10.5.3.    command</h3><p>覆盖容器启动后默认执行的命令。</p>
<p>command: echo “hello world”</p>
<h3 id="10-5-4-configs"><a href="#10-5-4-configs" class="headerlink" title="10.5.4.    configs"></a>10.5.4.    configs</h3><p>仅用于 Swarm mode</p>
<h3 id="10-5-5-cgroup-parent"><a href="#10-5-5-cgroup-parent" class="headerlink" title="10.5.5.    cgroup_parent"></a>10.5.5.    cgroup_parent</h3><p>指定父 cgroup 组，意味着将继承该组的资源限制。</p>
<p>例如，创建了一个 cgroup 组名称为 cgroups_1。</p>
<p>cgroup_parent: cgroups_1</p>
<h3 id="10-5-6-container-name"><a href="#10-5-6-container-name" class="headerlink" title="10.5.6.    container_name"></a>10.5.6.    container_name</h3><p>指定容器名称。默认将会使用 项目名称_服务名称_序号 这样的格式。</p>
<p>container_name: docker-web-container</p>
<p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p>
<h3 id="10-5-7-deploy"><a href="#10-5-7-deploy" class="headerlink" title="10.5.7.    deploy"></a>10.5.7.    deploy</h3><p>仅用于 Swarm mode</p>
<h3 id="10-5-8-devices"><a href="#10-5-8-devices" class="headerlink" title="10.5.8.    devices"></a>10.5.8.    devices</h3><p>指定设备映射关系。</p>
<p>devices:</p>
<p> - “/dev/ttyUSB1:/dev/ttyUSB0”</p>
<h3 id="10-5-9-depends-on"><a href="#10-5-9-depends-on" class="headerlink" title="10.5.9.    depends_on"></a>10.5.9.    depends_on</h3><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 redis db 再启动 web</p>
<p>version: ‘3’</p>
<p>services:</p>
<p> web:</p>
<p>  build: .</p>
<p>  depends_on:</p>
<p>   - db</p>
<p>   - redis</p>
<p> redis:</p>
<p>  image: redis</p>
<p> db:</p>
<p>  image: postgres</p>
<p>注意：web 服务不会等待 redis db 「完全启动」之后才启动。</p>
<h3 id="10-5-10-dns"><a href="#10-5-10-dns" class="headerlink" title="10.5.10.  dns"></a>10.5.10.  dns</h3><p>自定义 DNS 服务器。可以是一个值，也可以是一个列表。</p>
<p>dns: 8.8.8.8</p>
<p>dns:</p>
<p> - 8.8.8.8</p>
<p> - 114.114.114.114</p>
<h3 id="10-5-11-dns-search"><a href="#10-5-11-dns-search" class="headerlink" title="10.5.11.  dns_search"></a>10.5.11.  dns_search</h3><p>配置 DNS 搜索域。可以是一个值，也可以是一个列表。</p>
<p>dns_search: example.com</p>
<p>dns_search:</p>
<p> - domain1.example.com</p>
<p> - domain2.example.com</p>
<h3 id="10-5-12-tmpfs"><a href="#10-5-12-tmpfs" class="headerlink" title="10.5.12.  tmpfs"></a>10.5.12.  tmpfs</h3><p>挂载一个 tmpfs 文件系统到容器。</p>
<p>tmpfs: /run</p>
<p>tmpfs:</p>
<p> - /run</p>
<p> - /tmp</p>
<h3 id="10-5-13-env-file"><a href="#10-5-13-env-file" class="headerlink" title="10.5.13.  env_file"></a>10.5.13.  env_file</h3><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>
<p>如果通过 docker-compose -f FILE 方式来指定 Compose 模板文件，则 env_file 中变量的路径会基于模板文件路径。</p>
<p>如果有变量名称与 environment 指令冲突，则按照惯例，以后者为准。</p>
<p>env_file: .env</p>
<p>env_file:</p>
<p> - ./common.env</p>
<p> - ./apps/web.env</p>
<p> - /opt/secrets.env</p>
<p>环境变量文件中每一行必须符合格式，支持 # 开头的注释行。</p>
<p># common.env: Set development environment</p>
<p>PROG_ENV=development</p>
<h3 id="10-5-14-environment"><a href="#10-5-14-environment" class="headerlink" title="10.5.14.  environment"></a>10.5.14.  environment</h3><p>设置环境变量。你可以使用数组或字典两种格式。</p>
<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>
<p>environment:</p>
<p> RACK_ENV: development</p>
<p> SESSION_SECRET:</p>
<p>environment:</p>
<p> - RACK_ENV=development</p>
<p> - SESSION_SECRET</p>
<p>如果变量名称或者值中用到 true|false，yes|no 等表达 布尔 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>
<p>y|Y|yes|Yes|YES|n|N|no|No|NO|true|True|TRUE|false|False|FALSE|on|On|ON|off|Off|OFF</p>
<h3 id="10-5-15-expose"><a href="#10-5-15-expose" class="headerlink" title="10.5.15.  expose"></a>10.5.15.  expose</h3><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p>
<p>仅可以指定内部端口为参数</p>
<p>expose:</p>
<p> - “3000”</p>
<p> - “8000”</p>
<h3 id="10-5-16-external-links"><a href="#10-5-16-external-links" class="headerlink" title="10.5.16.  external_links"></a>10.5.16.  external_links</h3><p>注意：不建议使用该指令。</p>
<p>链接到 docker-compose.yml 外部的容器，甚至并非 Compose 管理的外部容器。</p>
<p>external_links:</p>
<p> - redis_1</p>
<p> - project_db_1:mysql</p>
<p> - project_db_1:postgresql</p>
<h3 id="10-5-17-extra-hosts"><a href="#10-5-17-extra-hosts" class="headerlink" title="10.5.17.  extra_hosts"></a>10.5.17.  extra_hosts</h3><p>类似 Docker 中的 –add-host 参数，指定额外的 host 名称映射信息。</p>
<p>extra_hosts:</p>
<p> - “googledns:8.8.8.8”</p>
<p> - “dockerhub:52.1.157.61”</p>
<p>会在启动后的服务容器中 /etc/hosts 文件中添加如下两条条目。</p>
<p>8.8.8.8 googledns</p>
<p>52.1.157.61 dockerhub:</p>
<h3 id="10-5-18-healthcheck"><a href="#10-5-18-healthcheck" class="headerlink" title="10.5.18.  healthcheck"></a>10.5.18.  healthcheck</h3><p>通过命令检查容器是否健康运行。</p>
<p>healthcheck:</p>
<p> test: [“CMD”, “curl”, “-f”, “<a href="http://localhost&quot;]">http://localhost&quot;]</a></p>
<p> interval: 1m30s</p>
<p> timeout: 10s</p>
<p> retries: 3</p>
<h3 id="10-5-19-image"><a href="#10-5-19-image" class="headerlink" title="10.5.19.  image"></a>10.5.19.  image</h3><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉取这个镜像。</p>
<p>image: ubuntu</p>
<p>image: orchardup/postgresql</p>
<p>image: a4bc65fd</p>
<h3 id="10-5-20-labels"><a href="#10-5-20-labels" class="headerlink" title="10.5.20.  labels"></a>10.5.20.  labels</h3><p>为容器添加 Docker 元数据（metadata）信息。例如可以为容器添加辅助说明信息。</p>
<p>labels:</p>
<p> com.startupteam.description: “webapp for a startup team”</p>
<p> com.startupteam.department: “devops department”</p>
<p> com.startupteam.release: “rc3 for v1.0”</p>
<h3 id="10-5-21-links"><a href="#10-5-21-links" class="headerlink" title="10.5.21.  links"></a>10.5.21.  links</h3><p>注意：不推荐使用该指令。</p>
<h3 id="10-5-22-logging"><a href="#10-5-22-logging" class="headerlink" title="10.5.22.  logging"></a>10.5.22.  logging</h3><p>配置日志选项。</p>
<p>logging:</p>
<p> driver: syslog</p>
<p> options:</p>
<p>  syslog-address: “tcp://192.168.0.42:123”</p>
<p>目前支持三种日志驱动类型。</p>
<p>driver: “json-file”</p>
<p>driver: “syslog”</p>
<p>driver: “none”</p>
<p>options 配置日志驱动的相关参数。</p>
<p>options:</p>
<p> max-size: “200k”</p>
<p> max-file: “10”</p>
<h3 id="10-5-23-network-mode"><a href="#10-5-23-network-mode" class="headerlink" title="10.5.23.  network_mode"></a>10.5.23.  network_mode</h3><p>设置网络模式。使用和 docker run 的 –network 参数一样的值。</p>
<p>network_mode: “bridge”</p>
<p>network_mode: “host”</p>
<p>network_mode: “none”</p>
<p>network_mode: “service:[service name]”</p>
<p>network_mode: “container:[container name/id]”</p>
<h3 id="10-5-24-networks"><a href="#10-5-24-networks" class="headerlink" title="10.5.24.  networks"></a>10.5.24.  networks</h3><p>配置容器连接的网络。</p>
<p>version: “3”</p>
<p>services:</p>
<p> some-service:</p>
<p>  networks:</p>
<p>   - some-network</p>
<p>   - other-network</p>
<p>networks:</p>
<p> some-network:</p>
<p> other-network:</p>
<h3 id="10-5-25-pid"><a href="#10-5-25-pid" class="headerlink" title="10.5.25.  pid"></a>10.5.25.  pid</h3><p>跟主机系统共享进程命名空间。打开该选项的容器之间，以及容器和宿主机系统之间可以通过进程 ID 来相互访问和操作。</p>
<p>pid: “host”</p>
<h3 id="10-5-26-ports"><a href="#10-5-26-ports" class="headerlink" title="10.5.26.  ports"></a>10.5.26.  ports</h3><p>暴露端口信息。</p>
<p>使用宿主端口：容器端口 (HOST:CONTAINER) 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>
<p>ports:</p>
<p> - “3000”</p>
<p> - “8000:8000”</p>
<p> - “49100:22”</p>
<p> - “127.0.0.1:8001:8001”</p>
<p>注意：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 YAML 会自动解析 xx:yy 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</p>
<h3 id="10-5-27-secrets"><a href="#10-5-27-secrets" class="headerlink" title="10.5.27.  secrets"></a>10.5.27.  secrets</h3><p>存储敏感数据，例如 mysql 服务密码。</p>
<p>version: “3.1”</p>
<p>services:</p>
<p>mysql:</p>
<p> image: mysql</p>
<p> environment:</p>
<p>  MYSQL_ROOT_PASSWORD_FILE: /run/secrets/db_root_password</p>
<p> secrets:</p>
<p>  - db_root_password</p>
<p>  - my_other_secret</p>
<p>secrets:</p>
<p> my_secret:</p>
<p>  file: ./my_secret.txt</p>
<p> my_other_secret:</p>
<p>  external: true</p>
<h3 id="10-5-28-security-opt"><a href="#10-5-28-security-opt" class="headerlink" title="10.5.28.  security_opt"></a>10.5.28.  security_opt</h3><p>指定容器模板标签（label）机制的默认属性（用户、角色、类型、级别等）。例如配置标签的用户名和角色名。</p>
<p>security_opt:</p>
<p>  - label:user:USER</p>
<p>  - label:role:ROLE</p>
<h3 id="10-5-29-stop-signal"><a href="#10-5-29-stop-signal" class="headerlink" title="10.5.29.  stop_signal"></a>10.5.29.  stop_signal</h3><p>设置另一个信号来停止容器。在默认情况下使用的是 SIGTERM 停止容器。</p>
<p>stop_signal: SIGUSR1</p>
<h3 id="10-5-30-sysctls"><a href="#10-5-30-sysctls" class="headerlink" title="10.5.30.  sysctls"></a>10.5.30.  sysctls</h3><p>配置容器内核参数。</p>
<p>sysctls:</p>
<p> net.core.somaxconn: 1024</p>
<p> net.ipv4.tcp_syncookies: 0</p>
<p>sysctls:</p>
<p> - net.core.somaxconn=1024</p>
<p> - net.ipv4.tcp_syncookies=0</p>
<h3 id="10-5-31-ulimits"><a href="#10-5-31-ulimits" class="headerlink" title="10.5.31.  ulimits"></a>10.5.31.  ulimits</h3><p>指定容器的 ulimits 限制值。</p>
<p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>
<p> ulimits:</p>
<p>  nproc: 65535</p>
<p>  nofile:</p>
<p>   soft: 20000</p>
<p>   hard: 40000</p>
<h3 id="10-5-32-volumes"><a href="#10-5-32-volumes" class="headerlink" title="10.5.32.  volumes"></a>10.5.32.  volumes</h3><p>数据卷所挂载路径设置。可以设置宿主机路径 （HOST:CONTAINER） 或加上访问模式 （HOST:CONTAINER:ro）。</p>
<p>该指令中路径支持相对路径。</p>
<p>volumes:</p>
<p> - /var/lib/mysql</p>
<p> - cache/:/tmp/cache</p>
<p> - ~/configs:/etc/configs/:ro</p>
<h3 id="10-5-33-其它指令"><a href="#10-5-33-其它指令" class="headerlink" title="10.5.33.  其它指令"></a>10.5.33.  其它指令</h3><p>此外，还有包括 domainname, entrypoint, hostname, ipc, mac_address, privileged, read_only, shm_size, restart, stdin_open, tty, user, working_dir 等指令，基本跟 docker run 中对应参数的功能一致。</p>
<p>指定服务容器启动后执行的入口文件。</p>
<p>entrypoint: /code/entrypoint.sh</p>
<p>指定容器中运行应用的用户名。</p>
<p>user: nginx</p>
<p>指定容器中工作目录。</p>
<p>working_dir: /code</p>
<p>指定容器中搜索域名、主机名、mac 地址等。</p>
<p>domainname: your_website.com</p>
<p>hostname: test</p>
<p>mac_address: 08-00-27-00-0C-0A</p>
<p>允许容器中运行一些特权命令。</p>
<p>privileged: true</p>
<p>指定容器退出后的重启策略为始终重启。该命令对保持服务始终运行十分有效，在生产环境中推荐配置为 always 或者 unless-stopped。</p>
<p>restart: always</p>
<p>以只读模式挂载容器的 root 文件系统，意味着不能对容器内容进行修改。</p>
<p>read_only: true</p>
<p>打开标准输入，可以接受外部输入。</p>
<p>stdin_open: true</p>
<p>模拟一个伪终端。</p>
<p>tty: true</p>
<h3 id="10-5-34-读取变量"><a href="#10-5-34-读取变量" class="headerlink" title="10.5.34.  读取变量"></a>10.5.34.  读取变量</h3><p>Compose 模板文件支持动态读取主机的系统环境变量和当前目录下的 .env 文件中的变量。</p>
<p>例如，下面的 Compose 文件将从运行它的环境中读取变量 ${MONGO_VERSION} 的值，并写入执行的指令中。</p>
<p>version: “3”</p>
<p>services:</p>
<p>db:</p>
<p> image: “mongo:${MONGO_VERSION}”</p>
<p>如果执行 MONGO_VERSION=3.2 docker-compose up 则会启动一个 mongo:3.2 镜像的容器；如果执行 MONGO_VERSION=2.8 docker-compose up 则会启动一个 mongo:2.8 镜像的容器。</p>
<p>若当前目录存在 .env 文件，执行 docker-compose 命令时将从该文件中读取变量。</p>
<p>在当前目录新建 .env 文件并写入以下内容。</p>
<p># 支持 # 号注释</p>
<p>MONGO_VERSION=3.6</p>
<p>执行 docker-compose up 则会启动一个 mongo:3.6 镜像的容器。</p>
<h2 id="10-6-docker-compose-实战-dubbo-admin"><a href="#10-6-docker-compose-实战-dubbo-admin" class="headerlink" title="10.6. docker compose 实战 dubbo-admin"></a>10.6. docker compose 实战 dubbo-admin</h2><p>compose 可以很便捷的让 dubbo-admin 运行在一个独立的环境中。</p>
<h3 id="10-6-1-创建空文件夹"><a href="#10-6-1-创建空文件夹" class="headerlink" title="10.6.1.    创建空文件夹"></a>10.6.1.    创建空文件夹</h3><p>假设新建一个名为 dubbo-admin 的文件夹，然后进入这个文件夹。</p>
<h3 id="10-6-2-创建-docker-compose-yml-文件"><a href="#10-6-2-创建-docker-compose-yml-文件" class="headerlink" title="10.6.2.    创建 docker-compose.yml 文件"></a>10.6.2.    创建 docker-compose.yml 文件</h3><p>docker-compose.yml 文件将开启一个 dubbo-admin 服务和一个独立的 zookeeper 实例：</p>
<p>version: ‘3.4’</p>
<p>services:</p>
<p> zk_server:</p>
<p>  image: zookeeper:3.4</p>
<p>  ports:</p>
<p>   - 2181:2181</p>
<p> dubbo-admin:</p>
<p>  image: xiaochunping/dubbo-admin:1.0</p>
<p>  links:</p>
<p>   - zk_server:zookeeper</p>
<p>  depends_on:</p>
<p>   - zk_server</p>
<p>  ports:</p>
<p>   - 7001:7001</p>
<h3 id="10-6-3-构建并运行项目"><a href="#10-6-3-构建并运行项目" class="headerlink" title="10.6.3.    构建并运行项目"></a>10.6.3.    构建并运行项目</h3><p>运行 docker-compose up -d 就会拉取镜像再创建我们所需要的镜像，然后启动 dubbo-admin 和数据库容器。 接着浏览器访问 127.0.0.1:7001 端口就能看到 dubbo-admin 安装界面了。</p>
<h1 id="11-docker-三剑客-machine"><a href="#11-docker-三剑客-machine" class="headerlink" title="11.  docker 三剑客 machine"></a>11.  docker 三剑客 machine</h1><h2 id="11-1-Docker-Machine-简介"><a href="#11-1-Docker-Machine-简介" class="headerlink" title="11.1. Docker Machine 简介"></a>11.1. Docker Machine 简介</h2><p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135253.gif" alt="IMG_256"></p>
<p>Docker Machine 是 Docker 官方编排（Orchestration）项目之一，负责在多种平台上快速安装 Docker 环境。</p>
<p>Docker Machine 项目基于 Go 语言实现，目前在 <a href="https://github.com/docker/machine" target="_blank" rel="noopener">Github </a>上进行维护。</p>
<p>本章将介绍 Docker Machine 的安装及使用。</p>
<h2 id="11-2-Docker-Machine-安装"><a href="#11-2-Docker-Machine-安装" class="headerlink" title="11.2. Docker Machine 安装"></a>11.2. Docker Machine 安装</h2><p>Docker Machine 可以在多种操作系统平台上安装，包括 Linux、macOS，以及 Windows。</p>
<h3 id="11-2-1-macOS、Windows"><a href="#11-2-1-macOS、Windows" class="headerlink" title="11.2.1.    macOS、Windows"></a>11.2.1.    macOS、Windows</h3><p>Docker for Mac、Docker for Windows 自带 docker-machine 二进制包，安装之后即可使用。</p>
<p>查看版本信息。</p>
<p>docker-machine -v</p>
<h3 id="11-2-2-Linux"><a href="#11-2-2-Linux" class="headerlink" title="11.2.2.    Linux"></a>11.2.2.    Linux</h3><p>在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。</p>
<p>例如，在 Linux 64 位系统上直接下载对应的二进制包。</p>
<p>sudo curl -L <a href="https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname" target="_blank" rel="noopener">https://github.com/docker/machine/releases/download/v0.13.0/docker-machine-`uname</a> -s<code>-</code>uname -m` &gt; /usr/local/bin/docker-machine</p>
<p>sudo chmod +x /usr/local/bin/docker-machine</p>
<p>完成后，查看版本信息。</p>
<p>docker-machine -v</p>
<h2 id="11-3-Docker-Machine-使用"><a href="#11-3-Docker-Machine-使用" class="headerlink" title="11.3. Docker Machine 使用"></a>11.3. Docker Machine 使用</h2><p>Docker Machine 支持多种后端驱动，包括虚拟机、本地主机和云平台等。</p>
<h3 id="11-3-1-创建本地主机实例"><a href="#11-3-1-创建本地主机实例" class="headerlink" title="11.3.1.    创建本地主机实例"></a>11.3.1.    创建本地主机实例</h3><p><strong>Virtualbox</strong> <strong>驱动</strong></p>
<p>使用 virtualbox 类型的驱动，创建一台 Docker 主机，命名为 test。</p>
<p>docker-machine create -d virtualbox test</p>
<p>你也可以在创建时加上如下参数，来配置主机或者主机上的 Docker。</p>
<p>–engine-opt dns=114.114.114.114 配置 Docker 的默认 DNS</p>
<p>–engine-registry-mirror <a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a> 配置 Docker 的仓库镜像</p>
<p>–virtualbox-memory 2048 配置主机内存</p>
<p>–virtualbox-cpu-count 2 配置主机 CPU</p>
<p>更多参数请使用 docker-machine create –driver virtualbox –help 命令查看。</p>
<p><strong>macOS xhyve</strong> <strong>驱动</strong></p>
<p>xhyve 驱动 GitHub: <a href="https://github.com/zchee/docker-machine-driver-xhyve" target="_blank" rel="noopener">https://github.com/zchee/docker-machine-driver-xhyve</a></p>
<p>xhyve 是 macOS 上轻量化的虚拟引擎，使用其创建的 Docker Machine 较 VirtualBox 驱动创建的运行效率要高。</p>
<p>brew install docker-machine-driver-xhyve</p>
<p>docker-machine create \</p>
<p>   -d xhyve \</p>
<p>   # –xhyve-boot2docker-url ~/.docker/machine/cache/boot2docker.iso \</p>
<p>   –engine-opt dns=114.114.114.114 \</p>
<p>   –engine-registry-mirror <a href="https://registry.docker-cn.com" target="_blank" rel="noopener">https://registry.docker-cn.com</a> \</p>
<p>   –xhyve-memory-size 2048 \</p>
<p>   –xhyve-rawdisk \</p>
<p>   –xhyve-cpu-count 2 \</p>
<p>   xhyve</p>
<p>注意：非首次创建时建议加上 –xhyve-boot2docker-url ~/.docker/machine/cache/boot2docker.iso 参数，避免每次创建时都从 GitHub 下载 ISO 镜像。</p>
<p>更多参数请使用 docker-machine create –driver xhyve –help 命令查看。</p>
<p><strong>Windows 10</strong></p>
<p>Windows 10 安装 Docker for Windows 之后不能再安装 VirtualBox，也就不能使用 virtualbox 驱动来创建 Docker Machine，我们可以选择使用 hyperv 驱动。</p>
<p>docker-machine create –driver hyperv vm</p>
<p>更多参数请使用 docker-machine create –driver hyperv –help 命令查看。</p>
<h3 id="11-3-2-使用介绍"><a href="#11-3-2-使用介绍" class="headerlink" title="11.3.2.    使用介绍"></a>11.3.2.    使用介绍</h3><p>创建好主机之后，查看主机</p>
<p>docker-machine ls</p>
<p>NAME   ACTIVE  DRIVER    STATE   URL    SWARM  DOCKER    ERRORS</p>
<p>test   -    virtualbox  Running  tcp://192.168.99.187:2376      v17.10.0-ce</p>
<p>创建主机成功后，可以通过 env 命令来让后续操作对象都是目标主机。</p>
<p>docker-machine env test</p>
<p>后续根据提示在命令行输入命令之后就可以操作 test 主机。</p>
<p>也可以通过 SSH 登录到主机。</p>
<p>docker-machine ssh test</p>
<p>docker@test:~$ docker –version</p>
<p>Docker version 17.10.0-ce, build f4ffd25</p>
<p>连接到主机之后你就可以在其上使用 Docker 了。</p>
<h3 id="11-3-3-官方支持驱动"><a href="#11-3-3-官方支持驱动" class="headerlink" title="11.3.3.    官方支持驱动"></a>11.3.3.    官方支持驱动</h3><p>通过 -d 选项可以选择支持的驱动类型。</p>
<p>l amazonec2</p>
<p>l azure</p>
<p>l digitalocean</p>
<p>l exoscale</p>
<p>l generic</p>
<p>l google</p>
<p>l hyperv</p>
<p>l none</p>
<p>l openstack</p>
<p>l rackspace</p>
<p>l softlayer</p>
<p>l virtualbox</p>
<p>l vmwarevcloudair</p>
<p>l vmwarefusion</p>
<p>l vmwarevsphere</p>
<h3 id="11-3-4-第三方驱动"><a href="#11-3-4-第三方驱动" class="headerlink" title="11.3.4.    第三方驱动"></a>11.3.4.    第三方驱动</h3><p>请到 <a href="https://github.com/docker/docker.github.io/blob/master/machine/AVAILABLE_DRIVER_PLUGINS.md" target="_blank" rel="noopener">第三方驱动列表</a> 查看</p>
<h3 id="11-3-5-操作命令"><a href="#11-3-5-操作命令" class="headerlink" title="11.3.5.    操作命令"></a>11.3.5.    操作命令</h3><p>l active 查看活跃的 Docker 主机</p>
<p>l config 输出连接的配置信息</p>
<p>l create 创建一个 Docker 主机</p>
<p>l env 显示连接到某个主机需要的环境变量</p>
<p>l inspect 输出主机更多信息</p>
<p>l ip 获取主机地址</p>
<p>l kill 停止某个主机</p>
<p>l ls 列出所有管理的主机</p>
<p>l provision 重新设置一个已存在的主机</p>
<p>l regenerate-certs 为某个主机重新生成 TLS 认证信息</p>
<p>l restart 重启主机</p>
<p>l rm 删除某台主机</p>
<p>l ssh SSH 到主机上执行命令</p>
<p>l scp 在主机之间复制文件</p>
<p>l mount 挂载主机目录到本地</p>
<p>l start 启动一个主机</p>
<p>l status 查看主机状态</p>
<p>l stop 停止一个主机</p>
<p>l upgrade 更新主机 Docker 版本为最新</p>
<p>l url 获取主机的 URL</p>
<p>l version 输出 docker-machine 版本信息</p>
<p>l help 输出帮助信息</p>
<p>每个命令，又带有不同的参数，可以通过</p>
<p>docker-machine COMMAND –help</p>
<p>来查看具体的用法。</p>
<h1 id="12-docker-三剑客-swarm"><a href="#12-docker-三剑客-swarm" class="headerlink" title="12.  docker 三剑客 swarm"></a>12.  docker 三剑客 swarm</h1><h2 id="12-1-Docker-Swarm-简介"><a href="#12-1-Docker-Swarm-简介" class="headerlink" title="12.1. Docker Swarm 简介"></a>12.1. Docker Swarm 简介</h2><p>Docker Swarm 是 Docker 官方三剑客项目之一，提供 Docker 容器集群服务，是 Docker 官方对容器云生态进行支持的核心方案。</p>
<p>使用它，用户可以将多个 Docker 主机封装为单个大型的虚拟 Docker 主机，快速打造一套容器云平台。</p>
<p>注意：Docker 1.12.0+ Swarm mode 已经内嵌入 Docker 引擎，成为了 docker 子命令 docker swarm，绝大多数用户已经开始使用 Swarm mode，Docker 引擎 API 已经删除 Docker Swarm。为避免大家混淆旧的 Docker Swarm 与新的 Swarm mode，旧的 Docker Swarm 内容已经删除，请查看 Swarm mode 一节。</p>
<h2 id="12-2-Docker-Swarm-mode"><a href="#12-2-Docker-Swarm-mode" class="headerlink" title="12.2. Docker Swarm mode"></a>12.2. Docker Swarm mode</h2><p>Docker 1.12 Swarm mode 已经内嵌入 Docker 引擎，成为了 docker 子命令 docker swarm。请注意与旧的 Docker Swarm 区分开来。</p>
<p>Swarm mode 内置 kv 存储功能，提供了众多的新特性，比如：具有容错能力的去中心化设计、内置服务发现、负载均衡、路由网格、动态伸缩、滚动更新、安全传输等。使得 Docker 原生的 Swarm 集群具备与 Mesos、Kubernetes 竞争的实力。</p>
<h2 id="12-3-Swarm-mode-基本概念"><a href="#12-3-Swarm-mode-基本概念" class="headerlink" title="12.3. Swarm mode 基本概念"></a>12.3. Swarm mode 基本概念</h2><p>Swarm 是使用 <a href="https://github.com/docker/swarmkit/" target="_blank" rel="noopener">SwarmKit</a> 构建的 Docker 引擎内置（原生）的集群管理和编排工具。</p>
<p>使用 Swarm 集群之前需要了解以下几个概念。</p>
<h3 id="12-3-1-节点"><a href="#12-3-1-节点" class="headerlink" title="12.3.1.    节点"></a>12.3.1.    节点</h3><p>运行 Docker 的主机可以主动初始化一个 Swarm 集群或者加入一个已存在的 Swarm 集群，这样这个运行 Docker 的主机就成为一个 Swarm 集群的节点 (node) 。</p>
<p>节点分为管理 (manager) 节点和工作 (worker) 节点。</p>
<p>管理节点用于 Swarm 集群的管理，docker swarm 命令基本只能在管理节点执行（节点退出集群命令 docker swarm leave 可以在工作节点执行）。一个 Swarm 集群可以有多个管理节点，但只有一个管理节点可以成为 leader，leader 通过 raft 协议实现。</p>
<p>工作节点是任务执行节点，管理节点将服务 (service) 下发至工作节点执行。管理节点默认也作为工作节点。你也可以通过配置让服务只运行在管理节点。</p>
<p>来自 Docker 官网的这张图片形象的展示了集群中管理节点与工作节点的关系。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135124.jpg" alt="IMG_256"></p>
<h3 id="12-3-2-服务和任务"><a href="#12-3-2-服务和任务" class="headerlink" title="12.3.2.    服务和任务"></a>12.3.2.    服务和任务</h3><p>任务 （Task）是 Swarm 中的最小的调度单位，目前来说就是一个单一的容器。</p>
<p>服务 （Services） 是指一组任务的集合，服务定义了任务的属性。服务有两种模式：</p>
<p>replicated services 按照一定规则在各个工作节点上运行指定个数的任务。</p>
<p>global services 每个工作节点上运行一个任务</p>
<p>两种模式通过 docker service create 的 –mode 参数指定。</p>
<p>来自 Docker 官网的这张图片形象的展示了容器、任务、服务的关系。</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135127.jpg" alt="IMG_256"></p>
<h2 id="12-4-创建-Swarm-集群"><a href="#12-4-创建-Swarm-集群" class="headerlink" title="12.4. 创建 Swarm 集群"></a>12.4. 创建 Swarm 集群</h2><p>阅读 基本概念 一节我们知道 Swarm 集群由 管理节点 和 工作节点 组成。本节我们来创建一个包含一个管理节点和两个工作节点的最小 Swarm 集群。</p>
<h3 id="12-4-1-初始化集群"><a href="#12-4-1-初始化集群" class="headerlink" title="12.4.1.    初始化集群"></a>12.4.1.    初始化集群</h3><p>在 Docker Machine 一节中我们了解到 Docker Machine 可以在数秒内创建一个虚拟的 Docker 主机，下面我们使用它来创建三个 Docker 主机，并加入到集群中。</p>
<p>我们首先创建一个 Docker 主机作为管理节点。</p>
<p>docker-machine create -d virtualbox manager</p>
<p>我们使用 docker swarm init 在管理节点初始化一个 Swarm 集群。</p>
<p>docker-machine ssh manager</p>
<p>docker@manager:~$ docker swarm init –advertise-addr 192.168.99.100</p>
<p>Swarm initialized: current node (dxn1zf6l61qsb1josjja83ngz) is now a manager.</p>
<p>To add a worker to this swarm, run the following command:</p>
<p>  docker swarm join \</p>
<p>  –token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</p>
<p>  192.168.99.100:2377</p>
<p>To add a manager to this swarm, run ‘docker swarm join-token manager’ and follow the instructions.</p>
<p>如果你的 Docker 主机有多个网卡，拥有多个 IP，必须使用 –advertise-addr 指定 IP。</p>
<p>执行 docker swarm init 命令的节点自动成为管理节点。</p>
<h3 id="12-4-2-增加工作节点"><a href="#12-4-2-增加工作节点" class="headerlink" title="12.4.2.    增加工作节点"></a>12.4.2.    增加工作节点</h3><p>上一步我们初始化了一个 Swarm 集群，拥有了一个管理节点，下面我们继续创建两个 Docker 主机作为工作节点，并加入到集群中。</p>
<p>$ docker-machine create -d virtualbox worker1</p>
<p>$ docker-machine ssh worker1</p>
<p>docker@worker1:~$ docker swarm join \</p>
<p>  –token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</p>
<p>  192.168.99.100:2377</p>
<p>This node joined a swarm as a worker.   </p>
<p>$ docker-machine create -d virtualbox worker2</p>
<p>$ docker-machine ssh worker2</p>
<p>docker@worker1:~$ docker swarm join \</p>
<p>  –token SWMTKN-1-49nj1cmql0jkz5s954yi3oex3nedyz0fb0xx14ie39trti4wxv-8vxv8rssmk743ojnwacrr2e7c \</p>
<p>  192.168.99.100:2377</p>
<p>This node joined a swarm as a worker.  </p>
<p>注意：一些细心的读者可能通过 docker-machine create –help 查看到 –swarm* 等一系列参数。该参数是用于旧的 Docker Swarm,与本章所讲的 Swarm mode 没有关系。</p>
<h3 id="12-4-3-查看集群"><a href="#12-4-3-查看集群" class="headerlink" title="12.4.3.    查看集群"></a>12.4.3.    查看集群</h3><p>经过上边的两步，我们已经拥有了一个最小的 Swarm 集群，包含一个管理节点和两个工作节点。</p>
<p>在管理节点使用 docker node ls 查看集群。</p>
<p>docker node ls</p>
<p>ID              HOSTNAME STATUS AVAILABILITY MANAGER STATUS</p>
<p>03g1y59jwfg7cf99w4lt0f662  worker2  Ready  Active</p>
<p>9j68exjopxe7wfl6yuxml7a7j  worker1  Ready  Active</p>
<p>dxn1zf6l61qsb1josjja83ngz * manager  Ready  Active    Leader</p>
<h2 id="12-5-Swarm-mode-部署服务"><a href="#12-5-Swarm-mode-部署服务" class="headerlink" title="12.5. Swarm mode 部署服务"></a>12.5. Swarm mode 部署服务</h2><p>我们使用 docker service 命令来管理 Swarm 集群中的服务，该命令只能在管理节点运行。</p>
<h3 id="12-5-1-新建服务"><a href="#12-5-1-新建服务" class="headerlink" title="12.5.1.    新建服务"></a>12.5.1.    新建服务</h3><p>现在我们在上一节创建的 Swarm 集群中运行一个名为 nginx 服务。</p>
<p>docker service create –replicas 3 -p 80:80 –name nginx nginx:1.13.7-alpine</p>
<p>现在我们使用浏览器，输入任意节点 IP ,即可看到 nginx 默认页面。</p>
<h3 id="12-5-2-查看服务"><a href="#12-5-2-查看服务" class="headerlink" title="12.5.2.    查看服务"></a>12.5.2.    查看服务</h3><p>使用 docker service ls 来查看当前 Swarm 集群运行的服务。</p>
<p>docker service ls</p>
<p>ID    NAME   MODE    REPLICAS   IMAGE    PORTS</p>
<p>kc57xffvhul5 nginx  replicated  3/3   nginx:1.13.7-alpine  *:80-&gt;80/tcp</p>
<p>使用 docker service ps 来查看某个服务的详情。</p>
<p>docker service ps nginx</p>
<p>ID  NAME  IMAGE  NODE  DESIRED STATE CURRENT STATE   ERROR   PORTS</p>
<p>pjfzd39buzlt   nginx.1  nginx:1.13.7-alpine  swarm2  Running  Running about a minute ago</p>
<p>hy9eeivdxlaa  nginx.2  nginx:1.13.7-alpine  swarm1   Running Running about a minute ago</p>
<p>36wmpiv7gmfo nginx.3  nginx:1.13.7-alpine  swarm3  Running  Running about a minute ago</p>
<p>使用 docker service logs 来查看某个服务的日志。</p>
<p>docker service logs nginx</p>
<p>nginx.3.36wmpiv7gmfo@swarm3  | 10.255.0.4 - - [25/Nov/2017:02:10:30 +0000] “GET / HTTP/1.1” 200 612 “-“ “Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0” “-“</p>
<p>nginx.3.36wmpiv7gmfo@swarm3  | 10.255.0.4 - - [25/Nov/2017:02:10:30 +0000] “GET /favicon.ico HTTP/1.1” 404 169 “-“ “Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0” “-“</p>
<p>nginx.3.36wmpiv7gmfo@swarm3  | 2017/11/25 02:10:30 [error] 5#5: *1 open() “/usr/share/nginx/html/favicon.ico” failed (2: No such file or directory), client: 10.255.0.4, server: localhost, request: “GET /favicon.ico HTTP/1.1”, host: “192.168.99.102”</p>
<p>nginx.1.pjfzd39buzlt@swarm2  | 10.255.0.2 - - [25/Nov/2017:02:10:26 +0000] “GET / HTTP/1.1” 200 612 “-“ “Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0” “-“</p>
<p>nginx.1.pjfzd39buzlt@swarm2  | 10.255.0.2 - - [25/Nov/2017:02:10:27 +0000] “GET /favicon.ico HTTP/1.1” 404 169 “-“ “Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:58.0) Gecko/20100101 Firefox/58.0” “-“</p>
<p>nginx.1.pjfzd39buzlt@swarm2  | 2017/11/25 02:10:27 [error] 5#5: *1 open() “/usr/share/nginx/html/favicon.ico” failed (2: No such file or directory), client: 10.255.0.2, server: localhost, request: “GET /favicon.ico HTTP/1.1”, host: “192.168.99.101”</p>
<h3 id="12-5-3-删除服务"><a href="#12-5-3-删除服务" class="headerlink" title="12.5.3.    删除服务"></a>12.5.3.    删除服务</h3><p>使用 docker service rm 来从 Swarm 集群移除某个服务。</p>
<p>docker service rm nginx</p>
<h2 id="12-6-使用-compose-文件"><a href="#12-6-使用-compose-文件" class="headerlink" title="12.6. 使用 compose 文件"></a>12.6. 使用 compose 文件</h2><p>正如之前使用 docker-compose.yml 来一次配置、启动多个容器，在 Swarm 集群中也可以使用 compose 文件 （docker-compose.yml） 来配置、启动多个服务。</p>
<p>上一节中，我们使用 docker service create 一次只能部署一个服务，使用 docker-compose.yml 我们可以一次启动多个关联的服务。</p>
<p>我们以在 Swarm 集群中部署 WordPress 为例进行说明。</p>
<p>version: “3”</p>
<p>services:</p>
<p> wordpress:</p>
<p>  image: wordpress</p>
<p>  ports:</p>
<p>   - 80:80</p>
<p>  networks:</p>
<p>   - overlay</p>
<p>  environment:</p>
<p>   WORDPRESS_DB_HOST: db:3306</p>
<p>   WORDPRESS_DB_USER: wordpress</p>
<p>   WORDPRESS_DB_PASSWORD: wordpress</p>
<p>  deploy:</p>
<p>   mode: replicated</p>
<p>   replicas: 3</p>
<p> db:</p>
<p>  image: mysql</p>
<p>  networks:</p>
<p>​    - overlay</p>
<p>  volumes:</p>
<p>   - db-data:/var/lib/mysql</p>
<p>  environment:</p>
<p>   MYSQL_ROOT_PASSWORD: somewordpress</p>
<p>   MYSQL_DATABASE: wordpress</p>
<p>   MYSQL_USER: wordpress</p>
<p>   MYSQL_PASSWORD: wordpress</p>
<p>  deploy:</p>
<p>   placement:</p>
<p>​    constraints: [node.role == manager]</p>
<p> visualizer:</p>
<p>  image: dockersamples/visualizer:stable</p>
<p>  ports:</p>
<p>   - “8080:8080”</p>
<p>  stop_grace_period: 1m30s</p>
<p>  volumes:</p>
<p>   - “/var/run/docker.sock:/var/run/docker.sock”</p>
<p>  deploy:</p>
<p>   placement:</p>
<p>​    constraints: [node.role == manager]</p>
<p>volumes:</p>
<p> db-data:</p>
<p>networks:</p>
<p> overlay:</p>
<p>在 Swarm 集群管理节点新建该文件，其中的 visualizer 服务提供一个可视化页面，我们可以从浏览器中很直观的查看集群中各个服务的运行节点。</p>
<p>在 Swarm 集群中使用 docker-compose.yml 我们用 docker stack 命令，下面我们对该命令进行详细讲解。</p>
<h3 id="12-6-1-部署服务"><a href="#12-6-1-部署服务" class="headerlink" title="12.6.1.    部署服务"></a>12.6.1.    部署服务</h3><p>部署服务使用 docker stack deploy，其中 -c 参数指定 compose 文件名。</p>
<p>docker stack deploy -c docker-compose.yml wordpress</p>
<p>现在我们打开浏览器输入 任一节点IP:8080 即可看到各节点运行状态。如下图所示：</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135135.gif" alt="IMG_256"></p>
<p>在浏览器新的标签页输入 任一节点IP 即可看到 WordPress 安装界面，安装完成之后，输入 任一节点IP 即可看到 WordPress 页面。</p>
<h3 id="12-6-2-查看服务"><a href="#12-6-2-查看服务" class="headerlink" title="12.6.2.    查看服务"></a>12.6.2.    查看服务</h3><p>docker stack ls</p>
<p>NAME        SERVICES</p>
<p>wordpress      3</p>
<h3 id="12-6-3-移除服务"><a href="#12-6-3-移除服务" class="headerlink" title="12.6.3.    移除服务"></a>12.6.3.    移除服务</h3><p>要移除服务，使用 docker stack down</p>
<p>docker stack down wordpress</p>
<p>Removing service wordpress_db</p>
<p>Removing service wordpress_visualizer</p>
<p>Removing service wordpress_wordpress</p>
<p>Removing network wordpress_overlay</p>
<p>Removing network wordpress_default</p>
<p>该命令不会移除服务所使用的 数据卷，如果你想移除数据卷请使用 docker volume rm</p>
<h2 id="12-7-Swarm-mode-管理敏感数据"><a href="#12-7-Swarm-mode-管理敏感数据" class="headerlink" title="12.7. Swarm mode 管理敏感数据"></a>12.7. Swarm mode 管理敏感数据</h2><p>在动态的、大规模的分布式集群上，管理和分发 密码、证书 等敏感信息是极其重要的工作。传统的密钥分发方式（如密钥放入镜像中，设置环境变量，volume 动态挂载等）都存在着潜在的巨大的安全风险。</p>
<p>Docker 目前已经提供了 secrets 管理功能，用户可以在 Swarm 集群中安全地管理密码、密钥证书等敏感数据，并允许在多个 Docker 容器实例之间共享访问指定的敏感数据。</p>
<p>注意： secret 也可以在 Docker Compose 中使用。</p>
<p>我们可以用 docker secret 命令来管理敏感信息。接下来我们在上面章节中创建好的 Swarm 集群中介绍该命令的使用。</p>
<p>这里我们以在 Swarm 集群中部署 mysql 和 wordpress 服务为例。</p>
<h3 id="12-7-1-创建-secret"><a href="#12-7-1-创建-secret" class="headerlink" title="12.7.1.    创建 secret"></a>12.7.1.    创建 secret</h3><p>我们使用 docker secret create 命令以管道符的形式创建 secret</p>
<p>openssl rand -base64 20 | docker secret create mysql_password -</p>
<p>openssl rand -base64 20 | docker secret create mysql_root_password -</p>
<h3 id="12-7-2-查看-secret"><a href="#12-7-2-查看-secret" class="headerlink" title="12.7.2.    查看 secret"></a>12.7.2.    查看 secret</h3><p>使用 docker secret ls 命令来查看 secret</p>
<p>docker secret ls-</p>
<p>ID             NAME         CREATED       UPDATED</p>
<p>l1vinzevzhj4goakjap5ya409  mysql_password    41 seconds ago   41 seconds ago</p>
<p>yvsczlx9votfw3l0nz5rlidig  mysql_root_password  12 seconds ago   12 seconds ago</p>
<h3 id="12-7-3-创建-MySQL-服务"><a href="#12-7-3-创建-MySQL-服务" class="headerlink" title="12.7.3.    创建 MySQL 服务"></a>12.7.3.    创建 MySQL 服务</h3><p>创建服务相关命令已经在前边章节进行了介绍，这里直接列出命令。</p>
<p>docker network create -d overlay mysql_private</p>
<p>docker service create \</p>
<p>   –name mysql \</p>
<p>   –replicas 1 \</p>
<p>   –network mysql_private \</p>
<p>   –mount type=volume,source=mydata,destination=/var/lib/mysql \</p>
<p>   –secret source=mysql_root_password,target=mysql_root_password \</p>
<p>   –secret source=mysql_password,target=mysql_password \</p>
<p>   -e MYSQL_ROOT_PASSWORD_FILE=”/run/secrets/mysql_root_password” \</p>
<p>   -e MYSQL_PASSWORD_FILE=”/run/secrets/mysql_password” \</p>
<p>   -e MYSQL_USER=”wordpress” \</p>
<p>   -e MYSQL_DATABASE=”wordpress” \</p>
<p>   mysql:latest</p>
<p>如果你没有在 target 中显式的指定路径时，secret 默认通过 tmpfs 文件系统挂载到容器的 /run/secrets 目录中。</p>
<p>docker service create \</p>
<p>   –name wordpress \</p>
<p>   –replicas 1 \</p>
<p>   –network mysql_private \</p>
<p>   –publish target=30000,port=80 \</p>
<p>   –mount type=volume,source=wpdata,destination=/var/www/html \</p>
<p>   –secret source=mysql_password,target=wp_db_password,mode=0400 \</p>
<p>   -e WORDPRESS_DB_USER=”wordpress” \</p>
<p>   -e WORDPRESS_DB_PASSWORD_FILE=”/run/secrets/wp_db_password” \</p>
<p>   -e WORDPRESS_DB_HOST=”mysql:3306” \</p>
<p>   -e WORDPRESS_DB_NAME=”wordpress” \</p>
<p>   wordpress:latest</p>
<p>查看服务</p>
<p>docker service ls</p>
<p>ID      NAME  MODE    REPLICAS IMAGE</p>
<p>wvnh0siktqr3 mysql   replicated 1/1    mysql:latest</p>
<p>nzt5xzae4n62 wordpress replicated 1/1    wordpress:latest</p>
<p>现在浏览器访问 IP:30000，即可开始 WordPress 的安装与使用。</p>
<p>通过以上方法，我们没有像以前通过设置环境变量来设置 MySQL 密码， 而是采用 docker secret 来设置密码，防范了密码泄露的风险。</p>
<h2 id="12-8-Swarm-mode-管理配置信息"><a href="#12-8-Swarm-mode-管理配置信息" class="headerlink" title="12.8. Swarm mode 管理配置信息"></a>12.8. Swarm mode 管理配置信息</h2><p>在动态的、大规模的分布式集群上，管理和分发配置文件也是很重要的工作。传统的配置文件分发方式（如配置文件放入镜像中，设置环境变量，volume 动态挂载等）都降低了镜像的通用性。</p>
<p>在 Docker 17.06 以上版本中，Docker 新增了 docker config 子命令来管理集群中的配置信息，以后你无需将配置文件放入镜像或挂载到容器中就可实现对服务的配置。</p>
<p>注意：config 仅能在 Swarm 集群中使用。</p>
<p>这里我们以在 Swarm 集群中部署 redis 服务为例。</p>
<h3 id="12-8-1-创建-config"><a href="#12-8-1-创建-config" class="headerlink" title="12.8.1.    创建 config"></a>12.8.1.    创建 config</h3><p>新建 redis.conf 文件</p>
<p>port 6380</p>
<p>此项配置 Redis 监听 6380 端口</p>
<p>我们使用 docker config create 命令创建 config</p>
<p>docker config create redis.conf redis.conf</p>
<h3 id="12-8-2-查看-config"><a href="#12-8-2-查看-config" class="headerlink" title="12.8.2.    查看 config"></a>12.8.2.    查看 config</h3><p>使用 docker config ls 命令来查看 config</p>
<p>docker config ls</p>
<p>ID             NAME        CREATED       UPDATED</p>
<p>yod8fx8iiqtoo84jgwadp86yk  redis.conf     4 seconds ago    4 seconds ago</p>
<h3 id="12-8-3-创建-redis-服务"><a href="#12-8-3-创建-redis-服务" class="headerlink" title="12.8.3.    创建 redis 服务"></a>12.8.3.    创建 redis 服务</h3><p>docker service create \</p>
<p>   –name redis \</p>
<p>   # –config source=redis.conf,target=/etc/redis.conf \</p>
<p>   –config redis.conf \</p>
<p>   -p 6379:6380 \</p>
<p>   redis:latest \</p>
<p>   redis-server /redis.conf</p>
<p>如果你没有在 target 中显式的指定路径时，默认的 redis.conf 以 tmpfs 文件系统挂载到容器的 /config.conf。</p>
<p>经过测试，redis 可以正常使用。</p>
<p>以前我们通过监听主机目录来配置 Redis，就需要在集群的每个节点放置该文件，如果采用 docker config 来管理服务的配置信息，我们只需在集群中的管理节点创建 config，当部署服务时，集群会自动的将配置文件分发到运行服务的各个节点中，大大降低了配置信息的管理和分发难度。</p>
<h1 id="13-docker-安全"><a href="#13-docker-安全" class="headerlink" title="13.  docker 安全"></a>13.  docker 安全</h1><p>评估 Docker 的安全性时，主要考虑三个方面:</p>
<p>l 由内核的命名空间和控制组机制提供的容器内在安全</p>
<p>l Docker 程序（特别是服务端）本身的抗攻击性</p>
<p>l 内核安全性的加强机制对容器安全性的影响</p>
<h2 id="13-1-内核命名空间"><a href="#13-1-内核命名空间" class="headerlink" title="13.1. 内核命名空间"></a>13.1. 内核命名空间</h2><p>Docker 容器和 LXC 容器很相似，所提供的安全特性也差不多。当用 docker run 启动一个容器时，在后台 Docker 为容器创建了一个独立的命名空间和控制组集合。</p>
<p>命名空间提供了最基础也是最直接的隔离，在容器中运行的进程不会被运行在主机上的进程和其它容器发现和作用。</p>
<p>每个容器都有自己独有的网络栈，意味着它们不能访问其他容器的 sockets 或接口。不过，如果主机系统上做了相应的设置，容器可以像跟主机交互一样的和其他容器交互。当指定公共端口或使用 links 来连接 2 个容器时，容器就可以相互通信了（可以根据配置来限制通信的策略）。</p>
<p>从网络架构的角度来看，所有的容器通过本地主机的网桥接口相互通信，就像物理机器通过物理交换机通信一样。</p>
<p>那么，内核中实现命名空间和私有网络的代码是否足够成熟？</p>
<p>内核命名空间从 2.6.15 版本（2008 年 7 月发布）之后被引入，数年间，这些机制的可靠性在诸多大型生产系统中被实践验证。</p>
<p>实际上，命名空间的想法和设计提出的时间要更早，最初是为了在内核中引入一种机制来实现 OpenVZ 的特性。 而 OpenVZ 项目早在 2005 年就发布了，其设计和实现都已经十分成熟。</p>
<h2 id="13-2-控制组"><a href="#13-2-控制组" class="headerlink" title="13.2. 控制组"></a>13.2. 控制组</h2><p>控制组是 Linux 容器机制的另外一个关键组件，负责实现资源的审计和限制。</p>
<p>它提供了很多有用的特性；以及确保各个容器可以公平地分享主机的内存、CPU、磁盘 IO 等资源；当然，更重要的是，控制组确保了当容器内的资源使用产生压力时不会连累主机系统。</p>
<p>尽管控制组不负责隔离容器之间相互访问、处理数据和进程，它在防止拒绝服务（DDOS）攻击方面是必不可少的。尤其是在多用户的平台（比如公有或私有的 PaaS）上，控制组十分重要。例如，当某些应用程序表现异常的时候，可以保证一致地正常运行和性能。</p>
<p>控制组机制始于 2006 年，内核从 2.6.24 版本开始被引入。</p>
<h2 id="13-3-服务端防护"><a href="#13-3-服务端防护" class="headerlink" title="13.3. 服务端防护"></a>13.3. 服务端防护</h2><p>运行一个容器或应用程序的核心是通过 Docker 服务端。Docker 服务的运行目前需要 root 权限，因此其安全性十分关键。</p>
<p>首先，确保只有可信的用户才可以访问 Docker 服务。Docker 允许用户在主机和容器间共享文件夹，同时不需要限制容器的访问权限，这就容易让容器突破资源限制。例如，恶意用户启动容器的时候将主机的根目录/映射到容器的 /host 目录中，那么容器理论上就可以对主机的文件系统进行任意修改了。这听起来很疯狂？但是事实上几乎所有虚拟化系统都允许类似的资源共享，而没法禁止用户共享主机根文件系统到虚拟机系统。</p>
<p>这将会造成很严重的安全后果。因此，当提供容器创建服务时（例如通过一个 web 服务器），要更加注意进行参数的安全检查，防止恶意的用户用特定参数来创建一些破坏性的容器。</p>
<p>为了加强对服务端的保护，Docker 的 REST API（客户端用来跟服务端通信）在 0.5.2 之后使用本地的 Unix 套接字机制替代了原先绑定在 127.0.0.1 上的 TCP 套接字，因为后者容易遭受跨站脚本攻击。现在用户使用 Unix 权限检查来加强套接字的访问安全。</p>
<p>用户仍可以利用 HTTP 提供 REST API 访问。建议使用安全机制，确保只有可信的网络或 VPN，或证书保护机制（例如受保护的 stunnel 和 ssl 认证）下的访问可以进行。此外，还可以使用 HTTPS 和证书来加强保护。</p>
<p>最近改进的 Linux 命名空间机制将可以实现使用非 root 用户来运行全功能的容器。这将从根本上解决了容器和主机之间共享文件系统而引起的安全问题。</p>
<p>终极目标是改进 2 个重要的安全特性：</p>
<p>l 将容器的 root 用户映射到本地主机上的非 root 用户，减轻容器和主机之间因权限提升而引起的安全问题；</p>
<p>l 允许 Docker 服务端在非 root 权限下运行，利用安全可靠的子进程来代理执行需要特权权限的操作。这些子进程将只允许在限定范围内进行操作，例如仅仅负责虚拟网络设定或文件系统管理、配置操作等。</p>
<p>最后，建议采用专用的服务器来运行 Docker 和相关的管理服务（例如管理服务比如 ssh 监控和进程监控、管理工具 nrpe、collectd 等）。其它的业务服务都放到容器中去运行。</p>
<h2 id="13-4-内核能力机制"><a href="#13-4-内核能力机制" class="headerlink" title="13.4. 内核能力机制"></a>13.4. 内核能力机制</h2><p>能力机制（Capability）是 Linux 内核一个强大的特性，可以提供细粒度的权限访问控制。 Linux 内核自 2.2 版本起就支持能力机制，它将权限划分为更加细粒度的操作能力，既可以作用在进程上，也可以作用在文件上。</p>
<p>例如，一个 Web 服务进程只需要绑定一个低于 1024 的端口的权限，并不需要 root 权限。那么它只需要被授权 net_bind_service 能力即可。此外，还有很多其他的类似能力来避免进程获取 root 权限。</p>
<p>默认情况下，Docker 启动的容器被严格限制只允许使用内核的一部分能力。</p>
<p>使用能力机制对加强 Docker 容器的安全有很多好处。通常，在服务器上会运行一堆需要特权权限的进程，包括有 ssh、cron、syslogd、硬件管理工具模块（例如负载模块）、网络配置工具等等。容器跟这些进程是不同的，因为几乎所有的特权进程都由容器以外的支持系统来进行管理。</p>
<p>l ssh 访问被主机上ssh服务来管理；</p>
<p>l cron 通常应该作为用户进程执行，权限交给使用它服务的应用来处理；</p>
<p>l 日志系统可由 Docker 或第三方服务管理；</p>
<p>l 硬件管理无关紧要，容器中也就无需执行 udevd 以及类似服务；</p>
<p>l 网络管理也都在主机上设置，除非特殊需求，容器不需要对网络进行配置。</p>
<p>从上面的例子可以看出，大部分情况下，容器并不需要“真正的” root 权限，容器只需要少数的能力即可。为了加强安全，容器可以禁用一些没必要的权限。</p>
<p>l 完全禁止任何 mount 操作；</p>
<p>l 禁止直接访问本地主机的套接字；</p>
<p>l 禁止访问一些文件系统的操作，比如创建新的设备、修改文件属性等；</p>
<p>l 禁止模块加载。</p>
<p>这样，就算攻击者在容器中取得了 root 权限，也不能获得本地主机的较高权限，能进行的破坏也有限。</p>
<p>默认情况下，Docker采用白名单机制，禁用必需功能之外的其它权限。 当然，用户也可以根据自身需求来为 Docker 容器启用额外的权限。</p>
<h2 id="13-5-其它安全特性"><a href="#13-5-其它安全特性" class="headerlink" title="13.5. 其它安全特性"></a>13.5. 其它安全特性</h2><p>除了能力机制之外，还可以利用一些现有的安全机制来增强使用 Docker 的安全性，例如 TOMOYO, AppArmor, SELinux, GRSEC 等。</p>
<p>Docker 当前默认只启用了能力机制。用户可以采用多种方案来加强 Docker 主机的安全，例如：</p>
<p>l 在内核中启用 GRSEC 和 PAX，这将增加很多编译和运行时的安全检查；通过地址随机化避免恶意探测等。并且，启用该特性不需要 Docker 进行任何配置。</p>
<p>l 使用一些有增强安全特性的容器模板，比如带 AppArmor 的模板和 Redhat 带 SELinux 策略的模板。这些模板提供了额外的安全特性。</p>
<p>l 用户可以自定义访问控制机制来定制安全策略。</p>
<p>跟其它添加到 Docker 容器的第三方工具一样（比如网络拓扑和文件系统共享），有很多类似的机制，在不改变 Docker 内核情况下就可以加固现有的容器。</p>
<h2 id="13-6-安全总结"><a href="#13-6-安全总结" class="headerlink" title="13.6. 安全总结"></a>13.6. 安全总结</h2><p>总体来看，Docker 容器还是十分安全的，特别是在容器内不使用 root 权限来运行进程的话。</p>
<p>另外，用户可以使用现有工具，比如 Apparmor, SELinux, GRSEC 来增强安全性；甚至自己在内核中实现更复杂的安全机制。</p>
<h1 id="14-docker-底层实现"><a href="#14-docker-底层实现" class="headerlink" title="14.  docker 底层实现"></a>14.  docker 底层实现</h1><p>Docker 底层的核心技术包括 Linux 上的命名空间（Namespaces）、控制组（Control groups）、Union 文件系统（Union file systems）和容器格式（Container format）。</p>
<p>我们知道，传统的虚拟机通过在宿主主机中运行 hypervisor 来模拟一整套完整的硬件环境提供给虚拟机的操作系统。虚拟机系统看到的环境是可限制的，也是彼此隔离的。 这种直接的做法实现了对资源最完整的封装，但很多时候往往意味着系统资源的浪费。 例如，以宿主机和虚拟机系统都为 Linux 系统为例，虚拟机中运行的应用其实可以利用宿主机系统中的运行环境。</p>
<p>我们知道，在操作系统中，包括内核、文件系统、网络、PID、UID、IPC、内存、硬盘、CPU 等等，所有的资源都是应用进程直接共享的。 要想实现虚拟化，除了要实现对内存、CPU、网络IO、硬盘IO、存储空间等的限制外，还要实现文件系统、网络、PID、UID、IPC等等的相互隔离。 前者相对容易实现一些，后者则需要宿主机系统的深入支持。</p>
<p>随着 Linux 系统对于命名空间功能的完善实现，程序员已经可以实现上面的所有需求，让某些进程在彼此隔离的命名空间中运行。大家虽然都共用一个内核和某些运行时环境（例如一些系统命令和系统库），但是彼此却看不到，都以为系统中只有自己的存在。这种机制就是容器（Container），利用命名空间来做权限的隔离控制，利用 cgroups 来做资源分配。</p>
<h2 id="14-1-基本架构"><a href="#14-1-基本架构" class="headerlink" title="14.1. 基本架构"></a>14.1. 基本架构</h2><p>Docker 采用了 C/S 架构，包括客户端和服务端。Docker 守护进程 （Daemon）作为服务端接受来自客户端的请求，并处理这些请求（创建、运行、分发容器）。</p>
<p>客户端和服务端既可以运行在一个机器上，也可通过 socket 或者 RESTful API 来进行通信。</p>
<p>Docker 基本架构</p>
<p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135152.jpg" alt="IMG_256"></p>
<p>Docker 守护进程一般在宿主主机后台运行，等待接收来自客户端的消息。</p>
<p>Docker 客户端则为用户提供一系列可执行命令，用户用这些命令实现跟 Docker 守护进程交互。</p>
<h2 id="14-2-命名空间"><a href="#14-2-命名空间" class="headerlink" title="14.2. 命名空间"></a>14.2. 命名空间</h2><p>命名空间是 Linux 内核一个强大的特性。每个容器都有自己单独的命名空间，运行在其中的应用都像是在独立的操作系统中运行一样。命名空间保证了容器之间彼此互不影响。</p>
<h3 id="14-2-1-pid-命名空间"><a href="#14-2-1-pid-命名空间" class="headerlink" title="14.2.1.    pid 命名空间"></a>14.2.1.    pid 命名空间</h3><p>不同用户的进程就是通过 pid 命名空间隔离开的，且不同命名空间中可以有相同 pid。所有的 LXC 进程在 Docker 中的父进程为Docker进程，每个 LXC 进程具有不同的命名空间。同时由于允许嵌套，因此可以很方便的实现嵌套的 Docker 容器。</p>
<h3 id="14-2-2-net-命名空间"><a href="#14-2-2-net-命名空间" class="headerlink" title="14.2.2.    net 命名空间"></a>14.2.2.    net 命名空间</h3><p>有了 pid 命名空间, 每个命名空间中的 pid 能够相互隔离，但是网络端口还是共享 host 的端口。网络隔离是通过 net 命名空间实现的， 每个 net 命名空间有独立的 网络设备, IP 地址, 路由表, /proc/net 目录。这样每个容器的网络就能隔离开来。Docker 默认采用 veth 的方式，将容器中的虚拟网卡同 host 上的一 个Docker 网桥 docker0 连接在一起。</p>
<h3 id="14-2-3-ipc-命名空间"><a href="#14-2-3-ipc-命名空间" class="headerlink" title="14.2.3.    ipc 命名空间"></a>14.2.3.    ipc 命名空间</h3><p>容器中进程交互还是采用了 Linux 常见的进程间交互方法(interprocess communication - IPC), 包括信号量、消息队列和共享内存等。然而同 VM 不同的是，容器的进程间交互实际上还是 host 上具有相同 pid 命名空间中的进程间交互，因此需要在 IPC 资源申请时加入命名空间信息，每个 IPC 资源有一个唯一的 32 位 id。</p>
<h3 id="14-2-4-mnt-命名空间"><a href="#14-2-4-mnt-命名空间" class="headerlink" title="14.2.4.    mnt 命名空间"></a>14.2.4.    mnt 命名空间</h3><p>类似 chroot，将一个进程放到一个特定的目录执行。mnt 命名空间允许不同命名空间的进程看到的文件结构不同，这样每个命名空间 中的进程所看到的文件目录就被隔离开了。同 chroot 不同，每个命名空间中的容器在 /proc/mounts 的信息只包含所在命名空间的 mount point。</p>
<h3 id="14-2-5-uts-命名空间"><a href="#14-2-5-uts-命名空间" class="headerlink" title="14.2.5.    uts 命名空间"></a>14.2.5.    uts 命名空间</h3><p>UTS(“UNIX Time-sharing System”) 命名空间允许每个容器拥有独立的 hostname 和 domain name, 使其在网络上可以被视作一个独立的节点而非 主机上的一个进程。</p>
<h3 id="14-2-6-user-命名空间"><a href="#14-2-6-user-命名空间" class="headerlink" title="14.2.6.    user 命名空间"></a>14.2.6.    user 命名空间</h3><p>每个容器可以有不同的用户和组 id, 也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户。</p>
<h2 id="14-3-控制组"><a href="#14-3-控制组" class="headerlink" title="14.3. 控制组"></a>14.3. 控制组</h2><p>控制组（<a href="http://en.wikipedia.org/wiki/Cgroups" target="_blank" rel="noopener">cgroups</a>）是 Linux 内核的一个特性，主要用来对共享资源进行隔离、限制、审计等。只有能控制分配到容器的资源，才能避免当多个容器同时运行时的对系统资源的竞争。</p>
<p>控制组技术最早是由 Google 的程序员在 2006 年提出，Linux 内核自 2.6.24 开始支持。</p>
<p>控制组可以提供对容器的内存、CPU、磁盘 IO 等资源的限制和审计管理。</p>
<h2 id="14-4-联合文件系统"><a href="#14-4-联合文件系统" class="headerlink" title="14.4. 联合文件系统"></a>14.4. 联合文件系统</h2><p>联合文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。</p>
<p>联合文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>另外，不同 Docker 容器就可以共享一些基础的文件系统层，同时再加上自己独有的改动层，大大提高了存储的效率。</p>
<p>Docker 中使用的 AUFS（AnotherUnionFS）就是一种联合文件系统。 AUFS 支持为每一个成员目录（类似 Git 的分支）设定只读（readonly）、读写（readwrite）和写出（whiteout-able）权限, 同时 AUFS 里有一个类似分层的概念, 对只读权限的分支可以逻辑上进行增量地修改(不影响只读部分的)。</p>
<p>Docker 目前支持的联合文件系统包括 OverlayFS, AUFS, Btrfs, VFS, ZFS 和 Device Mapper。</p>
<p>各 Linux 发行版 Docker 推荐使用的存储驱动如下表。</p>
<table>
<thead>
<tr>
<th><strong>Linux</strong> <strong>发行版</strong></th>
<th><strong>Docker</strong> <strong>推荐使用的存储驱动</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Docker CE on Ubuntu</td>
<td>aufs, devicemapper, overlay2 (Ubuntu  14.04.4 +, 16.04 +), overlay, zfs, vfs</td>
</tr>
<tr>
<td>Docker CE on Debian</td>
<td>aufs, devicemapper, overlay2 (Debian  Stretch), overlay, vfs</td>
</tr>
<tr>
<td>Docker CE on CentOS</td>
<td>devicemapper, vfs</td>
</tr>
<tr>
<td>Docker CE on Fedora</td>
<td>devicemapper, overlay2 (Fedora 26 +),  overlay (实验性支持), vfs</td>
</tr>
</tbody></table>
<p>在可能的情况下，推荐使用 overlay2 存储驱动，overlay2 是目前 Docker 默认的存储驱动，以前则是 aufs。你可以通过配置来使用以上提到的其他类型的存储驱动。</p>
<h2 id="14-5-容器格式"><a href="#14-5-容器格式" class="headerlink" title="14.5. 容器格式"></a>14.5. 容器格式</h2><p>最初，Docker 采用了 LXC 中的容器格式。从 0.7 版本以后开始去除 LXC，转而使用自行开发的 <a href="https://github.com/docker/libcontainer" target="_blank" rel="noopener">libcontainer</a>，从 1.11 开始，则进一步演进为使用 <a href="https://github.com/opencontainers/runc" target="_blank" rel="noopener">runC</a> 和 <a href="https://containerd.tools/" target="_blank" rel="noopener">containerd</a>。</p>
<p>对更多容器格式的支持，还在进一步的发展中。</p>
<h2 id="14-6-网络"><a href="#14-6-网络" class="headerlink" title="14.6. 网络"></a>14.6. 网络</h2><p>Docker 的网络实现其实就是利用了 Linux 上的网络命名空间和虚拟网络设备（特别是 veth pair）。建议先熟悉了解这两部分的基本概念再阅读本章。</p>
<h3 id="14-6-1-基本原理"><a href="#14-6-1-基本原理" class="headerlink" title="14.6.1.    基本原理"></a>14.6.1.    基本原理</h3><p>首先，要实现网络通信，机器需要至少一个网络接口（物理接口或虚拟接口）来收发数据包；此外，如果不同子网之间要进行通信，需要路由机制。</p>
<p>Docker 中的网络接口默认都是虚拟的接口。虚拟接口的优势之一是转发效率较高。 Linux 通过在内核中进行数据复制来实现虚拟接口之间的数据转发，发送接口的发送缓存中的数据包被直接复制到接收接口的接收缓存中。对于本地系统和容器内系统看来就像是一个正常的以太网卡，只是它不需要真正同外部网络设备通信，速度要快很多。</p>
<p>Docker 容器网络就利用了这项技术。它在本地主机和容器内分别创建一个虚拟接口，并让它们彼此连通（这样的一对接口叫做 veth pair）。</p>
<h3 id="14-6-2-创建网络参数"><a href="#14-6-2-创建网络参数" class="headerlink" title="14.6.2.    创建网络参数"></a>14.6.2.    创建网络参数</h3><p>Docker 创建一个容器的时候，会执行如下操作：</p>
<p>l 创建一对虚拟接口，分别放到本地主机和新容器中；</p>
<p>l 本地主机一端桥接到默认的 docker0 或指定网桥上，并具有一个唯一的名字，如 veth65f9；</p>
<p>l 容器一端放到新容器中，并修改名字作为 eth0，这个接口只在容器的命名空间可见；</p>
<p>l 从网桥可用地址段中获取一个空闲地址分配给容器的 eth0，并配置默认路由到桥接网卡 veth65f9。</p>
<p>完成这些之后，容器就可以使用 eth0 虚拟网卡来连接其他容器和其他网络。</p>
<p>可以在 docker run 的时候通过 –net 参数来指定容器的网络配置，有4个可选值：</p>
<p>l –net=bridge 这个是默认值，连接到默认的网桥。</p>
<p>l –net=host 告诉 Docker 不要将容器网络放到隔离的命名空间中，即不要容器化容器内的网络。此时容器使用本地主机的网络，它拥有完全的本地主机接口访问权限。容器进程可以跟主机其它 root 进程一样可以打开低范围的端口，可以访问本地网络服务比如 D-bus，还可以让容器做一些影响整个主机系统的事情，比如重启主机。因此使用这个选项的时候要非常小心。如果进一步的使用 –privileged=true，容器会被允许直接配置主机的网络堆栈。</p>
<p>l –net=container:NAME_or_ID 让 Docker 将新建容器的进程放到一个已存在容器的网络栈中，新容器进程有自己的文件系统、进程列表和资源限制，但会和已存在的容器共享 IP 地址和端口等网络资源，两者进程可以直接通过 lo 环回接口通信。</p>
<p>l –net=none 让 Docker 将新容器放到隔离的网络栈中，但是不进行网络配置。之后，用户可以自己进行配置。</p>
<h3 id="14-6-3-网络配置细节"><a href="#14-6-3-网络配置细节" class="headerlink" title="14.6.3.    网络配置细节"></a>14.6.3.    网络配置细节</h3><p>用户使用 –net=none 后，可以自行配置网络，让容器达到跟平常一样具有访问网络的权限。通过这个过程，可以了解 Docker 配置网络的细节。</p>
<p>首先，启动一个 /bin/bash 容器，指定 –net=none 参数。</p>
<p>docker run -i -t –rm –net=none base /bin/bash</p>
<p>root@63f36fc01b5f:/#</p>
<p>在本地主机查找容器的进程 id，并为它创建网络命名空间。</p>
<p>docker inspect -f ‘{.State.Pid}’ 63f36fc01b5f</p>
<p>2778</p>
<p>pid=2778</p>
<p>sudo mkdir -p /var/run/netns</p>
<p>sudo ln -s /proc/$pid/ns/net /var/run/netns/$pid</p>
<p>检查桥接网卡的 IP 和子网掩码信息。</p>
<p>ip addr show docker0</p>
<p>21: docker0: …</p>
<p>inet 172.17.42.1/16 scope global docker0</p>
<p>…</p>
<p>创建一对 “veth pair” 接口 A 和 B，绑定 A 到网桥 docker0，并启用它</p>
<p>sudo ip link add A type veth peer name B</p>
<p>sudo brctl addif docker0 A</p>
<p>sudo ip link set A up</p>
<p>将B放到容器的网络命名空间，命名为 eth0，启动它并配置一个可用 IP（桥接网段）和默认网关。</p>
<p>sudo ip link set B netns $pid</p>
<p>sudo ip netns exec $pid ip link set dev B name eth0</p>
<p>sudo ip netns exec $pid ip link set eth0 up</p>
<p>sudo ip netns exec $pid ip addr add 172.17.42.99/16 dev eth0</p>
<p>sudo ip netns exec $pid ip route add default via 172.17.42.1</p>
<p>以上，就是 Docker 配置网络的具体过程。</p>
<p>当容器结束后，Docker 会清空容器，容器内的 eth0 会随网络命名空间一起被清除，A 接口也被自动从 docker0 卸载。</p>
<p>此外，用户可以使用 ip netns exec 命令来在指定网络命名空间中进行配置，从而配置容器内的网络。</p>
<h1 id="15-附录"><a href="#15-附录" class="headerlink" title="15.  附录"></a>15.  附录</h1><h2 id="15-1-Docker-命令查询"><a href="#15-1-Docker-命令查询" class="headerlink" title="15.1. Docker 命令查询"></a>15.1. Docker 命令查询</h2><h3 id="15-1-1-基本语法"><a href="#15-1-1-基本语法" class="headerlink" title="15.1.1.    基本语法"></a>15.1.1.    基本语法</h3><p>Docker 命令有两大类，客户端命令和服务端命令。前者是主要的操作接口，后者用来启动 Docker Daemon。</p>
<p>客户端命令：基本命令格式为 docker [OPTIONS] COMMAND [arg…]；</p>
<p>服务端命令：基本命令格式为 dockerd [OPTIONS]。</p>
<p>可以通过 man docker 或 docker help 来查看这些命令。</p>
<h3 id="15-1-2-客户端命令选项"><a href="#15-1-2-客户端命令选项" class="headerlink" title="15.1.2.    客户端命令选项"></a>15.1.2.    客户端命令选项</h3><p>–config=””：指定客户端配置文件，默认为 <code>/.docker</code>；</p>
<p>-D=true|false：是否使用 debug 模式。默认不开启；</p>
<p>-H, –host=[]：指定命令对应 Docker 守护进程的监听接口，可以为 unix 套接字（unix:///path/to/socket），文件句柄（fd://socketfd）或 tcp 套接字（tcp://[host[:port]]），默认为 unix:///var/run/docker.sock；</p>
<p>-l, –log-level=”debug|info|warn|error|fatal”：指定日志输出级别；</p>
<p>–tls=true|false：是否对 Docker 守护进程启用 TLS 安全机制，默认为否；</p>
<p>–tlscacert= /.docker/ca.pem：TLS CA 签名的可信证书文件路径；</p>
<p>–tlscert= /.docker/cert.pem：TLS 可信证书文件路径；</p>
<p>–tlscert= /.docker/key.pem：TLS 密钥文件路径；</p>
<p>–tlsverify=true|false：启用 TLS 校验，默认为否。</p>
<h3 id="15-1-3-dockerd-命令选项"><a href="#15-1-3-dockerd-命令选项" class="headerlink" title="15.1.3.    dockerd 命令选项"></a>15.1.3.    dockerd 命令选项</h3><p>–api-cors-header=””：CORS 头部域，默认不允许 CORS，要允许任意的跨域访问，可以指定为 “*”；</p>
<p>–authorization-plugin=””：载入认证的插件；</p>
<p>-b=””：将容器挂载到一个已存在的网桥上。指定为 ‘none’ 时则禁用容器的网络，与 –bip 选项互斥；</p>
<p>–bip=””：让动态创建的 docker0 网桥采用给定的 CIDR 地址; 与 -b 选项互斥；</p>
<p>–cgroup-parent=””：指定 cgroup 的父组，默认 fs cgroup 驱动为 <code>/docker</code>，systemd cgroup 驱动为 <code>system.slice</code>；</p>
<p>–cluster-store=””：构成集群（如 Swarm）时，集群键值数据库服务地址；</p>
<p>–cluster-advertise=””：构成集群时，自身的被访问地址，可以为 <code>host:port</code> 或 <code>interface:port</code>；</p>
<p>–cluster-store-opt=””：构成集群时，键值数据库的配置选项；</p>
<p>–config-file=”/etc/docker/daemon.json”：daemon 配置文件路径；</p>
<p>–containerd=””：containerd 文件的路径；</p>
<p>-D, –debug=true|false：是否使用 Debug 模式。缺省为 false；</p>
<p>–default-gateway=””：容器的 IPv4 网关地址，必须在网桥的子网段内；</p>
<p>–default-gateway-v6=””：容器的 IPv6 网关地址；</p>
<p>–default-ulimit=[]：默认的 ulimit 值；</p>
<p>–disable-legacy-registry=true|false：是否允许访问旧版本的镜像仓库服务器；</p>
<p>–dns=””：指定容器使用的 DNS 服务器地址；</p>
<p>–dns-opt=””：DNS 选项；</p>
<p>–dns-search=[]：DNS 搜索域；</p>
<p>–exec-opt=[]：运行时的执行选项；</p>
<p>–exec-root=””：容器执行状态文件的根路径，默认为 <code>/var/run/docker</code>；</p>
<p>–fixed-cidr=””：限定分配 IPv4 地址范围；</p>
<p>–fixed-cidr-v6=””：限定分配 IPv6 地址范围；</p>
<p>-G, –group=””：分配给 unix 套接字的组，默认为 <code>docker</code>；</p>
<p>-g, –graph=””：Docker 运行时的根路径，默认为 <code>/var/lib/docker</code>；</p>
<p>-H, –host=[]：指定命令对应 Docker daemon 的监听接口，可以为 unix 套接字（unix:///path/to/socket），文件句柄（fd://socketfd）或 tcp 套接字（tcp://[host[:port]]），默认为 unix:///var/run/docker.sock；</p>
<p>–icc=true|false：是否启用容器间以及跟 daemon 所在主机的通信。默认为 true。</p>
<p>–insecure-registry=[]：允许访问给定的非安全仓库服务；</p>
<p>–ip=””：绑定容器端口时候的默认 IP 地址。缺省为 0.0.0.0；</p>
<p>–ip-forward=true|false：是否检查启动在 Docker 主机上的启用 IP 转发服务，默认开启。注意关闭该选项将不对系统转发能力进行任何检查修改；</p>
<p>–ip-masq=true|false：是否进行地址伪装，用于容器访问外部网络，默认开启；</p>
<p>–iptables=true|false：是否允许 Docker 添加 iptables 规则。缺省为 true；</p>
<p>–ipv6=true|false：是否启用 IPv6 支持，默认关闭；</p>
<p>-l, –log-level=”debug|info|warn|error|fatal”：指定日志输出级别；</p>
<p>–label=”[]”：添加指定的键值对标注；</p>
<p>–log-driver=”json-file|syslog|journald|gelf|fluentd|awslogs|splunk|etwlogs|gcplogs|none”：指定日志后端驱动，默认为 json-file；</p>
<p>–log-opt=[]：日志后端的选项；</p>
<p>–mtu=VALUE：指定容器网络的 mtu；</p>
<p>-p=””：指定 daemon 的 PID 文件路径。缺省为 <code>/var/run/docker.pid</code>；</p>
<p>–raw-logs：输出原始，未加色彩的日志信息；</p>
<p>–registry-mirror=<scheme>://<host>：指定 <code>docker pull</code> 时使用的注册服务器镜像地址；</p>
<p>-s, –storage-driver=””：指定使用给定的存储后端；</p>
<p>–selinux-enabled=true|false：是否启用 SELinux 支持。缺省值为 false。SELinux 目前尚不支持 overlay 存储驱动；</p>
<p>–storage-opt=[]：驱动后端选项；</p>
<p>–tls=true|false：是否对 Docker daemon 启用 TLS 安全机制，默认为否；</p>
<p>–tlscacert= /.docker/ca.pem：TLS CA 签名的可信证书文件路径；</p>
<p>–tlscert= /.docker/cert.pem：TLS 可信证书文件路径；</p>
<p>–tlscert= /.docker/key.pem：TLS 密钥文件路径；</p>
<p>–tlsverify=true|false：启用 TLS 校验，默认为否；</p>
<p>–userland-proxy=true|false：是否使用用户态代理来实现容器间和出容器的回环通信，默认为 true；</p>
<p>–userns-remap=default|uid:gid|user:group|user|uid：指定容器的用户命名空间，默认是创建新的 UID 和 GID 映射到容器内进程。</p>
<h3 id="15-1-4-客户端命令"><a href="#15-1-4-客户端命令" class="headerlink" title="15.1.4.    客户端命令"></a>15.1.4.    客户端命令</h3><p>可以通过 docker COMMAND –help 来查看这些命令的具体用法。</p>
<p>attach：依附到一个正在运行的容器中；</p>
<p>build：从一个 Dockerfile 创建一个镜像；</p>
<p>commit：从一个容器的修改中创建一个新的镜像；</p>
<p>cp：在容器和本地宿主系统之间复制文件中；</p>
<p>create：创建一个新容器，但并不运行它；</p>
<p>diff：检查一个容器内文件系统的修改，包括修改和增加；</p>
<p>events：从服务端获取实时的事件；</p>
<p>exec：在运行的容器内执行命令；</p>
<p>export：导出容器内容为一个 tar 包；</p>
<p>history：显示一个镜像的历史信息；</p>
<p>images：列出存在的镜像；</p>
<p>import：导入一个文件（典型为 tar 包）路径或目录来创建一个本地镜像；</p>
<p>info：显示一些相关的系统信息；</p>
<p>inspect：显示一个容器的具体配置信息；</p>
<p>kill：关闭一个运行中的容器 (包括进程和所有相关资源)；</p>
<p>load：从一个 tar 包中加载一个镜像；</p>
<p>login：注册或登录到一个 Docker 的仓库服务器；</p>
<p>logout：从 Docker 的仓库服务器登出；</p>
<p>logs：获取容器的 log 信息；</p>
<p>network：管理 Docker 的网络，包括查看、创建、删除、挂载、卸载等；</p>
<p>node：管理 swarm 集群中的节点，包括查看、更新、删除、提升/取消管理节点等；</p>
<p>pause：暂停一个容器中的所有进程；</p>
<p>port：查找一个 nat 到一个私有网口的公共口；</p>
<p>ps：列出主机上的容器；</p>
<p>pull：从一个Docker的仓库服务器下拉一个镜像或仓库；</p>
<p>push：将一个镜像或者仓库推送到一个 Docker 的注册服务器；</p>
<p>rename：重命名一个容器；</p>
<p>restart：重启一个运行中的容器；</p>
<p>rm：删除给定的若干个容器；</p>
<p>rmi：删除给定的若干个镜像；</p>
<p>run：创建一个新容器，并在其中运行给定命令；</p>
<p>save：保存一个镜像为 tar 包文件；</p>
<p>search：在 Docker index 中搜索一个镜像；</p>
<p>service：管理 Docker 所启动的应用服务，包括创建、更新、删除等；</p>
<p>start：启动一个容器；</p>
<p>stats：输出（一个或多个）容器的资源使用统计信息；</p>
<p>stop：终止一个运行中的容器；</p>
<p>swarm：管理 Docker swarm 集群，包括创建、加入、退出、更新等；</p>
<p>tag：为一个镜像打标签；</p>
<p>top：查看一个容器中的正在运行的进程信息；</p>
<p>unpause：将一个容器内所有的进程从暂停状态中恢复；</p>
<p>update：更新指定的若干容器的配置信息；</p>
<p>version：输出 Docker 的版本信息；</p>
<p>volume：管理 Docker volume，包括查看、创建、删除等；</p>
<p>wait：阻塞直到一个容器终止，然后输出它的退出符。</p>
<h3 id="15-1-5-一张图总结-Docker-的命令"><a href="#15-1-5-一张图总结-Docker-的命令" class="headerlink" title="15.1.5.    一张图总结 Docker 的命令"></a>15.1.5.    一张图总结 Docker 的命令</h3><p><img src="https://shuiruoyan-1255322941.cos.ap-guangzhou.myqcloud.com/picgo/20200406135205.jpg" alt="IMG_256"></p>
<h2 id="15-2-Docker-资源链接"><a href="#15-2-Docker-资源链接" class="headerlink" title="15.2. Docker 资源链接"></a>15.2. Docker 资源链接</h2><h3 id="15-2-1-官方网站"><a href="#15-2-1-官方网站" class="headerlink" title="15.2.1.    官方网站"></a>15.2.1.    官方网站</h3><p>l Docker 官方主页：<a href="https://www.docker.com" target="_blank" rel="noopener">https://www.docker.com</a></p>
<p>l Docker 官方博客：<a href="https://blog.docker.com/" target="_blank" rel="noopener">https://blog.docker.com/</a></p>
<p>l Docker 官方文档：<a href="https://docs.docker.com/" target="_blank" rel="noopener">https://docs.docker.com/</a></p>
<p>l Docker Store：<a href="https://store.docker.com" target="_blank" rel="noopener">https://store.docker.com</a></p>
<p>l Docker Cloud：<a href="https://cloud.docker.com" target="_blank" rel="noopener">https://cloud.docker.com</a></p>
<p>l Docker Hub：<a href="https://hub.docker.com" target="_blank" rel="noopener">https://hub.docker.com</a></p>
<p>l Docker 的源代码仓库：<a href="https://github.com/moby/moby" target="_blank" rel="noopener">https://github.com/moby/moby</a></p>
<p>l Docker 发布版本历史：<a href="https://docs.docker.com/release-notes/" target="_blank" rel="noopener">https://docs.docker.com/release-notes/</a></p>
<p>l Docker 常见问题：<a href="https://docs.docker.com/engine/faq/" target="_blank" rel="noopener">https://docs.docker.com/engine/faq/</a></p>
<p>l Docker 远端应用 API：<a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">https://docs.docker.com/develop/sdk/</a></p>
<h3 id="15-2-2-实践参考"><a href="#15-2-2-实践参考" class="headerlink" title="15.2.2.    实践参考"></a>15.2.2.    实践参考</h3><p>l Dockerfile 参考：<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/builder/</a></p>
<p>l Dockerfile 最佳实践：</p>
<p>l <a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/" target="_blank" rel="noopener">https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/</a></p>
<h3 id="15-2-3-技术交流"><a href="#15-2-3-技术交流" class="headerlink" title="15.2.3.    技术交流"></a>15.2.3.    技术交流</h3><p>l Docker 邮件列表： <a href="https://groups.google.com/forum/#!forum/docker-user" target="_blank" rel="noopener">https://groups.google.com/forum/#!forum/docker-user</a></p>
<p>l Docker 的 IRC 频道：<a href="https://chat.freenode.net#docker" target="_blank" rel="noopener">https://chat.freenode.net#docker</a></p>
<p>l Docker 的 Twitter 主页：<a href="https://twitter.com/docker" target="_blank" rel="noopener">https://twitter.com/docker</a></p>
<h3 id="15-2-4-其它"><a href="#15-2-4-其它" class="headerlink" title="15.2.4.    其它"></a>15.2.4.    其它</h3><p>l Docker 的 StackOverflow 问答主页：<a href="https://stackoverflow.com/search?q=docker" target="_blank" rel="noopener">https://stackoverflow.com/search?q=docker</a></p>

        
      </div>
      
      
      
    </div>
    
    
    
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/head.png"
                alt="浩子" />
            
              <p class="site-author-name" itemprop="name">浩子</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">74</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">76</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Docker-简介"><span class="nav-number">1.</span> <span class="nav-text">1. Docker 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-docker-是什么"><span class="nav-number">1.1.</span> <span class="nav-text">1.1.   docker 是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-为什么要使用-docker"><span class="nav-number">1.2.</span> <span class="nav-text">1.2.   为什么要使用 docker</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-docker-基本概念"><span class="nav-number">2.</span> <span class="nav-text">2. docker 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-docker-引擎"><span class="nav-number">2.1.</span> <span class="nav-text">2.1.   docker 引擎</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-docker-系统架构"><span class="nav-number">2.2.</span> <span class="nav-text">2.2.   docker 系统架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-docker-镜像"><span class="nav-number">2.3.</span> <span class="nav-text">2.3.   docker 镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-docker-容器"><span class="nav-number">2.4.</span> <span class="nav-text">2.4.   docker 容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-docker-仓库"><span class="nav-number">2.5.</span> <span class="nav-text">2.5.   docker 仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-公有-Docker-Registry"><span class="nav-number">2.5.1.</span> <span class="nav-text">2.5.1. 公有 Docker Registry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-私有-Docker-Registry"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.5.2. 私有 Docker Registry</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-docker-安装"><span class="nav-number">3.</span> <span class="nav-text">3. docker 安装</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-ubuntu-安装docker"><span class="nav-number">3.1.</span> <span class="nav-text">3.1.   ubuntu 安装docker</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-准备工作"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1. 准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-使用-APT-安装"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2. 使用 APT 安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-使用脚本自动安装"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.1.3. 使用脚本自动安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4-启动-Docker-CE"><span class="nav-number">3.1.4.</span> <span class="nav-text">3.1.4. 启动 Docker CE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-5-建立-docker-用户组"><span class="nav-number">3.1.5.</span> <span class="nav-text">3.1.5. 建立 docker 用户组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-6-测试-Docker-是否安装正确"><span class="nav-number">3.1.6.</span> <span class="nav-text">3.1.6. 测试 Docker 是否安装正确</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-7-镜像加速"><span class="nav-number">3.1.7.</span> <span class="nav-text">3.1.7. 镜像加速</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-8-参考文档"><span class="nav-number">3.1.8.</span> <span class="nav-text">3.1.8. 参考文档</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-centOS-安装-docker"><span class="nav-number">3.2.</span> <span class="nav-text">3.2.   centOS 安装 docker</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-准备工作"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1. 准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-使用-yum-安装"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2. 使用 yum 安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-使用脚本自动安装"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.2.3. 使用脚本自动安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-启动-Docker-CE"><span class="nav-number">3.2.4.</span> <span class="nav-text">3.2.4. 启动 Docker CE</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-5-建立-docker-用户组"><span class="nav-number">3.2.5.</span> <span class="nav-text">3.2.5. 建立 docker 用户组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-6-测试-Docker-是否安装正确"><span class="nav-number">3.2.6.</span> <span class="nav-text">3.2.6. 测试 Docker 是否安装正确</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-7-镜像加速"><span class="nav-number">3.2.7.</span> <span class="nav-text">3.2.7. 镜像加速</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-8-添加内核参数"><span class="nav-number">3.2.8.</span> <span class="nav-text">3.2.8. 添加内核参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-9-参考文档"><span class="nav-number">3.2.9.</span> <span class="nav-text">3.2.9. 参考文档</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-mac-安装-docker"><span class="nav-number">3.3.</span> <span class="nav-text">3.3.   mac 安装 docker</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-系统要求"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1. 系统要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-安装"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2. 安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-运行"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3.3. 运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-镜像加速"><span class="nav-number">3.3.4.</span> <span class="nav-text">3.3.4. 镜像加速</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-windos-安装-docker"><span class="nav-number">3.4.</span> <span class="nav-text">3.4.   windos 安装 docker</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-系统要求"><span class="nav-number">3.4.1.</span> <span class="nav-text">3.4.1. 系统要求</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-安装"><span class="nav-number">3.4.2.</span> <span class="nav-text">3.4.2. 安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3-运行"><span class="nav-number">3.4.3.</span> <span class="nav-text">3.4.3. 运行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-4-镜像加速"><span class="nav-number">3.4.4.</span> <span class="nav-text">3.4.4. 镜像加速</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-镜像加速"><span class="nav-number">3.5.</span> <span class="nav-text">3.5.   镜像加速</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-Ubuntu-14-04、Debian-7-Wheezy"><span class="nav-number">3.5.1.</span> <span class="nav-text">3.5.1. Ubuntu 14.04、Debian 7 Wheezy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-Ubuntu-16-04-、Debian-8-、CentOS-7"><span class="nav-number">3.5.2.</span> <span class="nav-text">3.5.2. Ubuntu 16.04+、Debian 8+、CentOS 7</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-3-Windows-10"><span class="nav-number">3.5.3.</span> <span class="nav-text">3.5.3. Windows 10</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-4-macOS"><span class="nav-number">3.5.4.</span> <span class="nav-text">3.5.4. macOS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-5-检查加速器是否生效"><span class="nav-number">3.5.5.</span> <span class="nav-text">3.5.5. 检查加速器是否生效</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-docker-镜像"><span class="nav-number">4.</span> <span class="nav-text">4. docker 镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-Docker-获取镜像"><span class="nav-number">4.1.</span> <span class="nav-text">4.1.   Docker 获取镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-1-运行"><span class="nav-number">4.1.1.</span> <span class="nav-text">4.1.1. 运行</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-docker-列出镜像"><span class="nav-number">4.2.</span> <span class="nav-text">4.2.   docker 列出镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-镜像体积"><span class="nav-number">4.2.1.</span> <span class="nav-text">4.2.1. 镜像体积</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-虚悬镜像"><span class="nav-number">4.2.2.</span> <span class="nav-text">4.2.2. 虚悬镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-中间层镜像"><span class="nav-number">4.2.3.</span> <span class="nav-text">4.2.3. 中间层镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-4-列出部分镜像"><span class="nav-number">4.2.4.</span> <span class="nav-text">4.2.4. 列出部分镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-5-以特定格式显示"><span class="nav-number">4.2.5.</span> <span class="nav-text">4.2.5. 以特定格式显示</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-docker-删除本地镜像"><span class="nav-number">4.3.</span> <span class="nav-text">4.3.   docker 删除本地镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-用-ID、镜像名、摘要删除镜像"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1. 用 ID、镜像名、摘要删除镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-Untagged-和-Deleted"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2. Untagged 和 Deleted</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-用-docker-image-ls-命令来配合"><span class="nav-number">4.3.3.</span> <span class="nav-text">4.3.3. 用 docker image ls 命令来配合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-4-CentOS-RHEL-的用户需要注意的事项"><span class="nav-number">4.3.4.</span> <span class="nav-text">4.3.4. CentOS&#x2F;RHEL 的用户需要注意的事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-利用-commit-理解镜像构成"><span class="nav-number">4.4.</span> <span class="nav-text">4.4.   利用 commit 理解镜像构成</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">5.</span> <span class="nav-text">Hello, Docker!</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">6.</span> <span class="nav-text">Hello, Docker!</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1-慎用-docker-commit"><span class="nav-number">6.0.1.</span> <span class="nav-text">4.4.1. 慎用 docker commit</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-使用-Dockerfile-定制镜像"><span class="nav-number">6.1.</span> <span class="nav-text">4.5.   使用 Dockerfile 定制镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-1-Dockerfile-定制镜像"><span class="nav-number">6.1.1.</span> <span class="nav-text">4.5.1. Dockerfile 定制镜像</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">7.</span> <span class="nav-text">Hello, Docker!</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-2-FROM-指定基础镜像"><span class="nav-number">7.0.1.</span> <span class="nav-text">4.5.2. FROM 指定基础镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-3-RUN-执行命令"><span class="nav-number">7.0.2.</span> <span class="nav-text">4.5.3. RUN 执行命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#"><span class="nav-number">8.</span> <span class="nav-text">Hello, Docker!</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-4-构建镜像"><span class="nav-number">8.0.1.</span> <span class="nav-text">4.5.4. 构建镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-5-镜像构建上下文（Context）"><span class="nav-number">8.0.2.</span> <span class="nav-text">4.5.5. 镜像构建上下文（Context）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-6-其它-docker-build-的用法"><span class="nav-number">8.0.3.</span> <span class="nav-text">4.5.6. 其它 docker build 的用法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-6-1-直接用-Git-repo-进行构建"><span class="nav-number">8.0.3.1.</span> <span class="nav-text">4.5.6.1.   直接用 Git repo 进行构建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-6-2-用给定的-tar-压缩包构建"><span class="nav-number">8.0.3.2.</span> <span class="nav-text">4.5.6.2.   用给定的 tar 压缩包构建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-6-3-从标准输入中读取-Dockerfile-进行构建"><span class="nav-number">8.0.3.3.</span> <span class="nav-text">4.5.6.3.   从标准输入中读取 Dockerfile 进行构建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-6-4-从标准输入中读取上下文压缩包进行构建"><span class="nav-number">8.0.3.4.</span> <span class="nav-text">4.5.6.4.   从标准输入中读取上下文压缩包进行构建</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-Dockerfile-指令详解"><span class="nav-number">8.1.</span> <span class="nav-text">4.6.   Dockerfile 指令详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-1-COPY-复制文件"><span class="nav-number">8.1.1.</span> <span class="nav-text">4.6.1. COPY 复制文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-2-ADD-更高级的复制文件"><span class="nav-number">8.1.2.</span> <span class="nav-text">4.6.2. ADD 更高级的复制文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-3-CMD-容器启动命令"><span class="nav-number">8.1.3.</span> <span class="nav-text">4.6.3. CMD 容器启动命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-4-ENTRYPOINT-入口点"><span class="nav-number">8.1.4.</span> <span class="nav-text">4.6.4. ENTRYPOINT 入口点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-5-ENV-设置环境变量"><span class="nav-number">8.1.5.</span> <span class="nav-text">4.6.5. ENV 设置环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-6-ARG-构建参数"><span class="nav-number">8.1.6.</span> <span class="nav-text">4.6.6. ARG 构建参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-7-VOLUME-定义匿名卷"><span class="nav-number">8.1.7.</span> <span class="nav-text">4.6.7. VOLUME 定义匿名卷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-8-EXPOSE-暴露端口"><span class="nav-number">8.1.8.</span> <span class="nav-text">4.6.8. EXPOSE 暴露端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-9-WORKDIR-指定工作目录"><span class="nav-number">8.1.9.</span> <span class="nav-text">4.6.9. WORKDIR 指定工作目录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-10-USER-指定当前用户"><span class="nav-number">8.1.10.</span> <span class="nav-text">4.6.10.    USER 指定当前用户</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-11-HEALTHCHECK-健康检查"><span class="nav-number">8.1.11.</span> <span class="nav-text">4.6.11.    HEALTHCHECK 健康检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-12-ONBUILD-为他人作嫁衣"><span class="nav-number">8.1.12.</span> <span class="nav-text">4.6.12.    ONBUILD 为他人作嫁衣</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-13-参考文档"><span class="nav-number">8.1.13.</span> <span class="nav-text">4.6.13.    参考文档</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7-Dockerfile-多阶段构建"><span class="nav-number">8.2.</span> <span class="nav-text">4.7.   Dockerfile 多阶段构建</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-1-之前的做法"><span class="nav-number">8.2.1.</span> <span class="nav-text">4.7.1. 之前的做法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-1-1-全部放入一个-Dockerfile"><span class="nav-number">8.2.1.1.</span> <span class="nav-text">4.7.1.1.   全部放入一个 Dockerfile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-1-2-分散到多个-Dockerfile"><span class="nav-number">8.2.1.2.</span> <span class="nav-text">4.7.1.2.   分散到多个 Dockerfile</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-2-使用多阶段构建"><span class="nav-number">8.2.2.</span> <span class="nav-text">4.7.2. 使用多阶段构建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-8-其他制作镜像方式"><span class="nav-number">8.3.</span> <span class="nav-text">4.8.   其他制作镜像方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-1-从-rootfs-压缩包导入"><span class="nav-number">8.3.1.</span> <span class="nav-text">4.8.1. 从 rootfs 压缩包导入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-8-2-docker-save-和-docker-load"><span class="nav-number">8.3.2.</span> <span class="nav-text">4.8.2. docker save 和 docker load</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-9-镜像的实现原理"><span class="nav-number">8.4.</span> <span class="nav-text">4.9.   镜像的实现原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-docker-容器"><span class="nav-number">9.</span> <span class="nav-text">5. docker 容器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-启动容器"><span class="nav-number">9.1.</span> <span class="nav-text">5.1.   启动容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-新建并启动"><span class="nav-number">9.1.1.</span> <span class="nav-text">5.1.1. 新建并启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-启动已终止容器"><span class="nav-number">9.1.2.</span> <span class="nav-text">5.1.2. 启动已终止容器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-守护状态运行"><span class="nav-number">9.2.</span> <span class="nav-text">5.2.   守护状态运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-终止容器"><span class="nav-number">9.3.</span> <span class="nav-text">5.3.   终止容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-进入容器"><span class="nav-number">9.4.</span> <span class="nav-text">5.4.   进入容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-1-attach-命令"><span class="nav-number">9.4.1.</span> <span class="nav-text">5.4.1. attach 命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-2-exec-命令"><span class="nav-number">9.4.2.</span> <span class="nav-text">5.4.2. exec 命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-导出和导入容器"><span class="nav-number">9.5.</span> <span class="nav-text">5.5.   导出和导入容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-1-导出容器"><span class="nav-number">9.5.1.</span> <span class="nav-text">5.5.1. 导出容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-2-导入容器快照"><span class="nav-number">9.5.2.</span> <span class="nav-text">5.5.2. 导入容器快照</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-删除容器"><span class="nav-number">9.6.</span> <span class="nav-text">5.6.   删除容器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-docker-仓库"><span class="nav-number">10.</span> <span class="nav-text">6. docker 仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-docker-hub"><span class="nav-number">10.1.</span> <span class="nav-text">6.1.   docker hub</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-注册"><span class="nav-number">10.1.1.</span> <span class="nav-text">6.1.1. 注册</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-登录"><span class="nav-number">10.1.2.</span> <span class="nav-text">6.1.2. 登录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-3-拉取镜像"><span class="nav-number">10.1.3.</span> <span class="nav-text">6.1.3. 拉取镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-4-推送镜像"><span class="nav-number">10.1.4.</span> <span class="nav-text">6.1.4. 推送镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-5-自动创建"><span class="nav-number">10.1.5.</span> <span class="nav-text">6.1.5. 自动创建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-docker-私有仓库"><span class="nav-number">10.2.</span> <span class="nav-text">6.2.   docker 私有仓库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-安装运行-docker-registry"><span class="nav-number">10.2.1.</span> <span class="nav-text">6.2.1. 安装运行 docker-registry</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-在私有仓库上传、搜索、下载镜像"><span class="nav-number">10.2.2.</span> <span class="nav-text">6.2.2. 在私有仓库上传、搜索、下载镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3-注意事项"><span class="nav-number">10.2.3.</span> <span class="nav-text">6.2.3. 注意事项</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-3-1-Ubuntu-14-04-Debian-7-Wheezy"><span class="nav-number">10.2.3.1.</span> <span class="nav-text">6.2.3.1.   Ubuntu 14.04, Debian 7 Wheezy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-3-2-Ubuntu-16-04-Debian-8-centos-7"><span class="nav-number">10.2.3.2.</span> <span class="nav-text">6.2.3.2.   Ubuntu 16.04+, Debian 8+, centos 7</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-4-其他"><span class="nav-number">10.2.4.</span> <span class="nav-text">6.2.4. 其他</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-5-docker-registry-配置证书"><span class="nav-number">10.2.5.</span> <span class="nav-text">6.2.5. docker registry 配置证书</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-5-1-准备站点证书"><span class="nav-number">10.2.5.1.</span> <span class="nav-text">6.2.5.1.   准备站点证书</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-5-2-配置私有仓库"><span class="nav-number">10.2.5.2.</span> <span class="nav-text">6.2.5.2.   配置私有仓库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-5-3-生成-http-认证文件"><span class="nav-number">10.2.5.3.</span> <span class="nav-text">6.2.5.3.   生成 http 认证文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-5-4-编辑-docker-compose-yml"><span class="nav-number">10.2.5.4.</span> <span class="nav-text">6.2.5.4.   编辑 docker-compose.yml</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-5-5-修改-hosts"><span class="nav-number">10.2.5.5.</span> <span class="nav-text">6.2.5.5.   修改 hosts</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-5-6-启动"><span class="nav-number">10.2.5.6.</span> <span class="nav-text">6.2.5.6.   启动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-5-7-测试私有仓库功能"><span class="nav-number">10.2.5.7.</span> <span class="nav-text">6.2.5.7.   测试私有仓库功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-5-8-注意事项"><span class="nav-number">10.2.5.8.</span> <span class="nav-text">6.2.5.8.   注意事项</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-docker-企业级仓库-Harbor"><span class="nav-number">10.3.</span> <span class="nav-text">6.3.   docker 企业级仓库 Harbor</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-docker-数据管理"><span class="nav-number">11.</span> <span class="nav-text">7. docker 数据管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-docker-数据卷"><span class="nav-number">11.1.</span> <span class="nav-text">7.1.   docker 数据卷</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-1-选择-v-还是-–mount-参数"><span class="nav-number">11.1.1.</span> <span class="nav-text">7.1.1. 选择 -v 还是 -–mount 参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-2-创建一个数据卷"><span class="nav-number">11.1.2.</span> <span class="nav-text">7.1.2. 创建一个数据卷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-3-启动一个挂载数据卷的容器"><span class="nav-number">11.1.3.</span> <span class="nav-text">7.1.3. 启动一个挂载数据卷的容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-4-查看数据卷的具体信息"><span class="nav-number">11.1.4.</span> <span class="nav-text">7.1.4. 查看数据卷的具体信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-5-删除数据卷"><span class="nav-number">11.1.5.</span> <span class="nav-text">7.1.5. 删除数据卷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-监听主机目录"><span class="nav-number">11.2.</span> <span class="nav-text">7.2.   监听主机目录</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-v-还是-–mount-参数"><span class="nav-number">11.2.1.</span> <span class="nav-text">7.2.1. -v 还是 -–mount 参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-挂载一个主机目录作为数据卷"><span class="nav-number">11.2.2.</span> <span class="nav-text">7.2.2. 挂载一个主机目录作为数据卷</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-3-查看数据卷的具体信息"><span class="nav-number">11.2.3.</span> <span class="nav-text">7.2.3. 查看数据卷的具体信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-4-挂载一个本地主机文件作为数据卷"><span class="nav-number">11.2.4.</span> <span class="nav-text">7.2.4. 挂载一个本地主机文件作为数据卷</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#8-docker-网络配置"><span class="nav-number">12.</span> <span class="nav-text">8. docker 网络配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-Docker-外部访问容器"><span class="nav-number">12.1.</span> <span class="nav-text">8.1.   Docker 外部访问容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-1-映射所有接口地址"><span class="nav-number">12.1.1.</span> <span class="nav-text">8.1.1. 映射所有接口地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-2-映射到指定地址的指定端口"><span class="nav-number">12.1.2.</span> <span class="nav-text">8.1.2. 映射到指定地址的指定端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-3-映射到指定地址的任意端口"><span class="nav-number">12.1.3.</span> <span class="nav-text">8.1.3. 映射到指定地址的任意端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-4-查看映射端口配置"><span class="nav-number">12.1.4.</span> <span class="nav-text">8.1.4. 查看映射端口配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-Docker-容器互连"><span class="nav-number">12.2.</span> <span class="nav-text">8.2.   Docker 容器互连</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-1-新建网络"><span class="nav-number">12.2.1.</span> <span class="nav-text">8.2.1. 新建网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-2-连接容器"><span class="nav-number">12.2.2.</span> <span class="nav-text">8.2.2. 连接容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-3-Docker-Compose"><span class="nav-number">12.2.3.</span> <span class="nav-text">8.2.3. Docker Compose</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-Docker-配置-DNS"><span class="nav-number">12.3.</span> <span class="nav-text">8.3.   Docker 配置 DNS</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#9-docker-高级网络配置"><span class="nav-number">13.</span> <span class="nav-text">9. docker 高级网络配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-1-快速配置指南"><span class="nav-number">13.1.</span> <span class="nav-text">9.1.   快速配置指南</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-2-容器访问控制"><span class="nav-number">13.2.</span> <span class="nav-text">9.2.   容器访问控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-1-容器访问外部网络"><span class="nav-number">13.2.1.</span> <span class="nav-text">9.2.1. 容器访问外部网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-2-容器之间访问"><span class="nav-number">13.2.2.</span> <span class="nav-text">9.2.2. 容器之间访问</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-3-端口映射实现"><span class="nav-number">13.3.</span> <span class="nav-text">9.3.   端口映射实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-1-容器访问外部实现"><span class="nav-number">13.3.1.</span> <span class="nav-text">9.3.1. 容器访问外部实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-3-2-外部访问容器实现"><span class="nav-number">13.3.2.</span> <span class="nav-text">9.3.2. 外部访问容器实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-4-配置-docker0-网桥"><span class="nav-number">13.4.</span> <span class="nav-text">9.4.   配置 docker0 网桥</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-5-自定义网桥"><span class="nav-number">13.5.</span> <span class="nav-text">9.5.   自定义网桥</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-6-工具和示例"><span class="nav-number">13.6.</span> <span class="nav-text">9.6.   工具和示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-6-1-pipework"><span class="nav-number">13.6.1.</span> <span class="nav-text">9.6.1. pipework</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-6-2-playground"><span class="nav-number">13.6.2.</span> <span class="nav-text">9.6.2. playground</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-7-编辑网络配置文件"><span class="nav-number">13.7.</span> <span class="nav-text">9.7.   编辑网络配置文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-8-实例：创建一个点到点连接"><span class="nav-number">13.8.</span> <span class="nav-text">9.8.   实例：创建一个点到点连接</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#10-docker-三剑客-compose"><span class="nav-number">14.</span> <span class="nav-text">10.  docker 三剑客 compose</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-docker-compose-简介"><span class="nav-number">14.1.</span> <span class="nav-text">10.1. docker compose 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-docker-compose-安装和卸载"><span class="nav-number">14.2.</span> <span class="nav-text">10.2. docker compose 安装和卸载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-1-二进制包"><span class="nav-number">14.2.1.</span> <span class="nav-text">10.2.1.    二进制包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-2-PIP-安装"><span class="nav-number">14.2.2.</span> <span class="nav-text">10.2.2.    PIP 安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-3-bash-补全命令"><span class="nav-number">14.2.3.</span> <span class="nav-text">10.2.3.    bash 补全命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-4-容器中执行"><span class="nav-number">14.2.4.</span> <span class="nav-text">10.2.4.    容器中执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-5-卸载"><span class="nav-number">14.2.5.</span> <span class="nav-text">10.2.5.    卸载</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-3-docker-compose-使用"><span class="nav-number">14.3.</span> <span class="nav-text">10.3. docker compose 使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-1-术语"><span class="nav-number">14.3.1.</span> <span class="nav-text">10.3.1.    术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-2-场景"><span class="nav-number">14.3.2.</span> <span class="nav-text">10.3.2.    场景</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-4-docker-compose-命令说明"><span class="nav-number">14.4.</span> <span class="nav-text">10.4. docker compose 命令说明</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-1-命令对象与格式"><span class="nav-number">14.4.1.</span> <span class="nav-text">10.4.1.    命令对象与格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-2-命令选项"><span class="nav-number">14.4.2.</span> <span class="nav-text">10.4.2.    命令选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-4-3-命令使用说明"><span class="nav-number">14.4.3.</span> <span class="nav-text">10.4.3.    命令使用说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-1-build"><span class="nav-number">14.4.3.1.</span> <span class="nav-text">10.4.3.1. build</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-2-config"><span class="nav-number">14.4.3.2.</span> <span class="nav-text">10.4.3.2. config</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-3-down"><span class="nav-number">14.4.3.3.</span> <span class="nav-text">10.4.3.3. down</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-4-exec"><span class="nav-number">14.4.3.4.</span> <span class="nav-text">10.4.3.4. exec</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-5-help"><span class="nav-number">14.4.3.5.</span> <span class="nav-text">10.4.3.5. help</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-6-images"><span class="nav-number">14.4.3.6.</span> <span class="nav-text">10.4.3.6. images</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-7-kill"><span class="nav-number">14.4.3.7.</span> <span class="nav-text">10.4.3.7. kill</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-8-logs"><span class="nav-number">14.4.3.8.</span> <span class="nav-text">10.4.3.8. logs</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-9-pause"><span class="nav-number">14.4.3.9.</span> <span class="nav-text">10.4.3.9. pause</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-10-port"><span class="nav-number">14.4.3.10.</span> <span class="nav-text">10.4.3.10.    port</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-11-ps"><span class="nav-number">14.4.3.11.</span> <span class="nav-text">10.4.3.11.    ps</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-12-pull"><span class="nav-number">14.4.3.12.</span> <span class="nav-text">10.4.3.12.    pull</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-13-push"><span class="nav-number">14.4.3.13.</span> <span class="nav-text">10.4.3.13.    push</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-14-restart"><span class="nav-number">14.4.3.14.</span> <span class="nav-text">10.4.3.14.    restart</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-15-rm"><span class="nav-number">14.4.3.15.</span> <span class="nav-text">10.4.3.15.    rm</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-16-run"><span class="nav-number">14.4.3.16.</span> <span class="nav-text">10.4.3.16.    run</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-17-scale"><span class="nav-number">14.4.3.17.</span> <span class="nav-text">10.4.3.17.    scale</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-18-start"><span class="nav-number">14.4.3.18.</span> <span class="nav-text">10.4.3.18.    start</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-19-stop"><span class="nav-number">14.4.3.19.</span> <span class="nav-text">10.4.3.19.    stop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-20-top"><span class="nav-number">14.4.3.20.</span> <span class="nav-text">10.4.3.20.    top</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-21-unpause"><span class="nav-number">14.4.3.21.</span> <span class="nav-text">10.4.3.21.    unpause</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-22-up"><span class="nav-number">14.4.3.22.</span> <span class="nav-text">10.4.3.22.    up</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-4-3-23-version"><span class="nav-number">14.4.3.23.</span> <span class="nav-text">10.4.3.23.    version</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-5-docker-compose-模板文件"><span class="nav-number">14.5.</span> <span class="nav-text">10.5. docker compose 模板文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-1-build"><span class="nav-number">14.5.1.</span> <span class="nav-text">10.5.1.    build</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-2-cap-add-cap-drop"><span class="nav-number">14.5.2.</span> <span class="nav-text">10.5.2.    cap_add, cap_drop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-3-command"><span class="nav-number">14.5.3.</span> <span class="nav-text">10.5.3.    command</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-4-configs"><span class="nav-number">14.5.4.</span> <span class="nav-text">10.5.4.    configs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-5-cgroup-parent"><span class="nav-number">14.5.5.</span> <span class="nav-text">10.5.5.    cgroup_parent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-6-container-name"><span class="nav-number">14.5.6.</span> <span class="nav-text">10.5.6.    container_name</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-7-deploy"><span class="nav-number">14.5.7.</span> <span class="nav-text">10.5.7.    deploy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-8-devices"><span class="nav-number">14.5.8.</span> <span class="nav-text">10.5.8.    devices</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-9-depends-on"><span class="nav-number">14.5.9.</span> <span class="nav-text">10.5.9.    depends_on</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-10-dns"><span class="nav-number">14.5.10.</span> <span class="nav-text">10.5.10.  dns</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-11-dns-search"><span class="nav-number">14.5.11.</span> <span class="nav-text">10.5.11.  dns_search</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-12-tmpfs"><span class="nav-number">14.5.12.</span> <span class="nav-text">10.5.12.  tmpfs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-13-env-file"><span class="nav-number">14.5.13.</span> <span class="nav-text">10.5.13.  env_file</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-14-environment"><span class="nav-number">14.5.14.</span> <span class="nav-text">10.5.14.  environment</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-15-expose"><span class="nav-number">14.5.15.</span> <span class="nav-text">10.5.15.  expose</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-16-external-links"><span class="nav-number">14.5.16.</span> <span class="nav-text">10.5.16.  external_links</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-17-extra-hosts"><span class="nav-number">14.5.17.</span> <span class="nav-text">10.5.17.  extra_hosts</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-18-healthcheck"><span class="nav-number">14.5.18.</span> <span class="nav-text">10.5.18.  healthcheck</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-19-image"><span class="nav-number">14.5.19.</span> <span class="nav-text">10.5.19.  image</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-20-labels"><span class="nav-number">14.5.20.</span> <span class="nav-text">10.5.20.  labels</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-21-links"><span class="nav-number">14.5.21.</span> <span class="nav-text">10.5.21.  links</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-22-logging"><span class="nav-number">14.5.22.</span> <span class="nav-text">10.5.22.  logging</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-23-network-mode"><span class="nav-number">14.5.23.</span> <span class="nav-text">10.5.23.  network_mode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-24-networks"><span class="nav-number">14.5.24.</span> <span class="nav-text">10.5.24.  networks</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-25-pid"><span class="nav-number">14.5.25.</span> <span class="nav-text">10.5.25.  pid</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-26-ports"><span class="nav-number">14.5.26.</span> <span class="nav-text">10.5.26.  ports</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-27-secrets"><span class="nav-number">14.5.27.</span> <span class="nav-text">10.5.27.  secrets</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-28-security-opt"><span class="nav-number">14.5.28.</span> <span class="nav-text">10.5.28.  security_opt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-29-stop-signal"><span class="nav-number">14.5.29.</span> <span class="nav-text">10.5.29.  stop_signal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-30-sysctls"><span class="nav-number">14.5.30.</span> <span class="nav-text">10.5.30.  sysctls</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-31-ulimits"><span class="nav-number">14.5.31.</span> <span class="nav-text">10.5.31.  ulimits</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-32-volumes"><span class="nav-number">14.5.32.</span> <span class="nav-text">10.5.32.  volumes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-33-其它指令"><span class="nav-number">14.5.33.</span> <span class="nav-text">10.5.33.  其它指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-5-34-读取变量"><span class="nav-number">14.5.34.</span> <span class="nav-text">10.5.34.  读取变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-6-docker-compose-实战-dubbo-admin"><span class="nav-number">14.6.</span> <span class="nav-text">10.6. docker compose 实战 dubbo-admin</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-6-1-创建空文件夹"><span class="nav-number">14.6.1.</span> <span class="nav-text">10.6.1.    创建空文件夹</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-6-2-创建-docker-compose-yml-文件"><span class="nav-number">14.6.2.</span> <span class="nav-text">10.6.2.    创建 docker-compose.yml 文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-6-3-构建并运行项目"><span class="nav-number">14.6.3.</span> <span class="nav-text">10.6.3.    构建并运行项目</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#11-docker-三剑客-machine"><span class="nav-number">15.</span> <span class="nav-text">11.  docker 三剑客 machine</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#11-1-Docker-Machine-简介"><span class="nav-number">15.1.</span> <span class="nav-text">11.1. Docker Machine 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-2-Docker-Machine-安装"><span class="nav-number">15.2.</span> <span class="nav-text">11.2. Docker Machine 安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-1-macOS、Windows"><span class="nav-number">15.2.1.</span> <span class="nav-text">11.2.1.    macOS、Windows</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-2-Linux"><span class="nav-number">15.2.2.</span> <span class="nav-text">11.2.2.    Linux</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-3-Docker-Machine-使用"><span class="nav-number">15.3.</span> <span class="nav-text">11.3. Docker Machine 使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-1-创建本地主机实例"><span class="nav-number">15.3.1.</span> <span class="nav-text">11.3.1.    创建本地主机实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-2-使用介绍"><span class="nav-number">15.3.2.</span> <span class="nav-text">11.3.2.    使用介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-3-官方支持驱动"><span class="nav-number">15.3.3.</span> <span class="nav-text">11.3.3.    官方支持驱动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-4-第三方驱动"><span class="nav-number">15.3.4.</span> <span class="nav-text">11.3.4.    第三方驱动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-5-操作命令"><span class="nav-number">15.3.5.</span> <span class="nav-text">11.3.5.    操作命令</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#12-docker-三剑客-swarm"><span class="nav-number">16.</span> <span class="nav-text">12.  docker 三剑客 swarm</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#12-1-Docker-Swarm-简介"><span class="nav-number">16.1.</span> <span class="nav-text">12.1. Docker Swarm 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-2-Docker-Swarm-mode"><span class="nav-number">16.2.</span> <span class="nav-text">12.2. Docker Swarm mode</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-3-Swarm-mode-基本概念"><span class="nav-number">16.3.</span> <span class="nav-text">12.3. Swarm mode 基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-1-节点"><span class="nav-number">16.3.1.</span> <span class="nav-text">12.3.1.    节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-3-2-服务和任务"><span class="nav-number">16.3.2.</span> <span class="nav-text">12.3.2.    服务和任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-4-创建-Swarm-集群"><span class="nav-number">16.4.</span> <span class="nav-text">12.4. 创建 Swarm 集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-4-1-初始化集群"><span class="nav-number">16.4.1.</span> <span class="nav-text">12.4.1.    初始化集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-4-2-增加工作节点"><span class="nav-number">16.4.2.</span> <span class="nav-text">12.4.2.    增加工作节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-4-3-查看集群"><span class="nav-number">16.4.3.</span> <span class="nav-text">12.4.3.    查看集群</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-5-Swarm-mode-部署服务"><span class="nav-number">16.5.</span> <span class="nav-text">12.5. Swarm mode 部署服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-5-1-新建服务"><span class="nav-number">16.5.1.</span> <span class="nav-text">12.5.1.    新建服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-5-2-查看服务"><span class="nav-number">16.5.2.</span> <span class="nav-text">12.5.2.    查看服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-5-3-删除服务"><span class="nav-number">16.5.3.</span> <span class="nav-text">12.5.3.    删除服务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-6-使用-compose-文件"><span class="nav-number">16.6.</span> <span class="nav-text">12.6. 使用 compose 文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-6-1-部署服务"><span class="nav-number">16.6.1.</span> <span class="nav-text">12.6.1.    部署服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-6-2-查看服务"><span class="nav-number">16.6.2.</span> <span class="nav-text">12.6.2.    查看服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-6-3-移除服务"><span class="nav-number">16.6.3.</span> <span class="nav-text">12.6.3.    移除服务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-7-Swarm-mode-管理敏感数据"><span class="nav-number">16.7.</span> <span class="nav-text">12.7. Swarm mode 管理敏感数据</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-7-1-创建-secret"><span class="nav-number">16.7.1.</span> <span class="nav-text">12.7.1.    创建 secret</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-7-2-查看-secret"><span class="nav-number">16.7.2.</span> <span class="nav-text">12.7.2.    查看 secret</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-7-3-创建-MySQL-服务"><span class="nav-number">16.7.3.</span> <span class="nav-text">12.7.3.    创建 MySQL 服务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-8-Swarm-mode-管理配置信息"><span class="nav-number">16.8.</span> <span class="nav-text">12.8. Swarm mode 管理配置信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#12-8-1-创建-config"><span class="nav-number">16.8.1.</span> <span class="nav-text">12.8.1.    创建 config</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-8-2-查看-config"><span class="nav-number">16.8.2.</span> <span class="nav-text">12.8.2.    查看 config</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-8-3-创建-redis-服务"><span class="nav-number">16.8.3.</span> <span class="nav-text">12.8.3.    创建 redis 服务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#13-docker-安全"><span class="nav-number">17.</span> <span class="nav-text">13.  docker 安全</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#13-1-内核命名空间"><span class="nav-number">17.1.</span> <span class="nav-text">13.1. 内核命名空间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-2-控制组"><span class="nav-number">17.2.</span> <span class="nav-text">13.2. 控制组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-3-服务端防护"><span class="nav-number">17.3.</span> <span class="nav-text">13.3. 服务端防护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-4-内核能力机制"><span class="nav-number">17.4.</span> <span class="nav-text">13.4. 内核能力机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-5-其它安全特性"><span class="nav-number">17.5.</span> <span class="nav-text">13.5. 其它安全特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-6-安全总结"><span class="nav-number">17.6.</span> <span class="nav-text">13.6. 安全总结</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#14-docker-底层实现"><span class="nav-number">18.</span> <span class="nav-text">14.  docker 底层实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1-基本架构"><span class="nav-number">18.1.</span> <span class="nav-text">14.1. 基本架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2-命名空间"><span class="nav-number">18.2.</span> <span class="nav-text">14.2. 命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-1-pid-命名空间"><span class="nav-number">18.2.1.</span> <span class="nav-text">14.2.1.    pid 命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-2-net-命名空间"><span class="nav-number">18.2.2.</span> <span class="nav-text">14.2.2.    net 命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-3-ipc-命名空间"><span class="nav-number">18.2.3.</span> <span class="nav-text">14.2.3.    ipc 命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-4-mnt-命名空间"><span class="nav-number">18.2.4.</span> <span class="nav-text">14.2.4.    mnt 命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-5-uts-命名空间"><span class="nav-number">18.2.5.</span> <span class="nav-text">14.2.5.    uts 命名空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-2-6-user-命名空间"><span class="nav-number">18.2.6.</span> <span class="nav-text">14.2.6.    user 命名空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-3-控制组"><span class="nav-number">18.3.</span> <span class="nav-text">14.3. 控制组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-4-联合文件系统"><span class="nav-number">18.4.</span> <span class="nav-text">14.4. 联合文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-5-容器格式"><span class="nav-number">18.5.</span> <span class="nav-text">14.5. 容器格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-6-网络"><span class="nav-number">18.6.</span> <span class="nav-text">14.6. 网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#14-6-1-基本原理"><span class="nav-number">18.6.1.</span> <span class="nav-text">14.6.1.    基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-6-2-创建网络参数"><span class="nav-number">18.6.2.</span> <span class="nav-text">14.6.2.    创建网络参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-6-3-网络配置细节"><span class="nav-number">18.6.3.</span> <span class="nav-text">14.6.3.    网络配置细节</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#15-附录"><span class="nav-number">19.</span> <span class="nav-text">15.  附录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#15-1-Docker-命令查询"><span class="nav-number">19.1.</span> <span class="nav-text">15.1. Docker 命令查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-1-基本语法"><span class="nav-number">19.1.1.</span> <span class="nav-text">15.1.1.    基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-2-客户端命令选项"><span class="nav-number">19.1.2.</span> <span class="nav-text">15.1.2.    客户端命令选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-3-dockerd-命令选项"><span class="nav-number">19.1.3.</span> <span class="nav-text">15.1.3.    dockerd 命令选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-4-客户端命令"><span class="nav-number">19.1.4.</span> <span class="nav-text">15.1.4.    客户端命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-1-5-一张图总结-Docker-的命令"><span class="nav-number">19.1.5.</span> <span class="nav-text">15.1.5.    一张图总结 Docker 的命令</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-2-Docker-资源链接"><span class="nav-number">19.2.</span> <span class="nav-text">15.2. Docker 资源链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-1-官方网站"><span class="nav-number">19.2.1.</span> <span class="nav-text">15.2.1.    官方网站</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-2-实践参考"><span class="nav-number">19.2.2.</span> <span class="nav-text">15.2.2.    实践参考</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-3-技术交流"><span class="nav-number">19.2.3.</span> <span class="nav-text">15.2.3.    技术交流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-2-4-其它"><span class="nav-number">19.2.4.</span> <span class="nav-text">15.2.4.    其它</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">浩子</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
